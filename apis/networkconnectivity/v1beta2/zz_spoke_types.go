// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1beta2

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type InstancesInitParameters struct {

	// The IP address on the VM to use for peering.
	IPAddress *string `json:"ipAddress,omitempty" tf:"ip_address,omitempty"`

	// The URI of the virtual machine resource
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta2.Instance
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("self_link",true)
	VirtualMachine *string `json:"virtualMachine,omitempty" tf:"virtual_machine,omitempty"`

	// Reference to a Instance in compute to populate virtualMachine.
	// +kubebuilder:validation:Optional
	VirtualMachineRef *v1.Reference `json:"virtualMachineRef,omitempty" tf:"-"`

	// Selector for a Instance in compute to populate virtualMachine.
	// +kubebuilder:validation:Optional
	VirtualMachineSelector *v1.Selector `json:"virtualMachineSelector,omitempty" tf:"-"`
}

type InstancesObservation struct {

	// The IP address on the VM to use for peering.
	IPAddress *string `json:"ipAddress,omitempty" tf:"ip_address,omitempty"`

	// The URI of the virtual machine resource
	VirtualMachine *string `json:"virtualMachine,omitempty" tf:"virtual_machine,omitempty"`
}

type InstancesParameters struct {

	// The IP address on the VM to use for peering.
	// +kubebuilder:validation:Optional
	IPAddress *string `json:"ipAddress" tf:"ip_address,omitempty"`

	// The URI of the virtual machine resource
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta2.Instance
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("self_link",true)
	// +kubebuilder:validation:Optional
	VirtualMachine *string `json:"virtualMachine,omitempty" tf:"virtual_machine,omitempty"`

	// Reference to a Instance in compute to populate virtualMachine.
	// +kubebuilder:validation:Optional
	VirtualMachineRef *v1.Reference `json:"virtualMachineRef,omitempty" tf:"-"`

	// Selector for a Instance in compute to populate virtualMachine.
	// +kubebuilder:validation:Optional
	VirtualMachineSelector *v1.Selector `json:"virtualMachineSelector,omitempty" tf:"-"`
}

type LinkedInterconnectAttachmentsInitParameters struct {

	// IP ranges allowed to be included during import from hub (does not control transit connectivity).
	// The only allowed value for now is "ALL_IPV4_RANGES".
	IncludeImportRanges []*string `json:"includeImportRanges,omitempty" tf:"include_import_ranges,omitempty"`

	// A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
	SiteToSiteDataTransfer *bool `json:"siteToSiteDataTransfer,omitempty" tf:"site_to_site_data_transfer,omitempty"`

	// The URIs of linked interconnect attachment resources
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.InterconnectAttachment
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("self_link",true)
	Uris []*string `json:"uris,omitempty" tf:"uris,omitempty"`

	// References to InterconnectAttachment in compute to populate uris.
	// +kubebuilder:validation:Optional
	UrisRefs []v1.Reference `json:"urisRefs,omitempty" tf:"-"`

	// Selector for a list of InterconnectAttachment in compute to populate uris.
	// +kubebuilder:validation:Optional
	UrisSelector *v1.Selector `json:"urisSelector,omitempty" tf:"-"`
}

type LinkedInterconnectAttachmentsObservation struct {

	// IP ranges allowed to be included during import from hub (does not control transit connectivity).
	// The only allowed value for now is "ALL_IPV4_RANGES".
	IncludeImportRanges []*string `json:"includeImportRanges,omitempty" tf:"include_import_ranges,omitempty"`

	// A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
	SiteToSiteDataTransfer *bool `json:"siteToSiteDataTransfer,omitempty" tf:"site_to_site_data_transfer,omitempty"`

	// The URIs of linked interconnect attachment resources
	Uris []*string `json:"uris,omitempty" tf:"uris,omitempty"`
}

type LinkedInterconnectAttachmentsParameters struct {

	// IP ranges allowed to be included during import from hub (does not control transit connectivity).
	// The only allowed value for now is "ALL_IPV4_RANGES".
	// +kubebuilder:validation:Optional
	IncludeImportRanges []*string `json:"includeImportRanges,omitempty" tf:"include_import_ranges,omitempty"`

	// A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
	// +kubebuilder:validation:Optional
	SiteToSiteDataTransfer *bool `json:"siteToSiteDataTransfer" tf:"site_to_site_data_transfer,omitempty"`

	// The URIs of linked interconnect attachment resources
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.InterconnectAttachment
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("self_link",true)
	// +kubebuilder:validation:Optional
	Uris []*string `json:"uris,omitempty" tf:"uris,omitempty"`

	// References to InterconnectAttachment in compute to populate uris.
	// +kubebuilder:validation:Optional
	UrisRefs []v1.Reference `json:"urisRefs,omitempty" tf:"-"`

	// Selector for a list of InterconnectAttachment in compute to populate uris.
	// +kubebuilder:validation:Optional
	UrisSelector *v1.Selector `json:"urisSelector,omitempty" tf:"-"`
}

type LinkedProducerVPCNetworkInitParameters struct {

	// IP ranges encompassing the subnets to be excluded from peering.
	ExcludeExportRanges []*string `json:"excludeExportRanges,omitempty" tf:"exclude_export_ranges,omitempty"`

	// IP ranges allowed to be included from peering.
	IncludeExportRanges []*string `json:"includeExportRanges,omitempty" tf:"include_export_ranges,omitempty"`

	// The URI of the Service Consumer VPC that the Producer VPC is peered with.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.Network
	Network *string `json:"network,omitempty" tf:"network,omitempty"`

	// Reference to a Network in compute to populate network.
	// +kubebuilder:validation:Optional
	NetworkRef *v1.Reference `json:"networkRef,omitempty" tf:"-"`

	// Selector for a Network in compute to populate network.
	// +kubebuilder:validation:Optional
	NetworkSelector *v1.Selector `json:"networkSelector,omitempty" tf:"-"`

	// The name of the VPC peering between the Service Consumer VPC and the Producer VPC (defined in the Tenant project) which is added to the NCC hub. This peering must be in ACTIVE state.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/servicenetworking/v1beta1.Connection
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("peering",true)
	Peering *string `json:"peering,omitempty" tf:"peering,omitempty"`

	// Reference to a Connection in servicenetworking to populate peering.
	// +kubebuilder:validation:Optional
	PeeringRef *v1.Reference `json:"peeringRef,omitempty" tf:"-"`

	// Selector for a Connection in servicenetworking to populate peering.
	// +kubebuilder:validation:Optional
	PeeringSelector *v1.Selector `json:"peeringSelector,omitempty" tf:"-"`
}

type LinkedProducerVPCNetworkObservation struct {

	// IP ranges encompassing the subnets to be excluded from peering.
	ExcludeExportRanges []*string `json:"excludeExportRanges,omitempty" tf:"exclude_export_ranges,omitempty"`

	// IP ranges allowed to be included from peering.
	IncludeExportRanges []*string `json:"includeExportRanges,omitempty" tf:"include_export_ranges,omitempty"`

	// The URI of the Service Consumer VPC that the Producer VPC is peered with.
	Network *string `json:"network,omitempty" tf:"network,omitempty"`

	// The name of the VPC peering between the Service Consumer VPC and the Producer VPC (defined in the Tenant project) which is added to the NCC hub. This peering must be in ACTIVE state.
	Peering *string `json:"peering,omitempty" tf:"peering,omitempty"`

	// (Output)
	// The URI of the Producer VPC.
	ProducerNetwork *string `json:"producerNetwork,omitempty" tf:"producer_network,omitempty"`
}

type LinkedProducerVPCNetworkParameters struct {

	// IP ranges encompassing the subnets to be excluded from peering.
	// +kubebuilder:validation:Optional
	ExcludeExportRanges []*string `json:"excludeExportRanges,omitempty" tf:"exclude_export_ranges,omitempty"`

	// IP ranges allowed to be included from peering.
	// +kubebuilder:validation:Optional
	IncludeExportRanges []*string `json:"includeExportRanges,omitempty" tf:"include_export_ranges,omitempty"`

	// The URI of the Service Consumer VPC that the Producer VPC is peered with.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.Network
	// +kubebuilder:validation:Optional
	Network *string `json:"network,omitempty" tf:"network,omitempty"`

	// Reference to a Network in compute to populate network.
	// +kubebuilder:validation:Optional
	NetworkRef *v1.Reference `json:"networkRef,omitempty" tf:"-"`

	// Selector for a Network in compute to populate network.
	// +kubebuilder:validation:Optional
	NetworkSelector *v1.Selector `json:"networkSelector,omitempty" tf:"-"`

	// The name of the VPC peering between the Service Consumer VPC and the Producer VPC (defined in the Tenant project) which is added to the NCC hub. This peering must be in ACTIVE state.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/servicenetworking/v1beta1.Connection
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("peering",true)
	// +kubebuilder:validation:Optional
	Peering *string `json:"peering,omitempty" tf:"peering,omitempty"`

	// Reference to a Connection in servicenetworking to populate peering.
	// +kubebuilder:validation:Optional
	PeeringRef *v1.Reference `json:"peeringRef,omitempty" tf:"-"`

	// Selector for a Connection in servicenetworking to populate peering.
	// +kubebuilder:validation:Optional
	PeeringSelector *v1.Selector `json:"peeringSelector,omitempty" tf:"-"`
}

type LinkedRouterApplianceInstancesInitParameters struct {

	// IP ranges allowed to be included during import from hub (does not control transit connectivity).
	// The only allowed value for now is "ALL_IPV4_RANGES".
	IncludeImportRanges []*string `json:"includeImportRanges,omitempty" tf:"include_import_ranges,omitempty"`

	// The list of router appliance instances
	// Structure is documented below.
	Instances []InstancesInitParameters `json:"instances,omitempty" tf:"instances,omitempty"`

	// A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
	SiteToSiteDataTransfer *bool `json:"siteToSiteDataTransfer,omitempty" tf:"site_to_site_data_transfer,omitempty"`
}

type LinkedRouterApplianceInstancesObservation struct {

	// IP ranges allowed to be included during import from hub (does not control transit connectivity).
	// The only allowed value for now is "ALL_IPV4_RANGES".
	IncludeImportRanges []*string `json:"includeImportRanges,omitempty" tf:"include_import_ranges,omitempty"`

	// The list of router appliance instances
	// Structure is documented below.
	Instances []InstancesObservation `json:"instances,omitempty" tf:"instances,omitempty"`

	// A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
	SiteToSiteDataTransfer *bool `json:"siteToSiteDataTransfer,omitempty" tf:"site_to_site_data_transfer,omitempty"`
}

type LinkedRouterApplianceInstancesParameters struct {

	// IP ranges allowed to be included during import from hub (does not control transit connectivity).
	// The only allowed value for now is "ALL_IPV4_RANGES".
	// +kubebuilder:validation:Optional
	IncludeImportRanges []*string `json:"includeImportRanges,omitempty" tf:"include_import_ranges,omitempty"`

	// The list of router appliance instances
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Instances []InstancesParameters `json:"instances" tf:"instances,omitempty"`

	// A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
	// +kubebuilder:validation:Optional
	SiteToSiteDataTransfer *bool `json:"siteToSiteDataTransfer" tf:"site_to_site_data_transfer,omitempty"`
}

type LinkedVPCNetworkInitParameters struct {

	// IP ranges encompassing the subnets to be excluded from peering.
	ExcludeExportRanges []*string `json:"excludeExportRanges,omitempty" tf:"exclude_export_ranges,omitempty"`

	// IP ranges allowed to be included from peering.
	IncludeExportRanges []*string `json:"includeExportRanges,omitempty" tf:"include_export_ranges,omitempty"`

	// The URI of the VPC network resource.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.Network
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("self_link",true)
	URI *string `json:"uri,omitempty" tf:"uri,omitempty"`

	// Reference to a Network in compute to populate uri.
	// +kubebuilder:validation:Optional
	URIRef *v1.Reference `json:"uriRef,omitempty" tf:"-"`

	// Selector for a Network in compute to populate uri.
	// +kubebuilder:validation:Optional
	URISelector *v1.Selector `json:"uriSelector,omitempty" tf:"-"`
}

type LinkedVPCNetworkObservation struct {

	// IP ranges encompassing the subnets to be excluded from peering.
	ExcludeExportRanges []*string `json:"excludeExportRanges,omitempty" tf:"exclude_export_ranges,omitempty"`

	// IP ranges allowed to be included from peering.
	IncludeExportRanges []*string `json:"includeExportRanges,omitempty" tf:"include_export_ranges,omitempty"`

	// The URI of the VPC network resource.
	URI *string `json:"uri,omitempty" tf:"uri,omitempty"`
}

type LinkedVPCNetworkParameters struct {

	// IP ranges encompassing the subnets to be excluded from peering.
	// +kubebuilder:validation:Optional
	ExcludeExportRanges []*string `json:"excludeExportRanges,omitempty" tf:"exclude_export_ranges,omitempty"`

	// IP ranges allowed to be included from peering.
	// +kubebuilder:validation:Optional
	IncludeExportRanges []*string `json:"includeExportRanges,omitempty" tf:"include_export_ranges,omitempty"`

	// The URI of the VPC network resource.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.Network
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("self_link",true)
	// +kubebuilder:validation:Optional
	URI *string `json:"uri,omitempty" tf:"uri,omitempty"`

	// Reference to a Network in compute to populate uri.
	// +kubebuilder:validation:Optional
	URIRef *v1.Reference `json:"uriRef,omitempty" tf:"-"`

	// Selector for a Network in compute to populate uri.
	// +kubebuilder:validation:Optional
	URISelector *v1.Selector `json:"uriSelector,omitempty" tf:"-"`
}

type LinkedVPNTunnelsInitParameters struct {

	// IP ranges allowed to be included during import from hub (does not control transit connectivity).
	// The only allowed value for now is "ALL_IPV4_RANGES".
	IncludeImportRanges []*string `json:"includeImportRanges,omitempty" tf:"include_import_ranges,omitempty"`

	// A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
	SiteToSiteDataTransfer *bool `json:"siteToSiteDataTransfer,omitempty" tf:"site_to_site_data_transfer,omitempty"`

	// The URIs of linked VPN tunnel resources.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.VPNTunnel
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("self_link",true)
	Uris []*string `json:"uris,omitempty" tf:"uris,omitempty"`

	// References to VPNTunnel in compute to populate uris.
	// +kubebuilder:validation:Optional
	UrisRefs []v1.Reference `json:"urisRefs,omitempty" tf:"-"`

	// Selector for a list of VPNTunnel in compute to populate uris.
	// +kubebuilder:validation:Optional
	UrisSelector *v1.Selector `json:"urisSelector,omitempty" tf:"-"`
}

type LinkedVPNTunnelsObservation struct {

	// IP ranges allowed to be included during import from hub (does not control transit connectivity).
	// The only allowed value for now is "ALL_IPV4_RANGES".
	IncludeImportRanges []*string `json:"includeImportRanges,omitempty" tf:"include_import_ranges,omitempty"`

	// A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
	SiteToSiteDataTransfer *bool `json:"siteToSiteDataTransfer,omitempty" tf:"site_to_site_data_transfer,omitempty"`

	// The URIs of linked VPN tunnel resources.
	Uris []*string `json:"uris,omitempty" tf:"uris,omitempty"`
}

type LinkedVPNTunnelsParameters struct {

	// IP ranges allowed to be included during import from hub (does not control transit connectivity).
	// The only allowed value for now is "ALL_IPV4_RANGES".
	// +kubebuilder:validation:Optional
	IncludeImportRanges []*string `json:"includeImportRanges,omitempty" tf:"include_import_ranges,omitempty"`

	// A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
	// +kubebuilder:validation:Optional
	SiteToSiteDataTransfer *bool `json:"siteToSiteDataTransfer" tf:"site_to_site_data_transfer,omitempty"`

	// The URIs of linked VPN tunnel resources.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.VPNTunnel
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("self_link",true)
	// +kubebuilder:validation:Optional
	Uris []*string `json:"uris,omitempty" tf:"uris,omitempty"`

	// References to VPNTunnel in compute to populate uris.
	// +kubebuilder:validation:Optional
	UrisRefs []v1.Reference `json:"urisRefs,omitempty" tf:"-"`

	// Selector for a list of VPNTunnel in compute to populate uris.
	// +kubebuilder:validation:Optional
	UrisSelector *v1.Selector `json:"urisSelector,omitempty" tf:"-"`
}

type ReasonsInitParameters struct {
}

type ReasonsObservation struct {

	// The code associated with this reason.
	Code *string `json:"code,omitempty" tf:"code,omitempty"`

	// Human-readable details about this reason.
	Message *string `json:"message,omitempty" tf:"message,omitempty"`

	// Additional information provided by the user in the RejectSpoke call.
	UserDetails *string `json:"userDetails,omitempty" tf:"user_details,omitempty"`
}

type ReasonsParameters struct {
}

type SpokeInitParameters struct {

	// An optional description of the spoke.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The name of the group that this spoke is associated with.
	Group *string `json:"group,omitempty" tf:"group,omitempty"`

	// Immutable. The URI of the hub that this spoke is attached to.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/networkconnectivity/v1beta1.Hub
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	Hub *string `json:"hub,omitempty" tf:"hub,omitempty"`

	// Reference to a Hub in networkconnectivity to populate hub.
	// +kubebuilder:validation:Optional
	HubRef *v1.Reference `json:"hubRef,omitempty" tf:"-"`

	// Selector for a Hub in networkconnectivity to populate hub.
	// +kubebuilder:validation:Optional
	HubSelector *v1.Selector `json:"hubSelector,omitempty" tf:"-"`

	// Optional labels in key:value format. For more information about labels, see Requirements for labels.
	// Note: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field effective_labels for all of the labels present on the resource.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// A collection of VLAN attachment resources. These resources should be redundant attachments that all advertise the same prefixes to Google Cloud. Alternatively, in active/passive configurations, all attachments should be capable of advertising the same prefixes.
	// Structure is documented below.
	LinkedInterconnectAttachments *LinkedInterconnectAttachmentsInitParameters `json:"linkedInterconnectAttachments,omitempty" tf:"linked_interconnect_attachments,omitempty"`

	// Producer VPC network that is associated with the spoke.
	// Structure is documented below.
	LinkedProducerVPCNetwork *LinkedProducerVPCNetworkInitParameters `json:"linkedProducerVpcNetwork,omitempty" tf:"linked_producer_vpc_network,omitempty"`

	// The URIs of linked Router appliance resources
	// Structure is documented below.
	LinkedRouterApplianceInstances *LinkedRouterApplianceInstancesInitParameters `json:"linkedRouterApplianceInstances,omitempty" tf:"linked_router_appliance_instances,omitempty"`

	// VPC network that is associated with the spoke.
	// Structure is documented below.
	LinkedVPCNetwork *LinkedVPCNetworkInitParameters `json:"linkedVpcNetwork,omitempty" tf:"linked_vpc_network,omitempty"`

	// The URIs of linked VPN tunnel resources
	// Structure is documented below.
	LinkedVPNTunnels *LinkedVPNTunnelsInitParameters `json:"linkedVpnTunnels,omitempty" tf:"linked_vpn_tunnels,omitempty"`

	// The location for the resource
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// Immutable. The name of the spoke. Spoke names must be unique.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `json:"project,omitempty" tf:"project,omitempty"`
}

type SpokeObservation struct {

	// Output only. The time the spoke was created.
	CreateTime *string `json:"createTime,omitempty" tf:"create_time,omitempty"`

	// An optional description of the spoke.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +mapType=granular
	EffectiveLabels map[string]*string `json:"effectiveLabels,omitempty" tf:"effective_labels,omitempty"`

	// The name of the group that this spoke is associated with.
	Group *string `json:"group,omitempty" tf:"group,omitempty"`

	// Immutable. The URI of the hub that this spoke is attached to.
	Hub *string `json:"hub,omitempty" tf:"hub,omitempty"`

	// an identifier for the resource with format projects/{{project}}/locations/{{location}}/spokes/{{name}}
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Optional labels in key:value format. For more information about labels, see Requirements for labels.
	// Note: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field effective_labels for all of the labels present on the resource.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// A collection of VLAN attachment resources. These resources should be redundant attachments that all advertise the same prefixes to Google Cloud. Alternatively, in active/passive configurations, all attachments should be capable of advertising the same prefixes.
	// Structure is documented below.
	LinkedInterconnectAttachments *LinkedInterconnectAttachmentsObservation `json:"linkedInterconnectAttachments,omitempty" tf:"linked_interconnect_attachments,omitempty"`

	// Producer VPC network that is associated with the spoke.
	// Structure is documented below.
	LinkedProducerVPCNetwork *LinkedProducerVPCNetworkObservation `json:"linkedProducerVpcNetwork,omitempty" tf:"linked_producer_vpc_network,omitempty"`

	// The URIs of linked Router appliance resources
	// Structure is documented below.
	LinkedRouterApplianceInstances *LinkedRouterApplianceInstancesObservation `json:"linkedRouterApplianceInstances,omitempty" tf:"linked_router_appliance_instances,omitempty"`

	// VPC network that is associated with the spoke.
	// Structure is documented below.
	LinkedVPCNetwork *LinkedVPCNetworkObservation `json:"linkedVpcNetwork,omitempty" tf:"linked_vpc_network,omitempty"`

	// The URIs of linked VPN tunnel resources
	// Structure is documented below.
	LinkedVPNTunnels *LinkedVPNTunnelsObservation `json:"linkedVpnTunnels,omitempty" tf:"linked_vpn_tunnels,omitempty"`

	// The location for the resource
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// Immutable. The name of the spoke. Spoke names must be unique.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// The reasons for the current state in the lifecycle
	// Structure is documented below.
	Reasons []ReasonsObservation `json:"reasons,omitempty" tf:"reasons,omitempty"`

	// Output only. The current lifecycle state of this spoke.
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// The combination of labels configured directly on the resource
	// and default labels configured on the provider.
	// +mapType=granular
	TerraformLabels map[string]*string `json:"terraformLabels,omitempty" tf:"terraform_labels,omitempty"`

	// Output only. The Google-generated UUID for the spoke. This value is unique across all spoke resources. If a spoke is deleted and another with the same name is created, the new spoke is assigned a different unique_id.
	UniqueID *string `json:"uniqueId,omitempty" tf:"unique_id,omitempty"`

	// Output only. The time the spoke was last updated.
	UpdateTime *string `json:"updateTime,omitempty" tf:"update_time,omitempty"`
}

type SpokeParameters struct {

	// An optional description of the spoke.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The name of the group that this spoke is associated with.
	// +kubebuilder:validation:Optional
	Group *string `json:"group,omitempty" tf:"group,omitempty"`

	// Immutable. The URI of the hub that this spoke is attached to.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/networkconnectivity/v1beta1.Hub
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	Hub *string `json:"hub,omitempty" tf:"hub,omitempty"`

	// Reference to a Hub in networkconnectivity to populate hub.
	// +kubebuilder:validation:Optional
	HubRef *v1.Reference `json:"hubRef,omitempty" tf:"-"`

	// Selector for a Hub in networkconnectivity to populate hub.
	// +kubebuilder:validation:Optional
	HubSelector *v1.Selector `json:"hubSelector,omitempty" tf:"-"`

	// Optional labels in key:value format. For more information about labels, see Requirements for labels.
	// Note: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field effective_labels for all of the labels present on the resource.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// A collection of VLAN attachment resources. These resources should be redundant attachments that all advertise the same prefixes to Google Cloud. Alternatively, in active/passive configurations, all attachments should be capable of advertising the same prefixes.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	LinkedInterconnectAttachments *LinkedInterconnectAttachmentsParameters `json:"linkedInterconnectAttachments,omitempty" tf:"linked_interconnect_attachments,omitempty"`

	// Producer VPC network that is associated with the spoke.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	LinkedProducerVPCNetwork *LinkedProducerVPCNetworkParameters `json:"linkedProducerVpcNetwork,omitempty" tf:"linked_producer_vpc_network,omitempty"`

	// The URIs of linked Router appliance resources
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	LinkedRouterApplianceInstances *LinkedRouterApplianceInstancesParameters `json:"linkedRouterApplianceInstances,omitempty" tf:"linked_router_appliance_instances,omitempty"`

	// VPC network that is associated with the spoke.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	LinkedVPCNetwork *LinkedVPCNetworkParameters `json:"linkedVpcNetwork,omitempty" tf:"linked_vpc_network,omitempty"`

	// The URIs of linked VPN tunnel resources
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	LinkedVPNTunnels *LinkedVPNTunnelsParameters `json:"linkedVpnTunnels,omitempty" tf:"linked_vpn_tunnels,omitempty"`

	// The location for the resource
	// +kubebuilder:validation:Optional
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// Immutable. The name of the spoke. Spoke names must be unique.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	// +kubebuilder:validation:Optional
	Project *string `json:"project,omitempty" tf:"project,omitempty"`
}

// SpokeSpec defines the desired state of Spoke
type SpokeSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     SpokeParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider SpokeInitParameters `json:"initProvider,omitempty"`
}

// SpokeStatus defines the observed state of Spoke.
type SpokeStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        SpokeObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status

// Spoke is the Schema for the Spokes API. The NetworkConnectivity Spoke resource
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcp}
type Spoke struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.location) || (has(self.initProvider) && has(self.initProvider.location))",message="spec.forProvider.location is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	Spec   SpokeSpec   `json:"spec"`
	Status SpokeStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// SpokeList contains a list of Spokes
type SpokeList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Spoke `json:"items"`
}

// Repository type metadata.
var (
	Spoke_Kind             = "Spoke"
	Spoke_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Spoke_Kind}.String()
	Spoke_KindAPIVersion   = Spoke_Kind + "." + CRDGroupVersion.String()
	Spoke_GroupVersionKind = CRDGroupVersion.WithKind(Spoke_Kind)
)

func init() {
	SchemeBuilder.Register(&Spoke{}, &SpokeList{})
}
