// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AvroConfigInitParameters struct {

	// When true, writes the Pub/Sub message metadata to
	// x-goog-pubsub-<KEY>:<VAL> headers of the HTTP request. Writes the
	// Pub/Sub message attributes to <KEY>:<VAL> headers of the HTTP request.
	WriteMetadata *bool `json:"writeMetadata,omitempty" tf:"write_metadata,omitempty"`
}

type AvroConfigObservation struct {

	// When true, writes the Pub/Sub message metadata to
	// x-goog-pubsub-<KEY>:<VAL> headers of the HTTP request. Writes the
	// Pub/Sub message attributes to <KEY>:<VAL> headers of the HTTP request.
	WriteMetadata *bool `json:"writeMetadata,omitempty" tf:"write_metadata,omitempty"`
}

type AvroConfigParameters struct {

	// When true, writes the Pub/Sub message metadata to
	// x-goog-pubsub-<KEY>:<VAL> headers of the HTTP request. Writes the
	// Pub/Sub message attributes to <KEY>:<VAL> headers of the HTTP request.
	// +kubebuilder:validation:Optional
	WriteMetadata *bool `json:"writeMetadata,omitempty" tf:"write_metadata,omitempty"`
}

type BigqueryConfigInitParameters struct {

	// When true and use_topic_schema or use_table_schema is true, any fields that are a part of the topic schema or message schema that
	// are not part of the BigQuery table schema are dropped when writing to BigQuery. Otherwise, the schemas must be kept in sync
	// and any messages with extra fields are not written and remain in the subscription's backlog.
	DropUnknownFields *bool `json:"dropUnknownFields,omitempty" tf:"drop_unknown_fields,omitempty"`

	// The name of the table to which to write data, of the form {projectId}:{datasetId}.{tableId}
	Table *string `json:"table,omitempty" tf:"table,omitempty"`

	// When true, use the BigQuery table's schema as the columns to write to in BigQuery. Messages
	// must be published in JSON format. Only one of use_topic_schema and use_table_schema can be set.
	UseTableSchema *bool `json:"useTableSchema,omitempty" tf:"use_table_schema,omitempty"`

	// When true, use the topic's schema as the columns to write to in BigQuery, if it exists.
	// Only one of use_topic_schema and use_table_schema can be set.
	UseTopicSchema *bool `json:"useTopicSchema,omitempty" tf:"use_topic_schema,omitempty"`

	// When true, write the subscription name, messageId, publishTime, attributes, and orderingKey to additional columns in the table.
	// The subscription name, messageId, and publishTime fields are put in their own columns while all other message properties (other than data) are written to a JSON object in the attributes column.
	WriteMetadata *bool `json:"writeMetadata,omitempty" tf:"write_metadata,omitempty"`
}

type BigqueryConfigObservation struct {

	// When true and use_topic_schema or use_table_schema is true, any fields that are a part of the topic schema or message schema that
	// are not part of the BigQuery table schema are dropped when writing to BigQuery. Otherwise, the schemas must be kept in sync
	// and any messages with extra fields are not written and remain in the subscription's backlog.
	DropUnknownFields *bool `json:"dropUnknownFields,omitempty" tf:"drop_unknown_fields,omitempty"`

	// The name of the table to which to write data, of the form {projectId}:{datasetId}.{tableId}
	Table *string `json:"table,omitempty" tf:"table,omitempty"`

	// When true, use the BigQuery table's schema as the columns to write to in BigQuery. Messages
	// must be published in JSON format. Only one of use_topic_schema and use_table_schema can be set.
	UseTableSchema *bool `json:"useTableSchema,omitempty" tf:"use_table_schema,omitempty"`

	// When true, use the topic's schema as the columns to write to in BigQuery, if it exists.
	// Only one of use_topic_schema and use_table_schema can be set.
	UseTopicSchema *bool `json:"useTopicSchema,omitempty" tf:"use_topic_schema,omitempty"`

	// When true, write the subscription name, messageId, publishTime, attributes, and orderingKey to additional columns in the table.
	// The subscription name, messageId, and publishTime fields are put in their own columns while all other message properties (other than data) are written to a JSON object in the attributes column.
	WriteMetadata *bool `json:"writeMetadata,omitempty" tf:"write_metadata,omitempty"`
}

type BigqueryConfigParameters struct {

	// When true and use_topic_schema or use_table_schema is true, any fields that are a part of the topic schema or message schema that
	// are not part of the BigQuery table schema are dropped when writing to BigQuery. Otherwise, the schemas must be kept in sync
	// and any messages with extra fields are not written and remain in the subscription's backlog.
	// +kubebuilder:validation:Optional
	DropUnknownFields *bool `json:"dropUnknownFields,omitempty" tf:"drop_unknown_fields,omitempty"`

	// The name of the table to which to write data, of the form {projectId}:{datasetId}.{tableId}
	// +kubebuilder:validation:Optional
	Table *string `json:"table" tf:"table,omitempty"`

	// When true, use the BigQuery table's schema as the columns to write to in BigQuery. Messages
	// must be published in JSON format. Only one of use_topic_schema and use_table_schema can be set.
	// +kubebuilder:validation:Optional
	UseTableSchema *bool `json:"useTableSchema,omitempty" tf:"use_table_schema,omitempty"`

	// When true, use the topic's schema as the columns to write to in BigQuery, if it exists.
	// Only one of use_topic_schema and use_table_schema can be set.
	// +kubebuilder:validation:Optional
	UseTopicSchema *bool `json:"useTopicSchema,omitempty" tf:"use_topic_schema,omitempty"`

	// When true, write the subscription name, messageId, publishTime, attributes, and orderingKey to additional columns in the table.
	// The subscription name, messageId, and publishTime fields are put in their own columns while all other message properties (other than data) are written to a JSON object in the attributes column.
	// +kubebuilder:validation:Optional
	WriteMetadata *bool `json:"writeMetadata,omitempty" tf:"write_metadata,omitempty"`
}

type CloudStorageConfigInitParameters struct {

	// If set, message data will be written to Cloud Storage in Avro format.
	// Structure is documented below.
	AvroConfig []AvroConfigInitParameters `json:"avroConfig,omitempty" tf:"avro_config,omitempty"`

	// User-provided name for the Cloud Storage bucket. The bucket must be created by the user. The bucket name must be without any prefix like "gs://".
	Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

	// User-provided prefix for Cloud Storage filename.
	FilenamePrefix *string `json:"filenamePrefix,omitempty" tf:"filename_prefix,omitempty"`

	// User-provided suffix for Cloud Storage filename. Must not end in "/".
	FilenameSuffix *string `json:"filenameSuffix,omitempty" tf:"filename_suffix,omitempty"`

	// The maximum bytes that can be written to a Cloud Storage file before a new file is created. Min 1 KB, max 10 GiB.
	// The maxBytes limit may be exceeded in cases where messages are larger than the limit.
	MaxBytes *float64 `json:"maxBytes,omitempty" tf:"max_bytes,omitempty"`

	// The maximum duration that can elapse before a new Cloud Storage file is created. Min 1 minute, max 10 minutes, default 5 minutes.
	// May not exceed the subscription's acknowledgement deadline.
	// A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
	MaxDuration *string `json:"maxDuration,omitempty" tf:"max_duration,omitempty"`
}

type CloudStorageConfigObservation struct {

	// If set, message data will be written to Cloud Storage in Avro format.
	// Structure is documented below.
	AvroConfig []AvroConfigObservation `json:"avroConfig,omitempty" tf:"avro_config,omitempty"`

	// User-provided name for the Cloud Storage bucket. The bucket must be created by the user. The bucket name must be without any prefix like "gs://".
	Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

	// User-provided prefix for Cloud Storage filename.
	FilenamePrefix *string `json:"filenamePrefix,omitempty" tf:"filename_prefix,omitempty"`

	// User-provided suffix for Cloud Storage filename. Must not end in "/".
	FilenameSuffix *string `json:"filenameSuffix,omitempty" tf:"filename_suffix,omitempty"`

	// The maximum bytes that can be written to a Cloud Storage file before a new file is created. Min 1 KB, max 10 GiB.
	// The maxBytes limit may be exceeded in cases where messages are larger than the limit.
	MaxBytes *float64 `json:"maxBytes,omitempty" tf:"max_bytes,omitempty"`

	// The maximum duration that can elapse before a new Cloud Storage file is created. Min 1 minute, max 10 minutes, default 5 minutes.
	// May not exceed the subscription's acknowledgement deadline.
	// A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
	MaxDuration *string `json:"maxDuration,omitempty" tf:"max_duration,omitempty"`

	// (Output)
	// An output-only field that indicates whether or not the subscription can receive messages.
	State *string `json:"state,omitempty" tf:"state,omitempty"`
}

type CloudStorageConfigParameters struct {

	// If set, message data will be written to Cloud Storage in Avro format.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	AvroConfig []AvroConfigParameters `json:"avroConfig,omitempty" tf:"avro_config,omitempty"`

	// User-provided name for the Cloud Storage bucket. The bucket must be created by the user. The bucket name must be without any prefix like "gs://".
	// +kubebuilder:validation:Optional
	Bucket *string `json:"bucket" tf:"bucket,omitempty"`

	// User-provided prefix for Cloud Storage filename.
	// +kubebuilder:validation:Optional
	FilenamePrefix *string `json:"filenamePrefix,omitempty" tf:"filename_prefix,omitempty"`

	// User-provided suffix for Cloud Storage filename. Must not end in "/".
	// +kubebuilder:validation:Optional
	FilenameSuffix *string `json:"filenameSuffix,omitempty" tf:"filename_suffix,omitempty"`

	// The maximum bytes that can be written to a Cloud Storage file before a new file is created. Min 1 KB, max 10 GiB.
	// The maxBytes limit may be exceeded in cases where messages are larger than the limit.
	// +kubebuilder:validation:Optional
	MaxBytes *float64 `json:"maxBytes,omitempty" tf:"max_bytes,omitempty"`

	// The maximum duration that can elapse before a new Cloud Storage file is created. Min 1 minute, max 10 minutes, default 5 minutes.
	// May not exceed the subscription's acknowledgement deadline.
	// A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
	// +kubebuilder:validation:Optional
	MaxDuration *string `json:"maxDuration,omitempty" tf:"max_duration,omitempty"`
}

type DeadLetterPolicyInitParameters struct {

	// The name of the topic to which dead letter messages should be published.
	// Format is projects/{project}/topics/{topic}.
	// The Cloud Pub/Sub service account associated with the enclosing subscription's
	// parent project (i.e.,
	// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
	// permission to Publish() to this topic.
	// The operation will fail if the topic does not exist.
	// Users should ensure that there is a subscription attached to this topic
	// since messages published to a topic with no subscriptions are lost.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/pubsub/v1beta1.Topic
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	DeadLetterTopic *string `json:"deadLetterTopic,omitempty" tf:"dead_letter_topic,omitempty"`

	// Reference to a Topic in pubsub to populate deadLetterTopic.
	// +kubebuilder:validation:Optional
	DeadLetterTopicRef *v1.Reference `json:"deadLetterTopicRef,omitempty" tf:"-"`

	// Selector for a Topic in pubsub to populate deadLetterTopic.
	// +kubebuilder:validation:Optional
	DeadLetterTopicSelector *v1.Selector `json:"deadLetterTopicSelector,omitempty" tf:"-"`

	// The maximum number of delivery attempts for any message. The value must be
	// between 5 and 100.
	// The number of delivery attempts is defined as 1 + (the sum of number of
	// NACKs and number of times the acknowledgement deadline has been exceeded for the message).
	// A NACK is any call to ModifyAckDeadline with a 0 deadline. Note that
	// client libraries may automatically extend ack_deadlines.
	// This field will be honored on a best effort basis.
	// If this parameter is 0, a default value of 5 is used.
	MaxDeliveryAttempts *float64 `json:"maxDeliveryAttempts,omitempty" tf:"max_delivery_attempts,omitempty"`
}

type DeadLetterPolicyObservation struct {

	// The name of the topic to which dead letter messages should be published.
	// Format is projects/{project}/topics/{topic}.
	// The Cloud Pub/Sub service account associated with the enclosing subscription's
	// parent project (i.e.,
	// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
	// permission to Publish() to this topic.
	// The operation will fail if the topic does not exist.
	// Users should ensure that there is a subscription attached to this topic
	// since messages published to a topic with no subscriptions are lost.
	DeadLetterTopic *string `json:"deadLetterTopic,omitempty" tf:"dead_letter_topic,omitempty"`

	// The maximum number of delivery attempts for any message. The value must be
	// between 5 and 100.
	// The number of delivery attempts is defined as 1 + (the sum of number of
	// NACKs and number of times the acknowledgement deadline has been exceeded for the message).
	// A NACK is any call to ModifyAckDeadline with a 0 deadline. Note that
	// client libraries may automatically extend ack_deadlines.
	// This field will be honored on a best effort basis.
	// If this parameter is 0, a default value of 5 is used.
	MaxDeliveryAttempts *float64 `json:"maxDeliveryAttempts,omitempty" tf:"max_delivery_attempts,omitempty"`
}

type DeadLetterPolicyParameters struct {

	// The name of the topic to which dead letter messages should be published.
	// Format is projects/{project}/topics/{topic}.
	// The Cloud Pub/Sub service account associated with the enclosing subscription's
	// parent project (i.e.,
	// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
	// permission to Publish() to this topic.
	// The operation will fail if the topic does not exist.
	// Users should ensure that there is a subscription attached to this topic
	// since messages published to a topic with no subscriptions are lost.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/pubsub/v1beta1.Topic
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	DeadLetterTopic *string `json:"deadLetterTopic,omitempty" tf:"dead_letter_topic,omitempty"`

	// Reference to a Topic in pubsub to populate deadLetterTopic.
	// +kubebuilder:validation:Optional
	DeadLetterTopicRef *v1.Reference `json:"deadLetterTopicRef,omitempty" tf:"-"`

	// Selector for a Topic in pubsub to populate deadLetterTopic.
	// +kubebuilder:validation:Optional
	DeadLetterTopicSelector *v1.Selector `json:"deadLetterTopicSelector,omitempty" tf:"-"`

	// The maximum number of delivery attempts for any message. The value must be
	// between 5 and 100.
	// The number of delivery attempts is defined as 1 + (the sum of number of
	// NACKs and number of times the acknowledgement deadline has been exceeded for the message).
	// A NACK is any call to ModifyAckDeadline with a 0 deadline. Note that
	// client libraries may automatically extend ack_deadlines.
	// This field will be honored on a best effort basis.
	// If this parameter is 0, a default value of 5 is used.
	// +kubebuilder:validation:Optional
	MaxDeliveryAttempts *float64 `json:"maxDeliveryAttempts,omitempty" tf:"max_delivery_attempts,omitempty"`
}

type ExpirationPolicyInitParameters struct {

	// Specifies the "time-to-live" duration for an associated resource. The
	// resource expires if it is not active for a period of ttl.
	// If ttl is set to "", the associated resource never expires.
	// A duration in seconds with up to nine fractional digits, terminated by 's'.
	// Example - "3.5s".
	TTL *string `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type ExpirationPolicyObservation struct {

	// Specifies the "time-to-live" duration for an associated resource. The
	// resource expires if it is not active for a period of ttl.
	// If ttl is set to "", the associated resource never expires.
	// A duration in seconds with up to nine fractional digits, terminated by 's'.
	// Example - "3.5s".
	TTL *string `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type ExpirationPolicyParameters struct {

	// Specifies the "time-to-live" duration for an associated resource. The
	// resource expires if it is not active for a period of ttl.
	// If ttl is set to "", the associated resource never expires.
	// A duration in seconds with up to nine fractional digits, terminated by 's'.
	// Example - "3.5s".
	// +kubebuilder:validation:Optional
	TTL *string `json:"ttl" tf:"ttl,omitempty"`
}

type NoWrapperInitParameters struct {

	// When true, writes the Pub/Sub message metadata to
	// x-goog-pubsub-<KEY>:<VAL> headers of the HTTP request. Writes the
	// Pub/Sub message attributes to <KEY>:<VAL> headers of the HTTP request.
	WriteMetadata *bool `json:"writeMetadata,omitempty" tf:"write_metadata,omitempty"`
}

type NoWrapperObservation struct {

	// When true, writes the Pub/Sub message metadata to
	// x-goog-pubsub-<KEY>:<VAL> headers of the HTTP request. Writes the
	// Pub/Sub message attributes to <KEY>:<VAL> headers of the HTTP request.
	WriteMetadata *bool `json:"writeMetadata,omitempty" tf:"write_metadata,omitempty"`
}

type NoWrapperParameters struct {

	// When true, writes the Pub/Sub message metadata to
	// x-goog-pubsub-<KEY>:<VAL> headers of the HTTP request. Writes the
	// Pub/Sub message attributes to <KEY>:<VAL> headers of the HTTP request.
	// +kubebuilder:validation:Optional
	WriteMetadata *bool `json:"writeMetadata" tf:"write_metadata,omitempty"`
}

type OidcTokenInitParameters struct {

	// Audience to be used when generating OIDC token. The audience claim
	// identifies the recipients that the JWT is intended for. The audience
	// value is a single case-sensitive string. Having multiple values (array)
	// for the audience field is not supported. More info about the OIDC JWT
	// token audience here: https://tools.ietf.org/html/rfc7519#section-4.1.3
	// Note: if not specified, the Push endpoint URL will be used.
	Audience *string `json:"audience,omitempty" tf:"audience,omitempty"`

	// Service account email to be used for generating the OIDC token.
	// The caller (for subscriptions.create, subscriptions.patch, and
	// subscriptions.modifyPushConfig RPCs) must have the
	// iam.serviceAccounts.actAs permission for the service account.
	ServiceAccountEmail *string `json:"serviceAccountEmail,omitempty" tf:"service_account_email,omitempty"`
}

type OidcTokenObservation struct {

	// Audience to be used when generating OIDC token. The audience claim
	// identifies the recipients that the JWT is intended for. The audience
	// value is a single case-sensitive string. Having multiple values (array)
	// for the audience field is not supported. More info about the OIDC JWT
	// token audience here: https://tools.ietf.org/html/rfc7519#section-4.1.3
	// Note: if not specified, the Push endpoint URL will be used.
	Audience *string `json:"audience,omitempty" tf:"audience,omitempty"`

	// Service account email to be used for generating the OIDC token.
	// The caller (for subscriptions.create, subscriptions.patch, and
	// subscriptions.modifyPushConfig RPCs) must have the
	// iam.serviceAccounts.actAs permission for the service account.
	ServiceAccountEmail *string `json:"serviceAccountEmail,omitempty" tf:"service_account_email,omitempty"`
}

type OidcTokenParameters struct {

	// Audience to be used when generating OIDC token. The audience claim
	// identifies the recipients that the JWT is intended for. The audience
	// value is a single case-sensitive string. Having multiple values (array)
	// for the audience field is not supported. More info about the OIDC JWT
	// token audience here: https://tools.ietf.org/html/rfc7519#section-4.1.3
	// Note: if not specified, the Push endpoint URL will be used.
	// +kubebuilder:validation:Optional
	Audience *string `json:"audience,omitempty" tf:"audience,omitempty"`

	// Service account email to be used for generating the OIDC token.
	// The caller (for subscriptions.create, subscriptions.patch, and
	// subscriptions.modifyPushConfig RPCs) must have the
	// iam.serviceAccounts.actAs permission for the service account.
	// +kubebuilder:validation:Optional
	ServiceAccountEmail *string `json:"serviceAccountEmail" tf:"service_account_email,omitempty"`
}

type PushConfigInitParameters struct {

	// Endpoint configuration attributes.
	// Every endpoint has a set of API supported attributes that can
	// be used to control different aspects of the message delivery.
	// The currently supported attribute is x-goog-version, which you
	// can use to change the format of the pushed message. This
	// attribute indicates the version of the data expected by
	// the endpoint. This controls the shape of the pushed message
	// (i.e., its fields and metadata). The endpoint version is
	// based on the version of the Pub/Sub API.
	// If not present during the subscriptions.create call,
	// it will default to the version of the API used to make
	// such call. If not present during a subscriptions.modifyPushConfig
	// call, its value will not be changed. subscriptions.get
	// calls will always return a valid version, even if the
	// subscription was created without this attribute.
	// The possible values for this attribute are:
	// +mapType=granular
	Attributes map[string]*string `json:"attributes,omitempty" tf:"attributes,omitempty"`

	// When set, the payload to the push endpoint is not wrapped.Sets the
	// data field as the HTTP body for delivery.
	// Structure is documented below.
	NoWrapper []NoWrapperInitParameters `json:"noWrapper,omitempty" tf:"no_wrapper,omitempty"`

	// If specified, Pub/Sub will generate and attach an OIDC JWT token as
	// an Authorization header in the HTTP request for every pushed message.
	// Structure is documented below.
	OidcToken []OidcTokenInitParameters `json:"oidcToken,omitempty" tf:"oidc_token,omitempty"`

	// A URL locating the endpoint to which messages should be pushed.
	// For example, a Webhook endpoint might use
	// "https://example.com/push".
	PushEndpoint *string `json:"pushEndpoint,omitempty" tf:"push_endpoint,omitempty"`
}

type PushConfigObservation struct {

	// Endpoint configuration attributes.
	// Every endpoint has a set of API supported attributes that can
	// be used to control different aspects of the message delivery.
	// The currently supported attribute is x-goog-version, which you
	// can use to change the format of the pushed message. This
	// attribute indicates the version of the data expected by
	// the endpoint. This controls the shape of the pushed message
	// (i.e., its fields and metadata). The endpoint version is
	// based on the version of the Pub/Sub API.
	// If not present during the subscriptions.create call,
	// it will default to the version of the API used to make
	// such call. If not present during a subscriptions.modifyPushConfig
	// call, its value will not be changed. subscriptions.get
	// calls will always return a valid version, even if the
	// subscription was created without this attribute.
	// The possible values for this attribute are:
	// +mapType=granular
	Attributes map[string]*string `json:"attributes,omitempty" tf:"attributes,omitempty"`

	// When set, the payload to the push endpoint is not wrapped.Sets the
	// data field as the HTTP body for delivery.
	// Structure is documented below.
	NoWrapper []NoWrapperObservation `json:"noWrapper,omitempty" tf:"no_wrapper,omitempty"`

	// If specified, Pub/Sub will generate and attach an OIDC JWT token as
	// an Authorization header in the HTTP request for every pushed message.
	// Structure is documented below.
	OidcToken []OidcTokenObservation `json:"oidcToken,omitempty" tf:"oidc_token,omitempty"`

	// A URL locating the endpoint to which messages should be pushed.
	// For example, a Webhook endpoint might use
	// "https://example.com/push".
	PushEndpoint *string `json:"pushEndpoint,omitempty" tf:"push_endpoint,omitempty"`
}

type PushConfigParameters struct {

	// Endpoint configuration attributes.
	// Every endpoint has a set of API supported attributes that can
	// be used to control different aspects of the message delivery.
	// The currently supported attribute is x-goog-version, which you
	// can use to change the format of the pushed message. This
	// attribute indicates the version of the data expected by
	// the endpoint. This controls the shape of the pushed message
	// (i.e., its fields and metadata). The endpoint version is
	// based on the version of the Pub/Sub API.
	// If not present during the subscriptions.create call,
	// it will default to the version of the API used to make
	// such call. If not present during a subscriptions.modifyPushConfig
	// call, its value will not be changed. subscriptions.get
	// calls will always return a valid version, even if the
	// subscription was created without this attribute.
	// The possible values for this attribute are:
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Attributes map[string]*string `json:"attributes,omitempty" tf:"attributes,omitempty"`

	// When set, the payload to the push endpoint is not wrapped.Sets the
	// data field as the HTTP body for delivery.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	NoWrapper []NoWrapperParameters `json:"noWrapper,omitempty" tf:"no_wrapper,omitempty"`

	// If specified, Pub/Sub will generate and attach an OIDC JWT token as
	// an Authorization header in the HTTP request for every pushed message.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	OidcToken []OidcTokenParameters `json:"oidcToken,omitempty" tf:"oidc_token,omitempty"`

	// A URL locating the endpoint to which messages should be pushed.
	// For example, a Webhook endpoint might use
	// "https://example.com/push".
	// +kubebuilder:validation:Optional
	PushEndpoint *string `json:"pushEndpoint" tf:"push_endpoint,omitempty"`
}

type RetryPolicyInitParameters struct {

	// The maximum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 600 seconds.
	// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	MaximumBackoff *string `json:"maximumBackoff,omitempty" tf:"maximum_backoff,omitempty"`

	// The minimum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 10 seconds.
	// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	MinimumBackoff *string `json:"minimumBackoff,omitempty" tf:"minimum_backoff,omitempty"`
}

type RetryPolicyObservation struct {

	// The maximum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 600 seconds.
	// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	MaximumBackoff *string `json:"maximumBackoff,omitempty" tf:"maximum_backoff,omitempty"`

	// The minimum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 10 seconds.
	// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	MinimumBackoff *string `json:"minimumBackoff,omitempty" tf:"minimum_backoff,omitempty"`
}

type RetryPolicyParameters struct {

	// The maximum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 600 seconds.
	// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	// +kubebuilder:validation:Optional
	MaximumBackoff *string `json:"maximumBackoff,omitempty" tf:"maximum_backoff,omitempty"`

	// The minimum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 10 seconds.
	// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	// +kubebuilder:validation:Optional
	MinimumBackoff *string `json:"minimumBackoff,omitempty" tf:"minimum_backoff,omitempty"`
}

type SubscriptionInitParameters struct {

	// This value is the maximum time after a subscriber receives a message
	// before the subscriber should acknowledge the message. After message
	// delivery but before the ack deadline expires and before the message is
	// acknowledged, it is an outstanding message and will not be delivered
	// again during that time (on a best-effort basis).
	// For pull subscriptions, this value is used as the initial value for
	// the ack deadline. To override this value for a given message, call
	// subscriptions.modifyAckDeadline with the corresponding ackId if using
	// pull. The minimum custom deadline you can specify is 10 seconds. The
	// maximum custom deadline you can specify is 600 seconds (10 minutes).
	// If this parameter is 0, a default value of 10 seconds is used.
	// For push delivery, this value is also used to set the request timeout
	// for the call to the push endpoint.
	// If the subscriber never acknowledges the message, the Pub/Sub system
	// will eventually redeliver the message.
	AckDeadlineSeconds *float64 `json:"ackDeadlineSeconds,omitempty" tf:"ack_deadline_seconds,omitempty"`

	// If delivery to BigQuery is used with this subscription, this field is used to configure it.
	// Either pushConfig, bigQueryConfig or cloudStorageConfig can be set, but not combined.
	// If all three are empty, then the subscriber will pull and ack messages using API methods.
	// Structure is documented below.
	BigqueryConfig []BigqueryConfigInitParameters `json:"bigqueryConfig,omitempty" tf:"bigquery_config,omitempty"`

	// If delivery to Cloud Storage is used with this subscription, this field is used to configure it.
	// Either pushConfig, bigQueryConfig or cloudStorageConfig can be set, but not combined.
	// If all three are empty, then the subscriber will pull and ack messages using API methods.
	// Structure is documented below.
	CloudStorageConfig []CloudStorageConfigInitParameters `json:"cloudStorageConfig,omitempty" tf:"cloud_storage_config,omitempty"`

	// A policy that specifies the conditions for dead lettering messages in
	// this subscription. If dead_letter_policy is not set, dead lettering
	// is disabled.
	// The Cloud Pub/Sub service account associated with this subscription's
	// parent project (i.e.,
	// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
	// permission to Acknowledge() messages on this subscription.
	// Structure is documented below.
	DeadLetterPolicy []DeadLetterPolicyInitParameters `json:"deadLetterPolicy,omitempty" tf:"dead_letter_policy,omitempty"`

	// If true, Pub/Sub provides the following guarantees for the delivery
	// of a message with a given value of messageId on this Subscriptions':
	EnableExactlyOnceDelivery *bool `json:"enableExactlyOnceDelivery,omitempty" tf:"enable_exactly_once_delivery,omitempty"`

	// If true, messages published with the same orderingKey in PubsubMessage will be delivered to
	// the subscribers in the order in which they are received by the Pub/Sub system. Otherwise, they
	// may be delivered in any order.
	EnableMessageOrdering *bool `json:"enableMessageOrdering,omitempty" tf:"enable_message_ordering,omitempty"`

	// A policy that specifies the conditions for this subscription's expiration.
	// A subscription is considered active as long as any connected subscriber
	// is successfully consuming messages from the subscription or is issuing
	// operations on the subscription. If expirationPolicy is not set, a default
	// policy with ttl of 31 days will be used.  If it is set but ttl is "", the
	// resource never expires.  The minimum allowed value for expirationPolicy.ttl
	// is 1 day.
	// Structure is documented below.
	ExpirationPolicy []ExpirationPolicyInitParameters `json:"expirationPolicy,omitempty" tf:"expiration_policy,omitempty"`

	// The subscription only delivers the messages that match the filter.
	// Pub/Sub automatically acknowledges the messages that don't match the filter. You can filter messages
	// by their attributes. The maximum length of a filter is 256 bytes. After creating the subscription,
	// you can't modify the filter.
	Filter *string `json:"filter,omitempty" tf:"filter,omitempty"`

	// A set of key/value label pairs to assign to this Subscription.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// How long to retain unacknowledged messages in the subscription's
	// backlog, from the moment a message is published. If
	// retain_acked_messages is true, then this also configures the retention
	// of acknowledged messages, and thus configures how far back in time a
	// subscriptions.seek can be done. Defaults to 7 days. Cannot be more
	// than 7 days ("604800s") or less than 10 minutes ("600s").
	// A duration in seconds with up to nine fractional digits, terminated
	// by 's'. Example: "600.5s".
	MessageRetentionDuration *string `json:"messageRetentionDuration,omitempty" tf:"message_retention_duration,omitempty"`

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// If push delivery is used with this subscription, this field is used to
	// configure it. An empty pushConfig signifies that the subscriber will
	// pull and ack messages using API methods.
	// Structure is documented below.
	PushConfig []PushConfigInitParameters `json:"pushConfig,omitempty" tf:"push_config,omitempty"`

	// Indicates whether to retain acknowledged messages. If true, then
	// messages are not expunged from the subscription's backlog, even if
	// they are acknowledged, until they fall out of the
	// messageRetentionDuration window.
	RetainAckedMessages *bool `json:"retainAckedMessages,omitempty" tf:"retain_acked_messages,omitempty"`

	// A policy that specifies how Pub/Sub retries message delivery for this subscription.
	// If not set, the default retry policy is applied. This generally implies that messages will be retried as soon as possible for healthy subscribers.
	// RetryPolicy will be triggered on NACKs or acknowledgement deadline exceeded events for a given message
	// Structure is documented below.
	RetryPolicy []RetryPolicyInitParameters `json:"retryPolicy,omitempty" tf:"retry_policy,omitempty"`

	// A reference to a Topic resource, of the form projects/{project}/topics/{{name}}
	// (as in the id property of a google_pubsub_topic), or just a topic name if
	// the topic is in the same project as the subscription.
	// +crossplane:generate:reference:type=Topic
	Topic *string `json:"topic,omitempty" tf:"topic,omitempty"`

	// Reference to a Topic to populate topic.
	// +kubebuilder:validation:Optional
	TopicRef *v1.Reference `json:"topicRef,omitempty" tf:"-"`

	// Selector for a Topic to populate topic.
	// +kubebuilder:validation:Optional
	TopicSelector *v1.Selector `json:"topicSelector,omitempty" tf:"-"`
}

type SubscriptionObservation struct {

	// This value is the maximum time after a subscriber receives a message
	// before the subscriber should acknowledge the message. After message
	// delivery but before the ack deadline expires and before the message is
	// acknowledged, it is an outstanding message and will not be delivered
	// again during that time (on a best-effort basis).
	// For pull subscriptions, this value is used as the initial value for
	// the ack deadline. To override this value for a given message, call
	// subscriptions.modifyAckDeadline with the corresponding ackId if using
	// pull. The minimum custom deadline you can specify is 10 seconds. The
	// maximum custom deadline you can specify is 600 seconds (10 minutes).
	// If this parameter is 0, a default value of 10 seconds is used.
	// For push delivery, this value is also used to set the request timeout
	// for the call to the push endpoint.
	// If the subscriber never acknowledges the message, the Pub/Sub system
	// will eventually redeliver the message.
	AckDeadlineSeconds *float64 `json:"ackDeadlineSeconds,omitempty" tf:"ack_deadline_seconds,omitempty"`

	// If delivery to BigQuery is used with this subscription, this field is used to configure it.
	// Either pushConfig, bigQueryConfig or cloudStorageConfig can be set, but not combined.
	// If all three are empty, then the subscriber will pull and ack messages using API methods.
	// Structure is documented below.
	BigqueryConfig []BigqueryConfigObservation `json:"bigqueryConfig,omitempty" tf:"bigquery_config,omitempty"`

	// If delivery to Cloud Storage is used with this subscription, this field is used to configure it.
	// Either pushConfig, bigQueryConfig or cloudStorageConfig can be set, but not combined.
	// If all three are empty, then the subscriber will pull and ack messages using API methods.
	// Structure is documented below.
	CloudStorageConfig []CloudStorageConfigObservation `json:"cloudStorageConfig,omitempty" tf:"cloud_storage_config,omitempty"`

	// A policy that specifies the conditions for dead lettering messages in
	// this subscription. If dead_letter_policy is not set, dead lettering
	// is disabled.
	// The Cloud Pub/Sub service account associated with this subscription's
	// parent project (i.e.,
	// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
	// permission to Acknowledge() messages on this subscription.
	// Structure is documented below.
	DeadLetterPolicy []DeadLetterPolicyObservation `json:"deadLetterPolicy,omitempty" tf:"dead_letter_policy,omitempty"`

	// for all of the labels present on the resource.
	// +mapType=granular
	EffectiveLabels map[string]*string `json:"effectiveLabels,omitempty" tf:"effective_labels,omitempty"`

	// If true, Pub/Sub provides the following guarantees for the delivery
	// of a message with a given value of messageId on this Subscriptions':
	EnableExactlyOnceDelivery *bool `json:"enableExactlyOnceDelivery,omitempty" tf:"enable_exactly_once_delivery,omitempty"`

	// If true, messages published with the same orderingKey in PubsubMessage will be delivered to
	// the subscribers in the order in which they are received by the Pub/Sub system. Otherwise, they
	// may be delivered in any order.
	EnableMessageOrdering *bool `json:"enableMessageOrdering,omitempty" tf:"enable_message_ordering,omitempty"`

	// A policy that specifies the conditions for this subscription's expiration.
	// A subscription is considered active as long as any connected subscriber
	// is successfully consuming messages from the subscription or is issuing
	// operations on the subscription. If expirationPolicy is not set, a default
	// policy with ttl of 31 days will be used.  If it is set but ttl is "", the
	// resource never expires.  The minimum allowed value for expirationPolicy.ttl
	// is 1 day.
	// Structure is documented below.
	ExpirationPolicy []ExpirationPolicyObservation `json:"expirationPolicy,omitempty" tf:"expiration_policy,omitempty"`

	// The subscription only delivers the messages that match the filter.
	// Pub/Sub automatically acknowledges the messages that don't match the filter. You can filter messages
	// by their attributes. The maximum length of a filter is 256 bytes. After creating the subscription,
	// you can't modify the filter.
	Filter *string `json:"filter,omitempty" tf:"filter,omitempty"`

	// an identifier for the resource with format projects/{{project}}/subscriptions/{{name}}
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// A set of key/value label pairs to assign to this Subscription.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// How long to retain unacknowledged messages in the subscription's
	// backlog, from the moment a message is published. If
	// retain_acked_messages is true, then this also configures the retention
	// of acknowledged messages, and thus configures how far back in time a
	// subscriptions.seek can be done. Defaults to 7 days. Cannot be more
	// than 7 days ("604800s") or less than 10 minutes ("600s").
	// A duration in seconds with up to nine fractional digits, terminated
	// by 's'. Example: "600.5s".
	MessageRetentionDuration *string `json:"messageRetentionDuration,omitempty" tf:"message_retention_duration,omitempty"`

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// If push delivery is used with this subscription, this field is used to
	// configure it. An empty pushConfig signifies that the subscriber will
	// pull and ack messages using API methods.
	// Structure is documented below.
	PushConfig []PushConfigObservation `json:"pushConfig,omitempty" tf:"push_config,omitempty"`

	// Indicates whether to retain acknowledged messages. If true, then
	// messages are not expunged from the subscription's backlog, even if
	// they are acknowledged, until they fall out of the
	// messageRetentionDuration window.
	RetainAckedMessages *bool `json:"retainAckedMessages,omitempty" tf:"retain_acked_messages,omitempty"`

	// A policy that specifies how Pub/Sub retries message delivery for this subscription.
	// If not set, the default retry policy is applied. This generally implies that messages will be retried as soon as possible for healthy subscribers.
	// RetryPolicy will be triggered on NACKs or acknowledgement deadline exceeded events for a given message
	// Structure is documented below.
	RetryPolicy []RetryPolicyObservation `json:"retryPolicy,omitempty" tf:"retry_policy,omitempty"`

	// The combination of labels configured directly on the resource
	// and default labels configured on the provider.
	// +mapType=granular
	TerraformLabels map[string]*string `json:"terraformLabels,omitempty" tf:"terraform_labels,omitempty"`

	// A reference to a Topic resource, of the form projects/{project}/topics/{{name}}
	// (as in the id property of a google_pubsub_topic), or just a topic name if
	// the topic is in the same project as the subscription.
	Topic *string `json:"topic,omitempty" tf:"topic,omitempty"`
}

type SubscriptionParameters struct {

	// This value is the maximum time after a subscriber receives a message
	// before the subscriber should acknowledge the message. After message
	// delivery but before the ack deadline expires and before the message is
	// acknowledged, it is an outstanding message and will not be delivered
	// again during that time (on a best-effort basis).
	// For pull subscriptions, this value is used as the initial value for
	// the ack deadline. To override this value for a given message, call
	// subscriptions.modifyAckDeadline with the corresponding ackId if using
	// pull. The minimum custom deadline you can specify is 10 seconds. The
	// maximum custom deadline you can specify is 600 seconds (10 minutes).
	// If this parameter is 0, a default value of 10 seconds is used.
	// For push delivery, this value is also used to set the request timeout
	// for the call to the push endpoint.
	// If the subscriber never acknowledges the message, the Pub/Sub system
	// will eventually redeliver the message.
	// +kubebuilder:validation:Optional
	AckDeadlineSeconds *float64 `json:"ackDeadlineSeconds,omitempty" tf:"ack_deadline_seconds,omitempty"`

	// If delivery to BigQuery is used with this subscription, this field is used to configure it.
	// Either pushConfig, bigQueryConfig or cloudStorageConfig can be set, but not combined.
	// If all three are empty, then the subscriber will pull and ack messages using API methods.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	BigqueryConfig []BigqueryConfigParameters `json:"bigqueryConfig,omitempty" tf:"bigquery_config,omitempty"`

	// If delivery to Cloud Storage is used with this subscription, this field is used to configure it.
	// Either pushConfig, bigQueryConfig or cloudStorageConfig can be set, but not combined.
	// If all three are empty, then the subscriber will pull and ack messages using API methods.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	CloudStorageConfig []CloudStorageConfigParameters `json:"cloudStorageConfig,omitempty" tf:"cloud_storage_config,omitempty"`

	// A policy that specifies the conditions for dead lettering messages in
	// this subscription. If dead_letter_policy is not set, dead lettering
	// is disabled.
	// The Cloud Pub/Sub service account associated with this subscription's
	// parent project (i.e.,
	// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
	// permission to Acknowledge() messages on this subscription.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	DeadLetterPolicy []DeadLetterPolicyParameters `json:"deadLetterPolicy,omitempty" tf:"dead_letter_policy,omitempty"`

	// If true, Pub/Sub provides the following guarantees for the delivery
	// of a message with a given value of messageId on this Subscriptions':
	// +kubebuilder:validation:Optional
	EnableExactlyOnceDelivery *bool `json:"enableExactlyOnceDelivery,omitempty" tf:"enable_exactly_once_delivery,omitempty"`

	// If true, messages published with the same orderingKey in PubsubMessage will be delivered to
	// the subscribers in the order in which they are received by the Pub/Sub system. Otherwise, they
	// may be delivered in any order.
	// +kubebuilder:validation:Optional
	EnableMessageOrdering *bool `json:"enableMessageOrdering,omitempty" tf:"enable_message_ordering,omitempty"`

	// A policy that specifies the conditions for this subscription's expiration.
	// A subscription is considered active as long as any connected subscriber
	// is successfully consuming messages from the subscription or is issuing
	// operations on the subscription. If expirationPolicy is not set, a default
	// policy with ttl of 31 days will be used.  If it is set but ttl is "", the
	// resource never expires.  The minimum allowed value for expirationPolicy.ttl
	// is 1 day.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	ExpirationPolicy []ExpirationPolicyParameters `json:"expirationPolicy,omitempty" tf:"expiration_policy,omitempty"`

	// The subscription only delivers the messages that match the filter.
	// Pub/Sub automatically acknowledges the messages that don't match the filter. You can filter messages
	// by their attributes. The maximum length of a filter is 256 bytes. After creating the subscription,
	// you can't modify the filter.
	// +kubebuilder:validation:Optional
	Filter *string `json:"filter,omitempty" tf:"filter,omitempty"`

	// A set of key/value label pairs to assign to this Subscription.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// How long to retain unacknowledged messages in the subscription's
	// backlog, from the moment a message is published. If
	// retain_acked_messages is true, then this also configures the retention
	// of acknowledged messages, and thus configures how far back in time a
	// subscriptions.seek can be done. Defaults to 7 days. Cannot be more
	// than 7 days ("604800s") or less than 10 minutes ("600s").
	// A duration in seconds with up to nine fractional digits, terminated
	// by 's'. Example: "600.5s".
	// +kubebuilder:validation:Optional
	MessageRetentionDuration *string `json:"messageRetentionDuration,omitempty" tf:"message_retention_duration,omitempty"`

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	// +kubebuilder:validation:Optional
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// If push delivery is used with this subscription, this field is used to
	// configure it. An empty pushConfig signifies that the subscriber will
	// pull and ack messages using API methods.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	PushConfig []PushConfigParameters `json:"pushConfig,omitempty" tf:"push_config,omitempty"`

	// Indicates whether to retain acknowledged messages. If true, then
	// messages are not expunged from the subscription's backlog, even if
	// they are acknowledged, until they fall out of the
	// messageRetentionDuration window.
	// +kubebuilder:validation:Optional
	RetainAckedMessages *bool `json:"retainAckedMessages,omitempty" tf:"retain_acked_messages,omitempty"`

	// A policy that specifies how Pub/Sub retries message delivery for this subscription.
	// If not set, the default retry policy is applied. This generally implies that messages will be retried as soon as possible for healthy subscribers.
	// RetryPolicy will be triggered on NACKs or acknowledgement deadline exceeded events for a given message
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	RetryPolicy []RetryPolicyParameters `json:"retryPolicy,omitempty" tf:"retry_policy,omitempty"`

	// A reference to a Topic resource, of the form projects/{project}/topics/{{name}}
	// (as in the id property of a google_pubsub_topic), or just a topic name if
	// the topic is in the same project as the subscription.
	// +crossplane:generate:reference:type=Topic
	// +kubebuilder:validation:Optional
	Topic *string `json:"topic,omitempty" tf:"topic,omitempty"`

	// Reference to a Topic to populate topic.
	// +kubebuilder:validation:Optional
	TopicRef *v1.Reference `json:"topicRef,omitempty" tf:"-"`

	// Selector for a Topic to populate topic.
	// +kubebuilder:validation:Optional
	TopicSelector *v1.Selector `json:"topicSelector,omitempty" tf:"-"`
}

// SubscriptionSpec defines the desired state of Subscription
type SubscriptionSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     SubscriptionParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider SubscriptionInitParameters `json:"initProvider,omitempty"`
}

// SubscriptionStatus defines the observed state of Subscription.
type SubscriptionStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        SubscriptionObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Subscription is the Schema for the Subscriptions API. A named resource representing the stream of messages from a single, specific topic, to be delivered to the subscribing application.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcp}
type Subscription struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              SubscriptionSpec   `json:"spec"`
	Status            SubscriptionStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// SubscriptionList contains a list of Subscriptions
type SubscriptionList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Subscription `json:"items"`
}

// Repository type metadata.
var (
	Subscription_Kind             = "Subscription"
	Subscription_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Subscription_Kind}.String()
	Subscription_KindAPIVersion   = Subscription_Kind + "." + CRDGroupVersion.String()
	Subscription_GroupVersionKind = CRDGroupVersion.WithKind(Subscription_Kind)
)

func init() {
	SchemeBuilder.Register(&Subscription{}, &SubscriptionList{})
}
