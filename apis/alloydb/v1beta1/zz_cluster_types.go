// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AutomatedBackupPolicyEncryptionConfigInitParameters struct {

	// The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
	KMSKeyName *string `json:"kmsKeyName,omitempty" tf:"kms_key_name,omitempty"`
}

type AutomatedBackupPolicyEncryptionConfigObservation struct {

	// The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
	KMSKeyName *string `json:"kmsKeyName,omitempty" tf:"kms_key_name,omitempty"`
}

type AutomatedBackupPolicyEncryptionConfigParameters struct {

	// The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
	// +kubebuilder:validation:Optional
	KMSKeyName *string `json:"kmsKeyName,omitempty" tf:"kms_key_name,omitempty"`
}

type AutomatedBackupPolicyInitParameters struct {

	// The length of the time window during which a backup can be taken. If a backup does not succeed within this time window, it will be canceled and considered failed.
	// The backup window must be at least 5 minutes long. There is no upper bound on the window. If not set, it will default to 1 hour.
	// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	BackupWindow *string `json:"backupWindow,omitempty" tf:"backup_window,omitempty"`

	// Whether automated backups are enabled.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
	// Structure is documented below.
	EncryptionConfig []AutomatedBackupPolicyEncryptionConfigInitParameters `json:"encryptionConfig,omitempty" tf:"encryption_config,omitempty"`

	// Labels to apply to backups created using this configuration.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Quantity-based Backup retention policy to retain recent backups. Conflicts with 'time_based_retention', both can't be set together.
	// Structure is documented below.
	QuantityBasedRetention []QuantityBasedRetentionInitParameters `json:"quantityBasedRetention,omitempty" tf:"quantity_based_retention,omitempty"`

	// Time-based Backup retention policy. Conflicts with 'quantity_based_retention', both can't be set together.
	// Structure is documented below.
	TimeBasedRetention []TimeBasedRetentionInitParameters `json:"timeBasedRetention,omitempty" tf:"time_based_retention,omitempty"`

	// Weekly schedule for the Backup.
	// Structure is documented below.
	WeeklySchedule []WeeklyScheduleInitParameters `json:"weeklySchedule,omitempty" tf:"weekly_schedule,omitempty"`
}

type AutomatedBackupPolicyObservation struct {

	// The length of the time window during which a backup can be taken. If a backup does not succeed within this time window, it will be canceled and considered failed.
	// The backup window must be at least 5 minutes long. There is no upper bound on the window. If not set, it will default to 1 hour.
	// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	BackupWindow *string `json:"backupWindow,omitempty" tf:"backup_window,omitempty"`

	// Whether automated backups are enabled.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
	// Structure is documented below.
	EncryptionConfig []AutomatedBackupPolicyEncryptionConfigObservation `json:"encryptionConfig,omitempty" tf:"encryption_config,omitempty"`

	// Labels to apply to backups created using this configuration.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The location where the backup will be stored. Currently, the only supported option is to store the backup in the same region as the cluster.
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// Quantity-based Backup retention policy to retain recent backups. Conflicts with 'time_based_retention', both can't be set together.
	// Structure is documented below.
	QuantityBasedRetention []QuantityBasedRetentionObservation `json:"quantityBasedRetention,omitempty" tf:"quantity_based_retention,omitempty"`

	// Time-based Backup retention policy. Conflicts with 'quantity_based_retention', both can't be set together.
	// Structure is documented below.
	TimeBasedRetention []TimeBasedRetentionObservation `json:"timeBasedRetention,omitempty" tf:"time_based_retention,omitempty"`

	// Weekly schedule for the Backup.
	// Structure is documented below.
	WeeklySchedule []WeeklyScheduleObservation `json:"weeklySchedule,omitempty" tf:"weekly_schedule,omitempty"`
}

type AutomatedBackupPolicyParameters struct {

	// The length of the time window during which a backup can be taken. If a backup does not succeed within this time window, it will be canceled and considered failed.
	// The backup window must be at least 5 minutes long. There is no upper bound on the window. If not set, it will default to 1 hour.
	// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	// +kubebuilder:validation:Optional
	BackupWindow *string `json:"backupWindow,omitempty" tf:"backup_window,omitempty"`

	// Whether automated backups are enabled.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	EncryptionConfig []AutomatedBackupPolicyEncryptionConfigParameters `json:"encryptionConfig,omitempty" tf:"encryption_config,omitempty"`

	// Labels to apply to backups created using this configuration.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The location where the backup will be stored. Currently, the only supported option is to store the backup in the same region as the cluster.
	// +kubebuilder:validation:Optional
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// Quantity-based Backup retention policy to retain recent backups. Conflicts with 'time_based_retention', both can't be set together.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	QuantityBasedRetention []QuantityBasedRetentionParameters `json:"quantityBasedRetention,omitempty" tf:"quantity_based_retention,omitempty"`

	// Time-based Backup retention policy. Conflicts with 'quantity_based_retention', both can't be set together.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	TimeBasedRetention []TimeBasedRetentionParameters `json:"timeBasedRetention,omitempty" tf:"time_based_retention,omitempty"`

	// Weekly schedule for the Backup.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	WeeklySchedule []WeeklyScheduleParameters `json:"weeklySchedule,omitempty" tf:"weekly_schedule,omitempty"`
}

type BackupSourceInitParameters struct {
}

type BackupSourceObservation struct {

	// The name of the backup resource.
	BackupName *string `json:"backupName,omitempty" tf:"backup_name,omitempty"`
}

type BackupSourceParameters struct {
}

type ClusterEncryptionConfigInitParameters struct {

	// The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
	KMSKeyName *string `json:"kmsKeyName,omitempty" tf:"kms_key_name,omitempty"`
}

type ClusterEncryptionConfigObservation struct {

	// The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
	KMSKeyName *string `json:"kmsKeyName,omitempty" tf:"kms_key_name,omitempty"`
}

type ClusterEncryptionConfigParameters struct {

	// The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
	// +kubebuilder:validation:Optional
	KMSKeyName *string `json:"kmsKeyName,omitempty" tf:"kms_key_name,omitempty"`
}

type ClusterEncryptionInfoInitParameters struct {
}

type ClusterEncryptionInfoObservation struct {

	// (Output)
	// Output only. Type of encryption.
	EncryptionType *string `json:"encryptionType,omitempty" tf:"encryption_type,omitempty"`

	// (Output)
	// Output only. Cloud KMS key versions that are being used to protect the database or the backup.
	KMSKeyVersions []*string `json:"kmsKeyVersions,omitempty" tf:"kms_key_versions,omitempty"`
}

type ClusterEncryptionInfoParameters struct {
}

type ClusterInitParameters struct {

	// Annotations to allow client tools to store small amount of arbitrary data. This is distinct from labels. https://google.aip.dev/128
	// An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
	// +mapType=granular
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// The automated backup policy for this cluster. AutomatedBackupPolicy is disabled by default.
	// Structure is documented below.
	AutomatedBackupPolicy []AutomatedBackupPolicyInitParameters `json:"automatedBackupPolicy,omitempty" tf:"automated_backup_policy,omitempty"`

	// The type of cluster. If not set, defaults to PRIMARY.
	// Default value is PRIMARY.
	// Possible values are: PRIMARY, SECONDARY.
	ClusterType *string `json:"clusterType,omitempty" tf:"cluster_type,omitempty"`

	// The continuous backup config for this cluster.
	// If no policy is provided then the default policy will be used. The default policy takes one backup a day and retains backups for 14 days.
	// Structure is documented below.
	ContinuousBackupConfig []ContinuousBackupConfigInitParameters `json:"continuousBackupConfig,omitempty" tf:"continuous_backup_config,omitempty"`

	// The database engine major version. This is an optional field and it's populated at the Cluster creation time. This field cannot be changed after cluster creation.
	DatabaseVersion *string `json:"databaseVersion,omitempty" tf:"database_version,omitempty"`

	// Policy to determine if the cluster should be deleted forcefully.
	// Deleting a cluster forcefully, deletes the cluster and all its associated instances within the cluster.
	// Deleting a Secondary cluster with a secondary instance REQUIRES setting deletion_policy = "FORCE" otherwise an error is returned. This is needed as there is no support to delete just the secondary instance, and the only way to delete secondary instance is to delete the associated secondary cluster forcefully which also deletes the secondary instance.
	DeletionPolicy *string `json:"deletionPolicy,omitempty" tf:"deletion_policy,omitempty"`

	// User-settable and human-readable display name for the Cluster.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
	// Structure is documented below.
	EncryptionConfig []ClusterEncryptionConfigInitParameters `json:"encryptionConfig,omitempty" tf:"encryption_config,omitempty"`

	// For Resource freshness validation (https://google.aip.dev/154)
	Etag *string `json:"etag,omitempty" tf:"etag,omitempty"`

	// Initial user to setup during cluster creation.
	// Structure is documented below.
	InitialUser []InitialUserInitParameters `json:"initialUser,omitempty" tf:"initial_user,omitempty"`

	// User-defined labels for the alloydb cluster.
	// Note: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field effective_labels for all of the labels present on the resource.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The relative resource name of the VPC network on which the instance can be accessed. It is specified in the following form:
	// "projects/{projectNumber}/global/networks/{network_id}".
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.Network
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	Network *string `json:"network,omitempty" tf:"network,omitempty"`

	// Metadata related to network configuration.
	// Structure is documented below.
	NetworkConfig []NetworkConfigInitParameters `json:"networkConfig,omitempty" tf:"network_config,omitempty"`

	// Reference to a Network in compute to populate network.
	// +kubebuilder:validation:Optional
	NetworkRef *v1.Reference `json:"networkRef,omitempty" tf:"-"`

	// Selector for a Network in compute to populate network.
	// +kubebuilder:validation:Optional
	NetworkSelector *v1.Selector `json:"networkSelector,omitempty" tf:"-"`

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source', both can't be set together.
	// Structure is documented below.
	RestoreBackupSource []RestoreBackupSourceInitParameters `json:"restoreBackupSource,omitempty" tf:"restore_backup_source,omitempty"`

	// The source when restoring via point in time recovery (PITR). Conflicts with 'restore_backup_source', both can't be set together.
	// Structure is documented below.
	RestoreContinuousBackupSource []RestoreContinuousBackupSourceInitParameters `json:"restoreContinuousBackupSource,omitempty" tf:"restore_continuous_backup_source,omitempty"`

	// Configuration of the secondary cluster for Cross Region Replication. This should be set if and only if the cluster is of type SECONDARY.
	// Structure is documented below.
	SecondaryConfig []SecondaryConfigInitParameters `json:"secondaryConfig,omitempty" tf:"secondary_config,omitempty"`
}

type ClusterObservation struct {

	// Annotations to allow client tools to store small amount of arbitrary data. This is distinct from labels. https://google.aip.dev/128
	// An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
	// +mapType=granular
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// The automated backup policy for this cluster. AutomatedBackupPolicy is disabled by default.
	// Structure is documented below.
	AutomatedBackupPolicy []AutomatedBackupPolicyObservation `json:"automatedBackupPolicy,omitempty" tf:"automated_backup_policy,omitempty"`

	// Cluster created from backup.
	// Structure is documented below.
	BackupSource []BackupSourceObservation `json:"backupSource,omitempty" tf:"backup_source,omitempty"`

	// The type of cluster. If not set, defaults to PRIMARY.
	// Default value is PRIMARY.
	// Possible values are: PRIMARY, SECONDARY.
	ClusterType *string `json:"clusterType,omitempty" tf:"cluster_type,omitempty"`

	// The continuous backup config for this cluster.
	// If no policy is provided then the default policy will be used. The default policy takes one backup a day and retains backups for 14 days.
	// Structure is documented below.
	ContinuousBackupConfig []ContinuousBackupConfigObservation `json:"continuousBackupConfig,omitempty" tf:"continuous_backup_config,omitempty"`

	// ContinuousBackupInfo describes the continuous backup properties of a cluster.
	// Structure is documented below.
	ContinuousBackupInfo []ContinuousBackupInfoObservation `json:"continuousBackupInfo,omitempty" tf:"continuous_backup_info,omitempty"`

	// The database engine major version. This is an optional field and it's populated at the Cluster creation time. This field cannot be changed after cluster creation.
	DatabaseVersion *string `json:"databaseVersion,omitempty" tf:"database_version,omitempty"`

	// Policy to determine if the cluster should be deleted forcefully.
	// Deleting a cluster forcefully, deletes the cluster and all its associated instances within the cluster.
	// Deleting a Secondary cluster with a secondary instance REQUIRES setting deletion_policy = "FORCE" otherwise an error is returned. This is needed as there is no support to delete just the secondary instance, and the only way to delete secondary instance is to delete the associated secondary cluster forcefully which also deletes the secondary instance.
	DeletionPolicy *string `json:"deletionPolicy,omitempty" tf:"deletion_policy,omitempty"`

	// User-settable and human-readable display name for the Cluster.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// for all of the annotations present on the resource.
	// +mapType=granular
	EffectiveAnnotations map[string]*string `json:"effectiveAnnotations,omitempty" tf:"effective_annotations,omitempty"`

	// +mapType=granular
	EffectiveLabels map[string]*string `json:"effectiveLabels,omitempty" tf:"effective_labels,omitempty"`

	// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
	// Structure is documented below.
	EncryptionConfig []ClusterEncryptionConfigObservation `json:"encryptionConfig,omitempty" tf:"encryption_config,omitempty"`

	// EncryptionInfo describes the encryption information of a cluster or a backup.
	// Structure is documented below.
	EncryptionInfo []ClusterEncryptionInfoObservation `json:"encryptionInfo,omitempty" tf:"encryption_info,omitempty"`

	// For Resource freshness validation (https://google.aip.dev/154)
	Etag *string `json:"etag,omitempty" tf:"etag,omitempty"`

	// an identifier for the resource with format projects/{{project}}/locations/{{location}}/clusters/{{cluster_id}}
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Initial user to setup during cluster creation.
	// Structure is documented below.
	InitialUser []InitialUserObservation `json:"initialUser,omitempty" tf:"initial_user,omitempty"`

	// User-defined labels for the alloydb cluster.
	// Note: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field effective_labels for all of the labels present on the resource.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The location where the alloydb cluster should reside.
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// Cluster created via DMS migration.
	// Structure is documented below.
	MigrationSource []MigrationSourceObservation `json:"migrationSource,omitempty" tf:"migration_source,omitempty"`

	// The name of the cluster resource.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The relative resource name of the VPC network on which the instance can be accessed. It is specified in the following form:
	// "projects/{projectNumber}/global/networks/{network_id}".
	Network *string `json:"network,omitempty" tf:"network,omitempty"`

	// Metadata related to network configuration.
	// Structure is documented below.
	NetworkConfig []NetworkConfigObservation `json:"networkConfig,omitempty" tf:"network_config,omitempty"`

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// Output only. Reconciling (https://google.aip.dev/128#reconciliation).
	// Set to true if the current state of Cluster does not match the user's intended state, and the service is actively updating the resource to reconcile them.
	// This can happen due to user-triggered updates or system actions like failover or maintenance.
	Reconciling *bool `json:"reconciling,omitempty" tf:"reconciling,omitempty"`

	// The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source', both can't be set together.
	// Structure is documented below.
	RestoreBackupSource []RestoreBackupSourceObservation `json:"restoreBackupSource,omitempty" tf:"restore_backup_source,omitempty"`

	// The source when restoring via point in time recovery (PITR). Conflicts with 'restore_backup_source', both can't be set together.
	// Structure is documented below.
	RestoreContinuousBackupSource []RestoreContinuousBackupSourceObservation `json:"restoreContinuousBackupSource,omitempty" tf:"restore_continuous_backup_source,omitempty"`

	// Configuration of the secondary cluster for Cross Region Replication. This should be set if and only if the cluster is of type SECONDARY.
	// Structure is documented below.
	SecondaryConfig []SecondaryConfigObservation `json:"secondaryConfig,omitempty" tf:"secondary_config,omitempty"`

	// Output only. The current serving state of the cluster.
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// The combination of labels configured directly on the resource
	// and default labels configured on the provider.
	// +mapType=granular
	TerraformLabels map[string]*string `json:"terraformLabels,omitempty" tf:"terraform_labels,omitempty"`

	// The system-generated UID of the resource.
	UID *string `json:"uid,omitempty" tf:"uid,omitempty"`
}

type ClusterParameters struct {

	// Annotations to allow client tools to store small amount of arbitrary data. This is distinct from labels. https://google.aip.dev/128
	// An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// The automated backup policy for this cluster. AutomatedBackupPolicy is disabled by default.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	AutomatedBackupPolicy []AutomatedBackupPolicyParameters `json:"automatedBackupPolicy,omitempty" tf:"automated_backup_policy,omitempty"`

	// The type of cluster. If not set, defaults to PRIMARY.
	// Default value is PRIMARY.
	// Possible values are: PRIMARY, SECONDARY.
	// +kubebuilder:validation:Optional
	ClusterType *string `json:"clusterType,omitempty" tf:"cluster_type,omitempty"`

	// The continuous backup config for this cluster.
	// If no policy is provided then the default policy will be used. The default policy takes one backup a day and retains backups for 14 days.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	ContinuousBackupConfig []ContinuousBackupConfigParameters `json:"continuousBackupConfig,omitempty" tf:"continuous_backup_config,omitempty"`

	// The database engine major version. This is an optional field and it's populated at the Cluster creation time. This field cannot be changed after cluster creation.
	// +kubebuilder:validation:Optional
	DatabaseVersion *string `json:"databaseVersion,omitempty" tf:"database_version,omitempty"`

	// Policy to determine if the cluster should be deleted forcefully.
	// Deleting a cluster forcefully, deletes the cluster and all its associated instances within the cluster.
	// Deleting a Secondary cluster with a secondary instance REQUIRES setting deletion_policy = "FORCE" otherwise an error is returned. This is needed as there is no support to delete just the secondary instance, and the only way to delete secondary instance is to delete the associated secondary cluster forcefully which also deletes the secondary instance.
	// +kubebuilder:validation:Optional
	DeletionPolicy *string `json:"deletionPolicy,omitempty" tf:"deletion_policy,omitempty"`

	// User-settable and human-readable display name for the Cluster.
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	EncryptionConfig []ClusterEncryptionConfigParameters `json:"encryptionConfig,omitempty" tf:"encryption_config,omitempty"`

	// For Resource freshness validation (https://google.aip.dev/154)
	// +kubebuilder:validation:Optional
	Etag *string `json:"etag,omitempty" tf:"etag,omitempty"`

	// Initial user to setup during cluster creation.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	InitialUser []InitialUserParameters `json:"initialUser,omitempty" tf:"initial_user,omitempty"`

	// User-defined labels for the alloydb cluster.
	// Note: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field effective_labels for all of the labels present on the resource.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The location where the alloydb cluster should reside.
	// +kubebuilder:validation:Required
	Location *string `json:"location" tf:"location,omitempty"`

	// The relative resource name of the VPC network on which the instance can be accessed. It is specified in the following form:
	// "projects/{projectNumber}/global/networks/{network_id}".
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.Network
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	Network *string `json:"network,omitempty" tf:"network,omitempty"`

	// Metadata related to network configuration.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	NetworkConfig []NetworkConfigParameters `json:"networkConfig,omitempty" tf:"network_config,omitempty"`

	// Reference to a Network in compute to populate network.
	// +kubebuilder:validation:Optional
	NetworkRef *v1.Reference `json:"networkRef,omitempty" tf:"-"`

	// Selector for a Network in compute to populate network.
	// +kubebuilder:validation:Optional
	NetworkSelector *v1.Selector `json:"networkSelector,omitempty" tf:"-"`

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	// +kubebuilder:validation:Optional
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source', both can't be set together.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	RestoreBackupSource []RestoreBackupSourceParameters `json:"restoreBackupSource,omitempty" tf:"restore_backup_source,omitempty"`

	// The source when restoring via point in time recovery (PITR). Conflicts with 'restore_backup_source', both can't be set together.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	RestoreContinuousBackupSource []RestoreContinuousBackupSourceParameters `json:"restoreContinuousBackupSource,omitempty" tf:"restore_continuous_backup_source,omitempty"`

	// Configuration of the secondary cluster for Cross Region Replication. This should be set if and only if the cluster is of type SECONDARY.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	SecondaryConfig []SecondaryConfigParameters `json:"secondaryConfig,omitempty" tf:"secondary_config,omitempty"`
}

type ContinuousBackupConfigEncryptionConfigInitParameters struct {

	// The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
	KMSKeyName *string `json:"kmsKeyName,omitempty" tf:"kms_key_name,omitempty"`
}

type ContinuousBackupConfigEncryptionConfigObservation struct {

	// The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
	KMSKeyName *string `json:"kmsKeyName,omitempty" tf:"kms_key_name,omitempty"`
}

type ContinuousBackupConfigEncryptionConfigParameters struct {

	// The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
	// +kubebuilder:validation:Optional
	KMSKeyName *string `json:"kmsKeyName,omitempty" tf:"kms_key_name,omitempty"`
}

type ContinuousBackupConfigInitParameters struct {

	// Whether continuous backup recovery is enabled. If not set, defaults to true.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
	// Structure is documented below.
	EncryptionConfig []ContinuousBackupConfigEncryptionConfigInitParameters `json:"encryptionConfig,omitempty" tf:"encryption_config,omitempty"`

	// The numbers of days that are eligible to restore from using PITR. To support the entire recovery window, backups and logs are retained for one day more than the recovery window.
	// If not set, defaults to 14 days.
	RecoveryWindowDays *float64 `json:"recoveryWindowDays,omitempty" tf:"recovery_window_days,omitempty"`
}

type ContinuousBackupConfigObservation struct {

	// Whether continuous backup recovery is enabled. If not set, defaults to true.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
	// Structure is documented below.
	EncryptionConfig []ContinuousBackupConfigEncryptionConfigObservation `json:"encryptionConfig,omitempty" tf:"encryption_config,omitempty"`

	// The numbers of days that are eligible to restore from using PITR. To support the entire recovery window, backups and logs are retained for one day more than the recovery window.
	// If not set, defaults to 14 days.
	RecoveryWindowDays *float64 `json:"recoveryWindowDays,omitempty" tf:"recovery_window_days,omitempty"`
}

type ContinuousBackupConfigParameters struct {

	// Whether continuous backup recovery is enabled. If not set, defaults to true.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	EncryptionConfig []ContinuousBackupConfigEncryptionConfigParameters `json:"encryptionConfig,omitempty" tf:"encryption_config,omitempty"`

	// The numbers of days that are eligible to restore from using PITR. To support the entire recovery window, backups and logs are retained for one day more than the recovery window.
	// If not set, defaults to 14 days.
	// +kubebuilder:validation:Optional
	RecoveryWindowDays *float64 `json:"recoveryWindowDays,omitempty" tf:"recovery_window_days,omitempty"`
}

type ContinuousBackupInfoEncryptionInfoInitParameters struct {
}

type ContinuousBackupInfoEncryptionInfoObservation struct {

	// (Output)
	// Output only. Type of encryption.
	EncryptionType *string `json:"encryptionType,omitempty" tf:"encryption_type,omitempty"`

	// (Output)
	// Output only. Cloud KMS key versions that are being used to protect the database or the backup.
	KMSKeyVersions []*string `json:"kmsKeyVersions,omitempty" tf:"kms_key_versions,omitempty"`
}

type ContinuousBackupInfoEncryptionInfoParameters struct {
}

type ContinuousBackupInfoInitParameters struct {
}

type ContinuousBackupInfoObservation struct {

	// (Output)
	// The earliest restorable time that can be restored to. Output only field.
	EarliestRestorableTime *string `json:"earliestRestorableTime,omitempty" tf:"earliest_restorable_time,omitempty"`

	// (Output)
	// When ContinuousBackup was most recently enabled. Set to null if ContinuousBackup is not enabled.
	EnabledTime *string `json:"enabledTime,omitempty" tf:"enabled_time,omitempty"`

	// (Output)
	// Output only. The encryption information for the WALs and backups required for ContinuousBackup.
	// Structure is documented below.
	EncryptionInfo []ContinuousBackupInfoEncryptionInfoObservation `json:"encryptionInfo,omitempty" tf:"encryption_info,omitempty"`

	// (Output)
	// Days of the week on which a continuous backup is taken. Output only field. Ignored if passed into the request.
	Schedule []*string `json:"schedule,omitempty" tf:"schedule,omitempty"`
}

type ContinuousBackupInfoParameters struct {
}

type InitialUserInitParameters struct {

	// The database username.
	User *string `json:"user,omitempty" tf:"user,omitempty"`
}

type InitialUserObservation struct {

	// The database username.
	User *string `json:"user,omitempty" tf:"user,omitempty"`
}

type InitialUserParameters struct {

	// The initial password for the user.
	// Note: This property is sensitive and will not be displayed in the plan.
	// +kubebuilder:validation:Required
	PasswordSecretRef v1.SecretKeySelector `json:"passwordSecretRef" tf:"-"`

	// The database username.
	// +kubebuilder:validation:Optional
	User *string `json:"user,omitempty" tf:"user,omitempty"`
}

type MigrationSourceInitParameters struct {
}

type MigrationSourceObservation struct {

	// The host and port of the on-premises instance in host:port format
	HostPort *string `json:"hostPort,omitempty" tf:"host_port,omitempty"`

	// Place holder for the external source identifier(e.g DMS job name) that created the cluster.
	ReferenceID *string `json:"referenceId,omitempty" tf:"reference_id,omitempty"`

	// Type of migration source.
	SourceType *string `json:"sourceType,omitempty" tf:"source_type,omitempty"`
}

type MigrationSourceParameters struct {
}

type NetworkConfigInitParameters struct {

	// The name of the allocated IP range for the private IP AlloyDB cluster. For example: "google-managed-services-default".
	// If set, the instance IPs for this cluster will be created in the allocated range.
	AllocatedIPRange *string `json:"allocatedIpRange,omitempty" tf:"allocated_ip_range,omitempty"`

	// The resource link for the VPC network in which cluster resources are created and from which they are accessible via Private IP. The network must belong to the same project as the cluster.
	// It is specified in the form: "projects/{projectNumber}/global/networks/{network_id}".
	Network *string `json:"network,omitempty" tf:"network,omitempty"`
}

type NetworkConfigObservation struct {

	// The name of the allocated IP range for the private IP AlloyDB cluster. For example: "google-managed-services-default".
	// If set, the instance IPs for this cluster will be created in the allocated range.
	AllocatedIPRange *string `json:"allocatedIpRange,omitempty" tf:"allocated_ip_range,omitempty"`

	// The resource link for the VPC network in which cluster resources are created and from which they are accessible via Private IP. The network must belong to the same project as the cluster.
	// It is specified in the form: "projects/{projectNumber}/global/networks/{network_id}".
	Network *string `json:"network,omitempty" tf:"network,omitempty"`
}

type NetworkConfigParameters struct {

	// The name of the allocated IP range for the private IP AlloyDB cluster. For example: "google-managed-services-default".
	// If set, the instance IPs for this cluster will be created in the allocated range.
	// +kubebuilder:validation:Optional
	AllocatedIPRange *string `json:"allocatedIpRange,omitempty" tf:"allocated_ip_range,omitempty"`

	// The resource link for the VPC network in which cluster resources are created and from which they are accessible via Private IP. The network must belong to the same project as the cluster.
	// It is specified in the form: "projects/{projectNumber}/global/networks/{network_id}".
	// +kubebuilder:validation:Optional
	Network *string `json:"network,omitempty" tf:"network,omitempty"`
}

type QuantityBasedRetentionInitParameters struct {

	// The number of backups to retain.
	Count *float64 `json:"count,omitempty" tf:"count,omitempty"`
}

type QuantityBasedRetentionObservation struct {

	// The number of backups to retain.
	Count *float64 `json:"count,omitempty" tf:"count,omitempty"`
}

type QuantityBasedRetentionParameters struct {

	// The number of backups to retain.
	// +kubebuilder:validation:Optional
	Count *float64 `json:"count,omitempty" tf:"count,omitempty"`
}

type RestoreBackupSourceInitParameters struct {

	// The name of the backup that this cluster is restored from.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/alloydb/v1beta1.Backup
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("name",true)
	BackupName *string `json:"backupName,omitempty" tf:"backup_name,omitempty"`

	// Reference to a Backup in alloydb to populate backupName.
	// +kubebuilder:validation:Optional
	BackupNameRef *v1.Reference `json:"backupNameRef,omitempty" tf:"-"`

	// Selector for a Backup in alloydb to populate backupName.
	// +kubebuilder:validation:Optional
	BackupNameSelector *v1.Selector `json:"backupNameSelector,omitempty" tf:"-"`
}

type RestoreBackupSourceObservation struct {

	// The name of the backup that this cluster is restored from.
	BackupName *string `json:"backupName,omitempty" tf:"backup_name,omitempty"`
}

type RestoreBackupSourceParameters struct {

	// The name of the backup that this cluster is restored from.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/alloydb/v1beta1.Backup
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("name",true)
	// +kubebuilder:validation:Optional
	BackupName *string `json:"backupName,omitempty" tf:"backup_name,omitempty"`

	// Reference to a Backup in alloydb to populate backupName.
	// +kubebuilder:validation:Optional
	BackupNameRef *v1.Reference `json:"backupNameRef,omitempty" tf:"-"`

	// Selector for a Backup in alloydb to populate backupName.
	// +kubebuilder:validation:Optional
	BackupNameSelector *v1.Selector `json:"backupNameSelector,omitempty" tf:"-"`
}

type RestoreContinuousBackupSourceInitParameters struct {

	// The name of the source cluster that this cluster is restored from.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/alloydb/v1beta1.Cluster
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("name",true)
	Cluster *string `json:"cluster,omitempty" tf:"cluster,omitempty"`

	// Reference to a Cluster in alloydb to populate cluster.
	// +kubebuilder:validation:Optional
	ClusterRef *v1.Reference `json:"clusterRef,omitempty" tf:"-"`

	// Selector for a Cluster in alloydb to populate cluster.
	// +kubebuilder:validation:Optional
	ClusterSelector *v1.Selector `json:"clusterSelector,omitempty" tf:"-"`

	// The point in time that this cluster is restored to, in RFC 3339 format.
	PointInTime *string `json:"pointInTime,omitempty" tf:"point_in_time,omitempty"`
}

type RestoreContinuousBackupSourceObservation struct {

	// The name of the source cluster that this cluster is restored from.
	Cluster *string `json:"cluster,omitempty" tf:"cluster,omitempty"`

	// The point in time that this cluster is restored to, in RFC 3339 format.
	PointInTime *string `json:"pointInTime,omitempty" tf:"point_in_time,omitempty"`
}

type RestoreContinuousBackupSourceParameters struct {

	// The name of the source cluster that this cluster is restored from.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/alloydb/v1beta1.Cluster
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("name",true)
	// +kubebuilder:validation:Optional
	Cluster *string `json:"cluster,omitempty" tf:"cluster,omitempty"`

	// Reference to a Cluster in alloydb to populate cluster.
	// +kubebuilder:validation:Optional
	ClusterRef *v1.Reference `json:"clusterRef,omitempty" tf:"-"`

	// Selector for a Cluster in alloydb to populate cluster.
	// +kubebuilder:validation:Optional
	ClusterSelector *v1.Selector `json:"clusterSelector,omitempty" tf:"-"`

	// The point in time that this cluster is restored to, in RFC 3339 format.
	// +kubebuilder:validation:Optional
	PointInTime *string `json:"pointInTime" tf:"point_in_time,omitempty"`
}

type SecondaryConfigInitParameters struct {

	// Name of the primary cluster must be in the format
	// 'projects/{project}/locations/{location}/clusters/{cluster_id}'
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/alloydb/v1beta1.Cluster
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("name",true)
	PrimaryClusterName *string `json:"primaryClusterName,omitempty" tf:"primary_cluster_name,omitempty"`

	// Reference to a Cluster in alloydb to populate primaryClusterName.
	// +kubebuilder:validation:Optional
	PrimaryClusterNameRef *v1.Reference `json:"primaryClusterNameRef,omitempty" tf:"-"`

	// Selector for a Cluster in alloydb to populate primaryClusterName.
	// +kubebuilder:validation:Optional
	PrimaryClusterNameSelector *v1.Selector `json:"primaryClusterNameSelector,omitempty" tf:"-"`
}

type SecondaryConfigObservation struct {

	// Name of the primary cluster must be in the format
	// 'projects/{project}/locations/{location}/clusters/{cluster_id}'
	PrimaryClusterName *string `json:"primaryClusterName,omitempty" tf:"primary_cluster_name,omitempty"`
}

type SecondaryConfigParameters struct {

	// Name of the primary cluster must be in the format
	// 'projects/{project}/locations/{location}/clusters/{cluster_id}'
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/alloydb/v1beta1.Cluster
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("name",true)
	// +kubebuilder:validation:Optional
	PrimaryClusterName *string `json:"primaryClusterName,omitempty" tf:"primary_cluster_name,omitempty"`

	// Reference to a Cluster in alloydb to populate primaryClusterName.
	// +kubebuilder:validation:Optional
	PrimaryClusterNameRef *v1.Reference `json:"primaryClusterNameRef,omitempty" tf:"-"`

	// Selector for a Cluster in alloydb to populate primaryClusterName.
	// +kubebuilder:validation:Optional
	PrimaryClusterNameSelector *v1.Selector `json:"primaryClusterNameSelector,omitempty" tf:"-"`
}

type StartTimesInitParameters struct {

	// Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
	Hours *float64 `json:"hours,omitempty" tf:"hours,omitempty"`

	// Minutes of hour of day. Currently, only the value 0 is supported.
	Minutes *float64 `json:"minutes,omitempty" tf:"minutes,omitempty"`

	// Fractions of seconds in nanoseconds. Currently, only the value 0 is supported.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Seconds of minutes of the time. Currently, only the value 0 is supported.
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type StartTimesObservation struct {

	// Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
	Hours *float64 `json:"hours,omitempty" tf:"hours,omitempty"`

	// Minutes of hour of day. Currently, only the value 0 is supported.
	Minutes *float64 `json:"minutes,omitempty" tf:"minutes,omitempty"`

	// Fractions of seconds in nanoseconds. Currently, only the value 0 is supported.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Seconds of minutes of the time. Currently, only the value 0 is supported.
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type StartTimesParameters struct {

	// Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
	// +kubebuilder:validation:Optional
	Hours *float64 `json:"hours,omitempty" tf:"hours,omitempty"`

	// Minutes of hour of day. Currently, only the value 0 is supported.
	// +kubebuilder:validation:Optional
	Minutes *float64 `json:"minutes,omitempty" tf:"minutes,omitempty"`

	// Fractions of seconds in nanoseconds. Currently, only the value 0 is supported.
	// +kubebuilder:validation:Optional
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Seconds of minutes of the time. Currently, only the value 0 is supported.
	// +kubebuilder:validation:Optional
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type TimeBasedRetentionInitParameters struct {

	// The retention period.
	// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	RetentionPeriod *string `json:"retentionPeriod,omitempty" tf:"retention_period,omitempty"`
}

type TimeBasedRetentionObservation struct {

	// The retention period.
	// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	RetentionPeriod *string `json:"retentionPeriod,omitempty" tf:"retention_period,omitempty"`
}

type TimeBasedRetentionParameters struct {

	// The retention period.
	// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	// +kubebuilder:validation:Optional
	RetentionPeriod *string `json:"retentionPeriod,omitempty" tf:"retention_period,omitempty"`
}

type WeeklyScheduleInitParameters struct {

	// The days of the week to perform a backup. At least one day of the week must be provided.
	// Each value may be one of: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
	DaysOfWeek []*string `json:"daysOfWeek,omitempty" tf:"days_of_week,omitempty"`

	// The times during the day to start a backup. At least one start time must be provided. The start times are assumed to be in UTC and to be an exact hour (e.g., 04:00:00).
	// Structure is documented below.
	StartTimes []StartTimesInitParameters `json:"startTimes,omitempty" tf:"start_times,omitempty"`
}

type WeeklyScheduleObservation struct {

	// The days of the week to perform a backup. At least one day of the week must be provided.
	// Each value may be one of: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
	DaysOfWeek []*string `json:"daysOfWeek,omitempty" tf:"days_of_week,omitempty"`

	// The times during the day to start a backup. At least one start time must be provided. The start times are assumed to be in UTC and to be an exact hour (e.g., 04:00:00).
	// Structure is documented below.
	StartTimes []StartTimesObservation `json:"startTimes,omitempty" tf:"start_times,omitempty"`
}

type WeeklyScheduleParameters struct {

	// The days of the week to perform a backup. At least one day of the week must be provided.
	// Each value may be one of: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
	// +kubebuilder:validation:Optional
	DaysOfWeek []*string `json:"daysOfWeek,omitempty" tf:"days_of_week,omitempty"`

	// The times during the day to start a backup. At least one start time must be provided. The start times are assumed to be in UTC and to be an exact hour (e.g., 04:00:00).
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	StartTimes []StartTimesParameters `json:"startTimes" tf:"start_times,omitempty"`
}

// ClusterSpec defines the desired state of Cluster
type ClusterSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ClusterParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider ClusterInitParameters `json:"initProvider,omitempty"`
}

// ClusterStatus defines the observed state of Cluster.
type ClusterStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ClusterObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Cluster is the Schema for the Clusters API. A managed alloydb cluster.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcp}
type Cluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ClusterSpec   `json:"spec"`
	Status            ClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ClusterList contains a list of Clusters
type ClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Cluster `json:"items"`
}

// Repository type metadata.
var (
	Cluster_Kind             = "Cluster"
	Cluster_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Cluster_Kind}.String()
	Cluster_KindAPIVersion   = Cluster_Kind + "." + CRDGroupVersion.String()
	Cluster_GroupVersionKind = CRDGroupVersion.WithKind(Cluster_Kind)
)

func init() {
	SchemeBuilder.Register(&Cluster{}, &ClusterList{})
}
