// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1beta2

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AvroOptionsInitParameters struct {

	// If is set to true, indicates whether
	// to interpret logical types as the corresponding BigQuery data type
	// (for example, TIMESTAMP), instead of using the raw type (for example, INTEGER).
	UseAvroLogicalTypes *bool `json:"useAvroLogicalTypes,omitempty" tf:"use_avro_logical_types,omitempty"`
}

type AvroOptionsObservation struct {

	// If is set to true, indicates whether
	// to interpret logical types as the corresponding BigQuery data type
	// (for example, TIMESTAMP), instead of using the raw type (for example, INTEGER).
	UseAvroLogicalTypes *bool `json:"useAvroLogicalTypes,omitempty" tf:"use_avro_logical_types,omitempty"`
}

type AvroOptionsParameters struct {

	// If is set to true, indicates whether
	// to interpret logical types as the corresponding BigQuery data type
	// (for example, TIMESTAMP), instead of using the raw type (for example, INTEGER).
	// +kubebuilder:validation:Optional
	UseAvroLogicalTypes *bool `json:"useAvroLogicalTypes" tf:"use_avro_logical_types,omitempty"`
}

type ColumnReferencesInitParameters struct {

	// :  The column in the primary key that are
	// referenced by the referencingColumn
	ReferencedColumn *string `json:"referencedColumn,omitempty" tf:"referenced_column,omitempty"`

	// :  The column that composes the foreign key.
	ReferencingColumn *string `json:"referencingColumn,omitempty" tf:"referencing_column,omitempty"`
}

type ColumnReferencesObservation struct {

	// :  The column in the primary key that are
	// referenced by the referencingColumn
	ReferencedColumn *string `json:"referencedColumn,omitempty" tf:"referenced_column,omitempty"`

	// :  The column that composes the foreign key.
	ReferencingColumn *string `json:"referencingColumn,omitempty" tf:"referencing_column,omitempty"`
}

type ColumnReferencesParameters struct {

	// :  The column in the primary key that are
	// referenced by the referencingColumn
	// +kubebuilder:validation:Optional
	ReferencedColumn *string `json:"referencedColumn" tf:"referenced_column,omitempty"`

	// :  The column that composes the foreign key.
	// +kubebuilder:validation:Optional
	ReferencingColumn *string `json:"referencingColumn" tf:"referencing_column,omitempty"`
}

type CsvOptionsInitParameters struct {

	// Indicates if BigQuery should accept rows
	// that are missing trailing optional columns.
	AllowJaggedRows *bool `json:"allowJaggedRows,omitempty" tf:"allow_jagged_rows,omitempty"`

	// Indicates if BigQuery should allow
	// quoted data sections that contain newline characters in a CSV file.
	// The default value is false.
	AllowQuotedNewlines *bool `json:"allowQuotedNewlines,omitempty" tf:"allow_quoted_newlines,omitempty"`

	// The character encoding of the data. The supported values are UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE. The default value is UTF-8.
	Encoding *string `json:"encoding,omitempty" tf:"encoding,omitempty"`

	// The separator for fields in a CSV file.
	FieldDelimiter *string `json:"fieldDelimiter,omitempty" tf:"field_delimiter,omitempty"`

	// The value that is used to quote data sections in a
	// CSV file. If your data does not contain quoted sections, set the
	// property value to an empty string. If your data contains quoted newline
	// characters, you must also set the allow_quoted_newlines property to true.
	Quote *string `json:"quote,omitempty" tf:"quote,omitempty"`

	// The number of rows at the top of the sheet
	// that BigQuery will skip when reading the data. At least one of range or
	// skip_leading_rows must be set.
	SkipLeadingRows *float64 `json:"skipLeadingRows,omitempty" tf:"skip_leading_rows,omitempty"`
}

type CsvOptionsObservation struct {

	// Indicates if BigQuery should accept rows
	// that are missing trailing optional columns.
	AllowJaggedRows *bool `json:"allowJaggedRows,omitempty" tf:"allow_jagged_rows,omitempty"`

	// Indicates if BigQuery should allow
	// quoted data sections that contain newline characters in a CSV file.
	// The default value is false.
	AllowQuotedNewlines *bool `json:"allowQuotedNewlines,omitempty" tf:"allow_quoted_newlines,omitempty"`

	// The character encoding of the data. The supported values are UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE. The default value is UTF-8.
	Encoding *string `json:"encoding,omitempty" tf:"encoding,omitempty"`

	// The separator for fields in a CSV file.
	FieldDelimiter *string `json:"fieldDelimiter,omitempty" tf:"field_delimiter,omitempty"`

	// The value that is used to quote data sections in a
	// CSV file. If your data does not contain quoted sections, set the
	// property value to an empty string. If your data contains quoted newline
	// characters, you must also set the allow_quoted_newlines property to true.
	Quote *string `json:"quote,omitempty" tf:"quote,omitempty"`

	// The number of rows at the top of the sheet
	// that BigQuery will skip when reading the data. At least one of range or
	// skip_leading_rows must be set.
	SkipLeadingRows *float64 `json:"skipLeadingRows,omitempty" tf:"skip_leading_rows,omitempty"`
}

type CsvOptionsParameters struct {

	// Indicates if BigQuery should accept rows
	// that are missing trailing optional columns.
	// +kubebuilder:validation:Optional
	AllowJaggedRows *bool `json:"allowJaggedRows,omitempty" tf:"allow_jagged_rows,omitempty"`

	// Indicates if BigQuery should allow
	// quoted data sections that contain newline characters in a CSV file.
	// The default value is false.
	// +kubebuilder:validation:Optional
	AllowQuotedNewlines *bool `json:"allowQuotedNewlines,omitempty" tf:"allow_quoted_newlines,omitempty"`

	// The character encoding of the data. The supported values are UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE. The default value is UTF-8.
	// +kubebuilder:validation:Optional
	Encoding *string `json:"encoding,omitempty" tf:"encoding,omitempty"`

	// The separator for fields in a CSV file.
	// +kubebuilder:validation:Optional
	FieldDelimiter *string `json:"fieldDelimiter,omitempty" tf:"field_delimiter,omitempty"`

	// The value that is used to quote data sections in a
	// CSV file. If your data does not contain quoted sections, set the
	// property value to an empty string. If your data contains quoted newline
	// characters, you must also set the allow_quoted_newlines property to true.
	// +kubebuilder:validation:Optional
	Quote *string `json:"quote" tf:"quote,omitempty"`

	// The number of rows at the top of the sheet
	// that BigQuery will skip when reading the data. At least one of range or
	// skip_leading_rows must be set.
	// +kubebuilder:validation:Optional
	SkipLeadingRows *float64 `json:"skipLeadingRows,omitempty" tf:"skip_leading_rows,omitempty"`
}

type EncryptionConfigurationInitParameters struct {

	// The self link or full name of a key which should be used to
	// encrypt this table.  Note that the default bigquery service account will need to have
	// encrypt/decrypt permissions on this key - you may want to see the
	// google_bigquery_default_service_account datasource and the
	// google_kms_crypto_key_iam_binding resource.
	KMSKeyName *string `json:"kmsKeyName,omitempty" tf:"kms_key_name,omitempty"`
}

type EncryptionConfigurationObservation struct {

	// The self link or full name of a key which should be used to
	// encrypt this table.  Note that the default bigquery service account will need to have
	// encrypt/decrypt permissions on this key - you may want to see the
	// google_bigquery_default_service_account datasource and the
	// google_kms_crypto_key_iam_binding resource.
	KMSKeyName *string `json:"kmsKeyName,omitempty" tf:"kms_key_name,omitempty"`

	// The self link or full name of the kms key version used to encrypt this table.
	KMSKeyVersion *string `json:"kmsKeyVersion,omitempty" tf:"kms_key_version,omitempty"`
}

type EncryptionConfigurationParameters struct {

	// The self link or full name of a key which should be used to
	// encrypt this table.  Note that the default bigquery service account will need to have
	// encrypt/decrypt permissions on this key - you may want to see the
	// google_bigquery_default_service_account datasource and the
	// google_kms_crypto_key_iam_binding resource.
	// +kubebuilder:validation:Optional
	KMSKeyName *string `json:"kmsKeyName" tf:"kms_key_name,omitempty"`
}

type ExternalDataConfigurationInitParameters struct {

	// - Let BigQuery try to autodetect the schema
	// and format of the table.
	Autodetect *bool `json:"autodetect,omitempty" tf:"autodetect,omitempty"`

	// Additional options if source_format is set to
	// "AVRO".  Structure is documented below.
	AvroOptions *AvroOptionsInitParameters `json:"avroOptions,omitempty" tf:"avro_options,omitempty"`

	// The compression type of the data source.
	// Valid values are "NONE" or "GZIP".
	Compression *string `json:"compression,omitempty" tf:"compression,omitempty"`

	// The connection specifying the credentials to be used to read
	// external storage, such as Azure Blob, Cloud Storage, or S3. The connection_id can have
	// the form {{project}}.{{location}}.{{connection_id}}
	// or projects/{{project}}/locations/{{location}}/connections/{{connection_id}}.
	ConnectionID *string `json:"connectionId,omitempty" tf:"connection_id,omitempty"`

	// Additional properties to set if
	// source_format is set to "CSV". Structure is documented below.
	CsvOptions *CsvOptionsInitParameters `json:"csvOptions,omitempty" tf:"csv_options,omitempty"`

	// Specifies how source URIs are interpreted for constructing the file set to load.
	// By default source URIs are expanded against the underlying storage.
	// Other options include specifying manifest files. Only applicable to object storage systems. Docs
	FileSetSpecType *string `json:"fileSetSpecType,omitempty" tf:"file_set_spec_type,omitempty"`

	// Additional options if
	// source_format is set to "GOOGLE_SHEETS". Structure is
	// documented below.
	GoogleSheetsOptions *GoogleSheetsOptionsInitParameters `json:"googleSheetsOptions,omitempty" tf:"google_sheets_options,omitempty"`

	// When set, configures hive partitioning
	// support. Not all storage formats support hive partitioning -- requesting hive
	// partitioning on an unsupported format will lead to an error, as will providing
	// an invalid specification. Structure is documented below.
	HivePartitioningOptions *HivePartitioningOptionsInitParameters `json:"hivePartitioningOptions,omitempty" tf:"hive_partitioning_options,omitempty"`

	// Indicates if BigQuery should
	// allow extra values that are not represented in the table schema.
	// If true, the extra values are ignored. If false, records with
	// extra columns are treated as bad records, and if there are too
	// many bad records, an invalid error is returned in the job result.
	// The default value is false.
	IgnoreUnknownValues *bool `json:"ignoreUnknownValues,omitempty" tf:"ignore_unknown_values,omitempty"`

	// Used to indicate that a JSON variant, rather than normal JSON, is being used as the sourceFormat. This should only be used in combination with the JSON source format. Valid values are: GEOJSON.
	JSONExtension *string `json:"jsonExtension,omitempty" tf:"json_extension,omitempty"`

	// Additional properties to set if
	// source_format is set to "JSON". Structure is documented below.
	JSONOptions *JSONOptionsInitParameters `json:"jsonOptions,omitempty" tf:"json_options,omitempty"`

	// The maximum number of bad records that
	// BigQuery can ignore when reading data.
	MaxBadRecords *float64 `json:"maxBadRecords,omitempty" tf:"max_bad_records,omitempty"`

	// Metadata Cache Mode for the table. Set this to enable caching of metadata from external data source. Valid values are AUTOMATIC and MANUAL.
	MetadataCacheMode *string `json:"metadataCacheMode,omitempty" tf:"metadata_cache_mode,omitempty"`

	// Object Metadata is used to create Object Tables. Object Tables contain a listing of objects (with their metadata) found at the sourceUris. If object_metadata is set, source_format should be omitted.
	ObjectMetadata *string `json:"objectMetadata,omitempty" tf:"object_metadata,omitempty"`

	// Additional properties to set if
	// source_format is set to "PARQUET". Structure is documented below.
	ParquetOptions *ExternalDataConfigurationParquetOptionsInitParameters `json:"parquetOptions,omitempty" tf:"parquet_options,omitempty"`

	// When creating an external table, the user can provide a reference file with the table schema. This is enabled for the following formats: AVRO, PARQUET, ORC.
	ReferenceFileSchemaURI *string `json:"referenceFileSchemaUri,omitempty" tf:"reference_file_schema_uri,omitempty"`

	// A JSON schema for the external table. Schema is required
	// for CSV and JSON formats if autodetect is not on. Schema is disallowed
	// for Google Cloud Bigtable, Cloud Datastore backups, Avro, Iceberg, ORC and Parquet formats.
	// ~>NOTE: Because this field expects a JSON string, any changes to the
	// string will create a diff, even if the JSON itself hasn't changed.
	// Furthermore drift for this field cannot not be detected because BigQuery
	// only uses this schema to compute the effective schema for the table, therefore
	// any changes on the configured value will force the table to be recreated.
	// This schema is effectively only applied when creating a table from an external
	// datasource, after creation the computed schema will be stored in
	// google_bigquery_table.schema
	Schema *string `json:"schema,omitempty" tf:"schema,omitempty"`

	// The data format. Please see sourceFormat under
	// ExternalDataConfiguration
	// in Bigquery's public API documentation for supported formats. To use "GOOGLE_SHEETS"
	// the scopes must include "https://www.googleapis.com/auth/drive.readonly".
	SourceFormat *string `json:"sourceFormat,omitempty" tf:"source_format,omitempty"`

	// A list of the fully-qualified URIs that point to
	// your data in Google Cloud.
	SourceUris []*string `json:"sourceUris,omitempty" tf:"source_uris,omitempty"`
}

type ExternalDataConfigurationObservation struct {

	// - Let BigQuery try to autodetect the schema
	// and format of the table.
	Autodetect *bool `json:"autodetect,omitempty" tf:"autodetect,omitempty"`

	// Additional options if source_format is set to
	// "AVRO".  Structure is documented below.
	AvroOptions *AvroOptionsObservation `json:"avroOptions,omitempty" tf:"avro_options,omitempty"`

	// The compression type of the data source.
	// Valid values are "NONE" or "GZIP".
	Compression *string `json:"compression,omitempty" tf:"compression,omitempty"`

	// The connection specifying the credentials to be used to read
	// external storage, such as Azure Blob, Cloud Storage, or S3. The connection_id can have
	// the form {{project}}.{{location}}.{{connection_id}}
	// or projects/{{project}}/locations/{{location}}/connections/{{connection_id}}.
	ConnectionID *string `json:"connectionId,omitempty" tf:"connection_id,omitempty"`

	// Additional properties to set if
	// source_format is set to "CSV". Structure is documented below.
	CsvOptions *CsvOptionsObservation `json:"csvOptions,omitempty" tf:"csv_options,omitempty"`

	// Specifies how source URIs are interpreted for constructing the file set to load.
	// By default source URIs are expanded against the underlying storage.
	// Other options include specifying manifest files. Only applicable to object storage systems. Docs
	FileSetSpecType *string `json:"fileSetSpecType,omitempty" tf:"file_set_spec_type,omitempty"`

	// Additional options if
	// source_format is set to "GOOGLE_SHEETS". Structure is
	// documented below.
	GoogleSheetsOptions *GoogleSheetsOptionsObservation `json:"googleSheetsOptions,omitempty" tf:"google_sheets_options,omitempty"`

	// When set, configures hive partitioning
	// support. Not all storage formats support hive partitioning -- requesting hive
	// partitioning on an unsupported format will lead to an error, as will providing
	// an invalid specification. Structure is documented below.
	HivePartitioningOptions *HivePartitioningOptionsObservation `json:"hivePartitioningOptions,omitempty" tf:"hive_partitioning_options,omitempty"`

	// Indicates if BigQuery should
	// allow extra values that are not represented in the table schema.
	// If true, the extra values are ignored. If false, records with
	// extra columns are treated as bad records, and if there are too
	// many bad records, an invalid error is returned in the job result.
	// The default value is false.
	IgnoreUnknownValues *bool `json:"ignoreUnknownValues,omitempty" tf:"ignore_unknown_values,omitempty"`

	// Used to indicate that a JSON variant, rather than normal JSON, is being used as the sourceFormat. This should only be used in combination with the JSON source format. Valid values are: GEOJSON.
	JSONExtension *string `json:"jsonExtension,omitempty" tf:"json_extension,omitempty"`

	// Additional properties to set if
	// source_format is set to "JSON". Structure is documented below.
	JSONOptions *JSONOptionsObservation `json:"jsonOptions,omitempty" tf:"json_options,omitempty"`

	// The maximum number of bad records that
	// BigQuery can ignore when reading data.
	MaxBadRecords *float64 `json:"maxBadRecords,omitempty" tf:"max_bad_records,omitempty"`

	// Metadata Cache Mode for the table. Set this to enable caching of metadata from external data source. Valid values are AUTOMATIC and MANUAL.
	MetadataCacheMode *string `json:"metadataCacheMode,omitempty" tf:"metadata_cache_mode,omitempty"`

	// Object Metadata is used to create Object Tables. Object Tables contain a listing of objects (with their metadata) found at the sourceUris. If object_metadata is set, source_format should be omitted.
	ObjectMetadata *string `json:"objectMetadata,omitempty" tf:"object_metadata,omitempty"`

	// Additional properties to set if
	// source_format is set to "PARQUET". Structure is documented below.
	ParquetOptions *ExternalDataConfigurationParquetOptionsObservation `json:"parquetOptions,omitempty" tf:"parquet_options,omitempty"`

	// When creating an external table, the user can provide a reference file with the table schema. This is enabled for the following formats: AVRO, PARQUET, ORC.
	ReferenceFileSchemaURI *string `json:"referenceFileSchemaUri,omitempty" tf:"reference_file_schema_uri,omitempty"`

	// A JSON schema for the external table. Schema is required
	// for CSV and JSON formats if autodetect is not on. Schema is disallowed
	// for Google Cloud Bigtable, Cloud Datastore backups, Avro, Iceberg, ORC and Parquet formats.
	// ~>NOTE: Because this field expects a JSON string, any changes to the
	// string will create a diff, even if the JSON itself hasn't changed.
	// Furthermore drift for this field cannot not be detected because BigQuery
	// only uses this schema to compute the effective schema for the table, therefore
	// any changes on the configured value will force the table to be recreated.
	// This schema is effectively only applied when creating a table from an external
	// datasource, after creation the computed schema will be stored in
	// google_bigquery_table.schema
	Schema *string `json:"schema,omitempty" tf:"schema,omitempty"`

	// The data format. Please see sourceFormat under
	// ExternalDataConfiguration
	// in Bigquery's public API documentation for supported formats. To use "GOOGLE_SHEETS"
	// the scopes must include "https://www.googleapis.com/auth/drive.readonly".
	SourceFormat *string `json:"sourceFormat,omitempty" tf:"source_format,omitempty"`

	// A list of the fully-qualified URIs that point to
	// your data in Google Cloud.
	SourceUris []*string `json:"sourceUris,omitempty" tf:"source_uris,omitempty"`
}

type ExternalDataConfigurationParameters struct {

	// - Let BigQuery try to autodetect the schema
	// and format of the table.
	// +kubebuilder:validation:Optional
	Autodetect *bool `json:"autodetect" tf:"autodetect,omitempty"`

	// Additional options if source_format is set to
	// "AVRO".  Structure is documented below.
	// +kubebuilder:validation:Optional
	AvroOptions *AvroOptionsParameters `json:"avroOptions,omitempty" tf:"avro_options,omitempty"`

	// The compression type of the data source.
	// Valid values are "NONE" or "GZIP".
	// +kubebuilder:validation:Optional
	Compression *string `json:"compression,omitempty" tf:"compression,omitempty"`

	// The connection specifying the credentials to be used to read
	// external storage, such as Azure Blob, Cloud Storage, or S3. The connection_id can have
	// the form {{project}}.{{location}}.{{connection_id}}
	// or projects/{{project}}/locations/{{location}}/connections/{{connection_id}}.
	// +kubebuilder:validation:Optional
	ConnectionID *string `json:"connectionId,omitempty" tf:"connection_id,omitempty"`

	// Additional properties to set if
	// source_format is set to "CSV". Structure is documented below.
	// +kubebuilder:validation:Optional
	CsvOptions *CsvOptionsParameters `json:"csvOptions,omitempty" tf:"csv_options,omitempty"`

	// Specifies how source URIs are interpreted for constructing the file set to load.
	// By default source URIs are expanded against the underlying storage.
	// Other options include specifying manifest files. Only applicable to object storage systems. Docs
	// +kubebuilder:validation:Optional
	FileSetSpecType *string `json:"fileSetSpecType,omitempty" tf:"file_set_spec_type,omitempty"`

	// Additional options if
	// source_format is set to "GOOGLE_SHEETS". Structure is
	// documented below.
	// +kubebuilder:validation:Optional
	GoogleSheetsOptions *GoogleSheetsOptionsParameters `json:"googleSheetsOptions,omitempty" tf:"google_sheets_options,omitempty"`

	// When set, configures hive partitioning
	// support. Not all storage formats support hive partitioning -- requesting hive
	// partitioning on an unsupported format will lead to an error, as will providing
	// an invalid specification. Structure is documented below.
	// +kubebuilder:validation:Optional
	HivePartitioningOptions *HivePartitioningOptionsParameters `json:"hivePartitioningOptions,omitempty" tf:"hive_partitioning_options,omitempty"`

	// Indicates if BigQuery should
	// allow extra values that are not represented in the table schema.
	// If true, the extra values are ignored. If false, records with
	// extra columns are treated as bad records, and if there are too
	// many bad records, an invalid error is returned in the job result.
	// The default value is false.
	// +kubebuilder:validation:Optional
	IgnoreUnknownValues *bool `json:"ignoreUnknownValues,omitempty" tf:"ignore_unknown_values,omitempty"`

	// Used to indicate that a JSON variant, rather than normal JSON, is being used as the sourceFormat. This should only be used in combination with the JSON source format. Valid values are: GEOJSON.
	// +kubebuilder:validation:Optional
	JSONExtension *string `json:"jsonExtension,omitempty" tf:"json_extension,omitempty"`

	// Additional properties to set if
	// source_format is set to "JSON". Structure is documented below.
	// +kubebuilder:validation:Optional
	JSONOptions *JSONOptionsParameters `json:"jsonOptions,omitempty" tf:"json_options,omitempty"`

	// The maximum number of bad records that
	// BigQuery can ignore when reading data.
	// +kubebuilder:validation:Optional
	MaxBadRecords *float64 `json:"maxBadRecords,omitempty" tf:"max_bad_records,omitempty"`

	// Metadata Cache Mode for the table. Set this to enable caching of metadata from external data source. Valid values are AUTOMATIC and MANUAL.
	// +kubebuilder:validation:Optional
	MetadataCacheMode *string `json:"metadataCacheMode,omitempty" tf:"metadata_cache_mode,omitempty"`

	// Object Metadata is used to create Object Tables. Object Tables contain a listing of objects (with their metadata) found at the sourceUris. If object_metadata is set, source_format should be omitted.
	// +kubebuilder:validation:Optional
	ObjectMetadata *string `json:"objectMetadata,omitempty" tf:"object_metadata,omitempty"`

	// Additional properties to set if
	// source_format is set to "PARQUET". Structure is documented below.
	// +kubebuilder:validation:Optional
	ParquetOptions *ExternalDataConfigurationParquetOptionsParameters `json:"parquetOptions,omitempty" tf:"parquet_options,omitempty"`

	// When creating an external table, the user can provide a reference file with the table schema. This is enabled for the following formats: AVRO, PARQUET, ORC.
	// +kubebuilder:validation:Optional
	ReferenceFileSchemaURI *string `json:"referenceFileSchemaUri,omitempty" tf:"reference_file_schema_uri,omitempty"`

	// A JSON schema for the external table. Schema is required
	// for CSV and JSON formats if autodetect is not on. Schema is disallowed
	// for Google Cloud Bigtable, Cloud Datastore backups, Avro, Iceberg, ORC and Parquet formats.
	// ~>NOTE: Because this field expects a JSON string, any changes to the
	// string will create a diff, even if the JSON itself hasn't changed.
	// Furthermore drift for this field cannot not be detected because BigQuery
	// only uses this schema to compute the effective schema for the table, therefore
	// any changes on the configured value will force the table to be recreated.
	// This schema is effectively only applied when creating a table from an external
	// datasource, after creation the computed schema will be stored in
	// google_bigquery_table.schema
	// +kubebuilder:validation:Optional
	Schema *string `json:"schema,omitempty" tf:"schema,omitempty"`

	// The data format. Please see sourceFormat under
	// ExternalDataConfiguration
	// in Bigquery's public API documentation for supported formats. To use "GOOGLE_SHEETS"
	// the scopes must include "https://www.googleapis.com/auth/drive.readonly".
	// +kubebuilder:validation:Optional
	SourceFormat *string `json:"sourceFormat,omitempty" tf:"source_format,omitempty"`

	// A list of the fully-qualified URIs that point to
	// your data in Google Cloud.
	// +kubebuilder:validation:Optional
	SourceUris []*string `json:"sourceUris" tf:"source_uris,omitempty"`
}

type ExternalDataConfigurationParquetOptionsInitParameters struct {

	// Indicates whether to use schema inference specifically for Parquet LIST logical type.
	EnableListInference *bool `json:"enableListInference,omitempty" tf:"enable_list_inference,omitempty"`

	// Indicates whether to infer Parquet ENUM logical type as STRING instead of BYTES by default.
	EnumAsString *bool `json:"enumAsString,omitempty" tf:"enum_as_string,omitempty"`
}

type ExternalDataConfigurationParquetOptionsObservation struct {

	// Indicates whether to use schema inference specifically for Parquet LIST logical type.
	EnableListInference *bool `json:"enableListInference,omitempty" tf:"enable_list_inference,omitempty"`

	// Indicates whether to infer Parquet ENUM logical type as STRING instead of BYTES by default.
	EnumAsString *bool `json:"enumAsString,omitempty" tf:"enum_as_string,omitempty"`
}

type ExternalDataConfigurationParquetOptionsParameters struct {

	// Indicates whether to use schema inference specifically for Parquet LIST logical type.
	// +kubebuilder:validation:Optional
	EnableListInference *bool `json:"enableListInference,omitempty" tf:"enable_list_inference,omitempty"`

	// Indicates whether to infer Parquet ENUM logical type as STRING instead of BYTES by default.
	// +kubebuilder:validation:Optional
	EnumAsString *bool `json:"enumAsString,omitempty" tf:"enum_as_string,omitempty"`
}

type ForeignKeysInitParameters struct {

	// :  The pair of the foreign key column and primary key column.
	// Structure is documented below.
	ColumnReferences *ColumnReferencesInitParameters `json:"columnReferences,omitempty" tf:"column_references,omitempty"`

	// :  Set only if the foreign key constraint is named.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// :  The table that holds the primary key
	// and is referenced by this foreign key.
	// Structure is documented below.
	ReferencedTable *ReferencedTableInitParameters `json:"referencedTable,omitempty" tf:"referenced_table,omitempty"`
}

type ForeignKeysObservation struct {

	// :  The pair of the foreign key column and primary key column.
	// Structure is documented below.
	ColumnReferences *ColumnReferencesObservation `json:"columnReferences,omitempty" tf:"column_references,omitempty"`

	// :  Set only if the foreign key constraint is named.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// :  The table that holds the primary key
	// and is referenced by this foreign key.
	// Structure is documented below.
	ReferencedTable *ReferencedTableObservation `json:"referencedTable,omitempty" tf:"referenced_table,omitempty"`
}

type ForeignKeysParameters struct {

	// :  The pair of the foreign key column and primary key column.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	ColumnReferences *ColumnReferencesParameters `json:"columnReferences" tf:"column_references,omitempty"`

	// :  Set only if the foreign key constraint is named.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// :  The table that holds the primary key
	// and is referenced by this foreign key.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	ReferencedTable *ReferencedTableParameters `json:"referencedTable" tf:"referenced_table,omitempty"`
}

type GoogleSheetsOptionsInitParameters struct {

	// Information required to partition based on ranges.
	// Structure is documented below.
	Range *string `json:"range,omitempty" tf:"range,omitempty"`

	// The number of rows at the top of the sheet
	// that BigQuery will skip when reading the data. At least one of range or
	// skip_leading_rows must be set.
	SkipLeadingRows *float64 `json:"skipLeadingRows,omitempty" tf:"skip_leading_rows,omitempty"`
}

type GoogleSheetsOptionsObservation struct {

	// Information required to partition based on ranges.
	// Structure is documented below.
	Range *string `json:"range,omitempty" tf:"range,omitempty"`

	// The number of rows at the top of the sheet
	// that BigQuery will skip when reading the data. At least one of range or
	// skip_leading_rows must be set.
	SkipLeadingRows *float64 `json:"skipLeadingRows,omitempty" tf:"skip_leading_rows,omitempty"`
}

type GoogleSheetsOptionsParameters struct {

	// Information required to partition based on ranges.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Range *string `json:"range,omitempty" tf:"range,omitempty"`

	// The number of rows at the top of the sheet
	// that BigQuery will skip when reading the data. At least one of range or
	// skip_leading_rows must be set.
	// +kubebuilder:validation:Optional
	SkipLeadingRows *float64 `json:"skipLeadingRows,omitempty" tf:"skip_leading_rows,omitempty"`
}

type HivePartitioningOptionsInitParameters struct {

	// When set, what mode of hive partitioning to use when
	// reading data. The following modes are supported.
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// If set to true, queries over this table
	// require a partition filter that can be used for partition elimination to be
	// specified. require_partition_filter is deprecated and will be removed in
	// a future major release. Use the top level field with the same name instead.
	RequirePartitionFilter *bool `json:"requirePartitionFilter,omitempty" tf:"require_partition_filter,omitempty"`

	// When hive partition detection is requested,
	// a common for all source uris must be required. The prefix must end immediately
	// before the partition key encoding begins. For example, consider files following
	// this data layout. gs://bucket/path_to_table/dt=2019-06-01/country=USA/id=7/file.avro
	// gs://bucket/path_to_table/dt=2019-05-31/country=CA/id=3/file.avro When hive
	// partitioning is requested with either AUTO or STRINGS detection, the common prefix
	// can be either of gs://bucket/path_to_table or gs://bucket/path_to_table/.
	// Note that when mode is set to CUSTOM, you must encode the partition key schema within the source_uri_prefix by setting source_uri_prefix to gs://bucket/path_to_table/{key1:TYPE1}/{key2:TYPE2}/{key3:TYPE3}.
	SourceURIPrefix *string `json:"sourceUriPrefix,omitempty" tf:"source_uri_prefix,omitempty"`
}

type HivePartitioningOptionsObservation struct {

	// When set, what mode of hive partitioning to use when
	// reading data. The following modes are supported.
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// If set to true, queries over this table
	// require a partition filter that can be used for partition elimination to be
	// specified. require_partition_filter is deprecated and will be removed in
	// a future major release. Use the top level field with the same name instead.
	RequirePartitionFilter *bool `json:"requirePartitionFilter,omitempty" tf:"require_partition_filter,omitempty"`

	// When hive partition detection is requested,
	// a common for all source uris must be required. The prefix must end immediately
	// before the partition key encoding begins. For example, consider files following
	// this data layout. gs://bucket/path_to_table/dt=2019-06-01/country=USA/id=7/file.avro
	// gs://bucket/path_to_table/dt=2019-05-31/country=CA/id=3/file.avro When hive
	// partitioning is requested with either AUTO or STRINGS detection, the common prefix
	// can be either of gs://bucket/path_to_table or gs://bucket/path_to_table/.
	// Note that when mode is set to CUSTOM, you must encode the partition key schema within the source_uri_prefix by setting source_uri_prefix to gs://bucket/path_to_table/{key1:TYPE1}/{key2:TYPE2}/{key3:TYPE3}.
	SourceURIPrefix *string `json:"sourceUriPrefix,omitempty" tf:"source_uri_prefix,omitempty"`
}

type HivePartitioningOptionsParameters struct {

	// When set, what mode of hive partitioning to use when
	// reading data. The following modes are supported.
	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// If set to true, queries over this table
	// require a partition filter that can be used for partition elimination to be
	// specified. require_partition_filter is deprecated and will be removed in
	// a future major release. Use the top level field with the same name instead.
	// +kubebuilder:validation:Optional
	RequirePartitionFilter *bool `json:"requirePartitionFilter,omitempty" tf:"require_partition_filter,omitempty"`

	// When hive partition detection is requested,
	// a common for all source uris must be required. The prefix must end immediately
	// before the partition key encoding begins. For example, consider files following
	// this data layout. gs://bucket/path_to_table/dt=2019-06-01/country=USA/id=7/file.avro
	// gs://bucket/path_to_table/dt=2019-05-31/country=CA/id=3/file.avro When hive
	// partitioning is requested with either AUTO or STRINGS detection, the common prefix
	// can be either of gs://bucket/path_to_table or gs://bucket/path_to_table/.
	// Note that when mode is set to CUSTOM, you must encode the partition key schema within the source_uri_prefix by setting source_uri_prefix to gs://bucket/path_to_table/{key1:TYPE1}/{key2:TYPE2}/{key3:TYPE3}.
	// +kubebuilder:validation:Optional
	SourceURIPrefix *string `json:"sourceUriPrefix,omitempty" tf:"source_uri_prefix,omitempty"`
}

type JSONOptionsInitParameters struct {

	// The character encoding of the data. The supported values are UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE. The default value is UTF-8.
	Encoding *string `json:"encoding,omitempty" tf:"encoding,omitempty"`
}

type JSONOptionsObservation struct {

	// The character encoding of the data. The supported values are UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE. The default value is UTF-8.
	Encoding *string `json:"encoding,omitempty" tf:"encoding,omitempty"`
}

type JSONOptionsParameters struct {

	// The character encoding of the data. The supported values are UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE. The default value is UTF-8.
	// +kubebuilder:validation:Optional
	Encoding *string `json:"encoding,omitempty" tf:"encoding,omitempty"`
}

type MaterializedViewInitParameters struct {

	// Allow non incremental materialized view definition.
	// The default value is false.
	AllowNonIncrementalDefinition *bool `json:"allowNonIncrementalDefinition,omitempty" tf:"allow_non_incremental_definition,omitempty"`

	// Specifies whether to use BigQuery's automatic refresh for this materialized view when the base table is updated.
	// The default value is true.
	EnableRefresh *bool `json:"enableRefresh,omitempty" tf:"enable_refresh,omitempty"`

	// A query whose result is persisted.
	Query *string `json:"query,omitempty" tf:"query,omitempty"`

	// The maximum frequency at which this materialized view will be refreshed.
	// The default value is 1800000
	RefreshIntervalMs *float64 `json:"refreshIntervalMs,omitempty" tf:"refresh_interval_ms,omitempty"`
}

type MaterializedViewObservation struct {

	// Allow non incremental materialized view definition.
	// The default value is false.
	AllowNonIncrementalDefinition *bool `json:"allowNonIncrementalDefinition,omitempty" tf:"allow_non_incremental_definition,omitempty"`

	// Specifies whether to use BigQuery's automatic refresh for this materialized view when the base table is updated.
	// The default value is true.
	EnableRefresh *bool `json:"enableRefresh,omitempty" tf:"enable_refresh,omitempty"`

	// A query whose result is persisted.
	Query *string `json:"query,omitempty" tf:"query,omitempty"`

	// The maximum frequency at which this materialized view will be refreshed.
	// The default value is 1800000
	RefreshIntervalMs *float64 `json:"refreshIntervalMs,omitempty" tf:"refresh_interval_ms,omitempty"`
}

type MaterializedViewParameters struct {

	// Allow non incremental materialized view definition.
	// The default value is false.
	// +kubebuilder:validation:Optional
	AllowNonIncrementalDefinition *bool `json:"allowNonIncrementalDefinition,omitempty" tf:"allow_non_incremental_definition,omitempty"`

	// Specifies whether to use BigQuery's automatic refresh for this materialized view when the base table is updated.
	// The default value is true.
	// +kubebuilder:validation:Optional
	EnableRefresh *bool `json:"enableRefresh,omitempty" tf:"enable_refresh,omitempty"`

	// A query whose result is persisted.
	// +kubebuilder:validation:Optional
	Query *string `json:"query" tf:"query,omitempty"`

	// The maximum frequency at which this materialized view will be refreshed.
	// The default value is 1800000
	// +kubebuilder:validation:Optional
	RefreshIntervalMs *float64 `json:"refreshIntervalMs,omitempty" tf:"refresh_interval_ms,omitempty"`
}

type PrimaryKeyInitParameters struct {

	// :  The columns that are composed of the primary key constraint.
	Columns []*string `json:"columns,omitempty" tf:"columns,omitempty"`
}

type PrimaryKeyObservation struct {

	// :  The columns that are composed of the primary key constraint.
	Columns []*string `json:"columns,omitempty" tf:"columns,omitempty"`
}

type PrimaryKeyParameters struct {

	// :  The columns that are composed of the primary key constraint.
	// +kubebuilder:validation:Optional
	Columns []*string `json:"columns" tf:"columns,omitempty"`
}

type RangeInitParameters struct {

	// End of the range partitioning, exclusive.
	End *float64 `json:"end,omitempty" tf:"end,omitempty"`

	// The width of each range within the partition.
	Interval *float64 `json:"interval,omitempty" tf:"interval,omitempty"`

	// Start of the range partitioning, inclusive.
	Start *float64 `json:"start,omitempty" tf:"start,omitempty"`
}

type RangeObservation struct {

	// End of the range partitioning, exclusive.
	End *float64 `json:"end,omitempty" tf:"end,omitempty"`

	// The width of each range within the partition.
	Interval *float64 `json:"interval,omitempty" tf:"interval,omitempty"`

	// Start of the range partitioning, inclusive.
	Start *float64 `json:"start,omitempty" tf:"start,omitempty"`
}

type RangeParameters struct {

	// End of the range partitioning, exclusive.
	// +kubebuilder:validation:Optional
	End *float64 `json:"end" tf:"end,omitempty"`

	// The width of each range within the partition.
	// +kubebuilder:validation:Optional
	Interval *float64 `json:"interval" tf:"interval,omitempty"`

	// Start of the range partitioning, inclusive.
	// +kubebuilder:validation:Optional
	Start *float64 `json:"start" tf:"start,omitempty"`
}

type RangePartitioningInitParameters struct {

	// The field used to determine how to create a range-based
	// partition.
	Field *string `json:"field,omitempty" tf:"field,omitempty"`

	// Information required to partition based on ranges.
	// Structure is documented below.
	Range *RangeInitParameters `json:"range,omitempty" tf:"range,omitempty"`
}

type RangePartitioningObservation struct {

	// The field used to determine how to create a range-based
	// partition.
	Field *string `json:"field,omitempty" tf:"field,omitempty"`

	// Information required to partition based on ranges.
	// Structure is documented below.
	Range *RangeObservation `json:"range,omitempty" tf:"range,omitempty"`
}

type RangePartitioningParameters struct {

	// The field used to determine how to create a range-based
	// partition.
	// +kubebuilder:validation:Optional
	Field *string `json:"field" tf:"field,omitempty"`

	// Information required to partition based on ranges.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Range *RangeParameters `json:"range" tf:"range,omitempty"`
}

type ReferencedTableInitParameters struct {

	// :  The ID of the project containing this table.
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// A unique ID for the resource.
	// Changing this forces a new resource to be created.
	TableID *string `json:"tableId,omitempty" tf:"table_id,omitempty"`
}

type ReferencedTableObservation struct {

	// :  The ID of the dataset containing this table.
	DatasetID *string `json:"datasetId,omitempty" tf:"dataset_id,omitempty"`

	// :  The ID of the project containing this table.
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// A unique ID for the resource.
	// Changing this forces a new resource to be created.
	TableID *string `json:"tableId,omitempty" tf:"table_id,omitempty"`
}

type ReferencedTableParameters struct {

	// :  The ID of the dataset containing this table.
	// +kubebuilder:validation:Required
	DatasetID *string `json:"datasetId" tf:"dataset_id,omitempty"`

	// :  The ID of the project containing this table.
	// +kubebuilder:validation:Optional
	ProjectID *string `json:"projectId" tf:"project_id,omitempty"`

	// A unique ID for the resource.
	// Changing this forces a new resource to be created.
	// +kubebuilder:validation:Optional
	TableID *string `json:"tableId" tf:"table_id,omitempty"`
}

type TableConstraintsInitParameters struct {

	// Present only if the table has a foreign key.
	// The foreign key is not enforced.
	// Structure is documented below.
	ForeignKeys []ForeignKeysInitParameters `json:"foreignKeys,omitempty" tf:"foreign_keys,omitempty"`

	// Represents the primary key constraint
	// on a table's columns. Present only if the table has a primary key.
	// The primary key is not enforced.
	// Structure is documented below.
	PrimaryKey *PrimaryKeyInitParameters `json:"primaryKey,omitempty" tf:"primary_key,omitempty"`
}

type TableConstraintsObservation struct {

	// Present only if the table has a foreign key.
	// The foreign key is not enforced.
	// Structure is documented below.
	ForeignKeys []ForeignKeysObservation `json:"foreignKeys,omitempty" tf:"foreign_keys,omitempty"`

	// Represents the primary key constraint
	// on a table's columns. Present only if the table has a primary key.
	// The primary key is not enforced.
	// Structure is documented below.
	PrimaryKey *PrimaryKeyObservation `json:"primaryKey,omitempty" tf:"primary_key,omitempty"`
}

type TableConstraintsParameters struct {

	// Present only if the table has a foreign key.
	// The foreign key is not enforced.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	ForeignKeys []ForeignKeysParameters `json:"foreignKeys,omitempty" tf:"foreign_keys,omitempty"`

	// Represents the primary key constraint
	// on a table's columns. Present only if the table has a primary key.
	// The primary key is not enforced.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	PrimaryKey *PrimaryKeyParameters `json:"primaryKey,omitempty" tf:"primary_key,omitempty"`
}

type TableInitParameters struct {

	// Specifies column names to use for data clustering.
	// Up to four top-level columns are allowed, and should be specified in
	// descending priority order.
	Clustering []*string `json:"clustering,omitempty" tf:"clustering,omitempty"`

	DeletionProtection *bool `json:"deletionProtection,omitempty" tf:"deletion_protection,omitempty"`

	// The field description.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Specifies how the table should be encrypted.
	// If left blank, the table will be encrypted with a Google-managed key; that process
	// is transparent to the user.  Structure is documented below.
	EncryptionConfiguration *EncryptionConfigurationInitParameters `json:"encryptionConfiguration,omitempty" tf:"encryption_configuration,omitempty"`

	// The time when this table expires, in
	// milliseconds since the epoch. If not present, the table will persist
	// indefinitely. Expired tables will be deleted and their storage
	// reclaimed.
	ExpirationTime *float64 `json:"expirationTime,omitempty" tf:"expiration_time,omitempty"`

	// Describes the data format,
	// location, and other properties of a table stored outside of BigQuery.
	// By defining these properties, the data source can then be queried as
	// if it were a standard BigQuery table. Structure is documented below.
	ExternalDataConfiguration *ExternalDataConfigurationInitParameters `json:"externalDataConfiguration,omitempty" tf:"external_data_configuration,omitempty"`

	// A descriptive name for the table.
	FriendlyName *string `json:"friendlyName,omitempty" tf:"friendly_name,omitempty"`

	// A mapping of labels to assign to the resource.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// If specified, configures this table as a materialized view.
	// Structure is documented below.
	MaterializedView *MaterializedViewInitParameters `json:"materializedView,omitempty" tf:"materialized_view,omitempty"`

	// :  The maximum staleness of data that could be
	// returned when the table (or stale MV) is queried. Staleness encoded as a
	// string encoding of SQL IntervalValue
	// type.
	MaxStaleness *string `json:"maxStaleness,omitempty" tf:"max_staleness,omitempty"`

	// If specified, configures range-based
	// partitioning for this table. Structure is documented below.
	RangePartitioning *RangePartitioningInitParameters `json:"rangePartitioning,omitempty" tf:"range_partitioning,omitempty"`

	// If set to true, queries over this table
	// require a partition filter that can be used for partition elimination to be
	// specified.
	RequirePartitionFilter *bool `json:"requirePartitionFilter,omitempty" tf:"require_partition_filter,omitempty"`

	// A JSON schema for the table.
	Schema *string `json:"schema,omitempty" tf:"schema,omitempty"`

	// Defines the primary key and foreign keys.
	// Structure is documented below.
	TableConstraints *TableConstraintsInitParameters `json:"tableConstraints,omitempty" tf:"table_constraints,omitempty"`

	TableReplicationInfo *TableReplicationInfoInitParameters `json:"tableReplicationInfo,omitempty" tf:"table_replication_info,omitempty"`

	// If specified, configures time-based
	// partitioning for this table. Structure is documented below.
	TimePartitioning *TableTimePartitioningInitParameters `json:"timePartitioning,omitempty" tf:"time_partitioning,omitempty"`

	// If specified, configures this table as a view.
	// Structure is documented below.
	View *TableViewInitParameters `json:"view,omitempty" tf:"view,omitempty"`
}

type TableObservation struct {

	// Specifies column names to use for data clustering.
	// Up to four top-level columns are allowed, and should be specified in
	// descending priority order.
	Clustering []*string `json:"clustering,omitempty" tf:"clustering,omitempty"`

	// The time when this table was created, in milliseconds since the epoch.
	CreationTime *float64 `json:"creationTime,omitempty" tf:"creation_time,omitempty"`

	// The dataset ID to create the table in.
	// Changing this forces a new resource to be created.
	DatasetID *string `json:"datasetId,omitempty" tf:"dataset_id,omitempty"`

	DeletionProtection *bool `json:"deletionProtection,omitempty" tf:"deletion_protection,omitempty"`

	// The field description.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +mapType=granular
	EffectiveLabels map[string]*string `json:"effectiveLabels,omitempty" tf:"effective_labels,omitempty"`

	// Specifies how the table should be encrypted.
	// If left blank, the table will be encrypted with a Google-managed key; that process
	// is transparent to the user.  Structure is documented below.
	EncryptionConfiguration *EncryptionConfigurationObservation `json:"encryptionConfiguration,omitempty" tf:"encryption_configuration,omitempty"`

	// A hash of the resource.
	Etag *string `json:"etag,omitempty" tf:"etag,omitempty"`

	// The time when this table expires, in
	// milliseconds since the epoch. If not present, the table will persist
	// indefinitely. Expired tables will be deleted and their storage
	// reclaimed.
	ExpirationTime *float64 `json:"expirationTime,omitempty" tf:"expiration_time,omitempty"`

	// Describes the data format,
	// location, and other properties of a table stored outside of BigQuery.
	// By defining these properties, the data source can then be queried as
	// if it were a standard BigQuery table. Structure is documented below.
	ExternalDataConfiguration *ExternalDataConfigurationObservation `json:"externalDataConfiguration,omitempty" tf:"external_data_configuration,omitempty"`

	// A descriptive name for the table.
	FriendlyName *string `json:"friendlyName,omitempty" tf:"friendly_name,omitempty"`

	// an identifier for the resource with format projects/{{project}}/datasets/{{dataset}}/tables/{{name}}
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// A mapping of labels to assign to the resource.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The time when this table was last modified, in milliseconds since the epoch.
	LastModifiedTime *float64 `json:"lastModifiedTime,omitempty" tf:"last_modified_time,omitempty"`

	// The geographic location where the table resides. This value is inherited from the dataset.
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// If specified, configures this table as a materialized view.
	// Structure is documented below.
	MaterializedView *MaterializedViewObservation `json:"materializedView,omitempty" tf:"materialized_view,omitempty"`

	// :  The maximum staleness of data that could be
	// returned when the table (or stale MV) is queried. Staleness encoded as a
	// string encoding of SQL IntervalValue
	// type.
	MaxStaleness *string `json:"maxStaleness,omitempty" tf:"max_staleness,omitempty"`

	// The size of this table in bytes, excluding any data in the streaming buffer.
	NumBytes *float64 `json:"numBytes,omitempty" tf:"num_bytes,omitempty"`

	// The number of bytes in the table that are considered "long-term storage".
	NumLongTermBytes *float64 `json:"numLongTermBytes,omitempty" tf:"num_long_term_bytes,omitempty"`

	// The number of rows of data in this table, excluding any data in the streaming buffer.
	NumRows *float64 `json:"numRows,omitempty" tf:"num_rows,omitempty"`

	// The ID of the project in which the resource belongs. If it
	// is not provided, the provider project is used.
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// If specified, configures range-based
	// partitioning for this table. Structure is documented below.
	RangePartitioning *RangePartitioningObservation `json:"rangePartitioning,omitempty" tf:"range_partitioning,omitempty"`

	// If set to true, queries over this table
	// require a partition filter that can be used for partition elimination to be
	// specified.
	RequirePartitionFilter *bool `json:"requirePartitionFilter,omitempty" tf:"require_partition_filter,omitempty"`

	// A JSON schema for the table.
	Schema *string `json:"schema,omitempty" tf:"schema,omitempty"`

	// The URI of the created resource.
	SelfLink *string `json:"selfLink,omitempty" tf:"self_link,omitempty"`

	// Defines the primary key and foreign keys.
	// Structure is documented below.
	TableConstraints *TableConstraintsObservation `json:"tableConstraints,omitempty" tf:"table_constraints,omitempty"`

	TableReplicationInfo *TableReplicationInfoObservation `json:"tableReplicationInfo,omitempty" tf:"table_replication_info,omitempty"`

	// The combination of labels configured directly on the resource and default labels configured on the provider.
	// +mapType=granular
	TerraformLabels map[string]*string `json:"terraformLabels,omitempty" tf:"terraform_labels,omitempty"`

	// If specified, configures time-based
	// partitioning for this table. Structure is documented below.
	TimePartitioning *TableTimePartitioningObservation `json:"timePartitioning,omitempty" tf:"time_partitioning,omitempty"`

	// Describes the table type.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// If specified, configures this table as a view.
	// Structure is documented below.
	View *TableViewObservation `json:"view,omitempty" tf:"view,omitempty"`
}

type TableParameters struct {

	// Specifies column names to use for data clustering.
	// Up to four top-level columns are allowed, and should be specified in
	// descending priority order.
	// +kubebuilder:validation:Optional
	Clustering []*string `json:"clustering,omitempty" tf:"clustering,omitempty"`

	// The dataset ID to create the table in.
	// Changing this forces a new resource to be created.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/bigquery/v1beta2.Dataset
	// +kubebuilder:validation:Optional
	DatasetID *string `json:"datasetId,omitempty" tf:"dataset_id,omitempty"`

	// Reference to a Dataset in bigquery to populate datasetId.
	// +kubebuilder:validation:Optional
	DatasetIDRef *v1.Reference `json:"datasetIdRef,omitempty" tf:"-"`

	// Selector for a Dataset in bigquery to populate datasetId.
	// +kubebuilder:validation:Optional
	DatasetIDSelector *v1.Selector `json:"datasetIdSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	DeletionProtection *bool `json:"deletionProtection,omitempty" tf:"deletion_protection,omitempty"`

	// The field description.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Specifies how the table should be encrypted.
	// If left blank, the table will be encrypted with a Google-managed key; that process
	// is transparent to the user.  Structure is documented below.
	// +kubebuilder:validation:Optional
	EncryptionConfiguration *EncryptionConfigurationParameters `json:"encryptionConfiguration,omitempty" tf:"encryption_configuration,omitempty"`

	// The time when this table expires, in
	// milliseconds since the epoch. If not present, the table will persist
	// indefinitely. Expired tables will be deleted and their storage
	// reclaimed.
	// +kubebuilder:validation:Optional
	ExpirationTime *float64 `json:"expirationTime,omitempty" tf:"expiration_time,omitempty"`

	// Describes the data format,
	// location, and other properties of a table stored outside of BigQuery.
	// By defining these properties, the data source can then be queried as
	// if it were a standard BigQuery table. Structure is documented below.
	// +kubebuilder:validation:Optional
	ExternalDataConfiguration *ExternalDataConfigurationParameters `json:"externalDataConfiguration,omitempty" tf:"external_data_configuration,omitempty"`

	// A descriptive name for the table.
	// +kubebuilder:validation:Optional
	FriendlyName *string `json:"friendlyName,omitempty" tf:"friendly_name,omitempty"`

	// A mapping of labels to assign to the resource.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// If specified, configures this table as a materialized view.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	MaterializedView *MaterializedViewParameters `json:"materializedView,omitempty" tf:"materialized_view,omitempty"`

	// :  The maximum staleness of data that could be
	// returned when the table (or stale MV) is queried. Staleness encoded as a
	// string encoding of SQL IntervalValue
	// type.
	// +kubebuilder:validation:Optional
	MaxStaleness *string `json:"maxStaleness,omitempty" tf:"max_staleness,omitempty"`

	// The ID of the project in which the resource belongs. If it
	// is not provided, the provider project is used.
	// +kubebuilder:validation:Optional
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// If specified, configures range-based
	// partitioning for this table. Structure is documented below.
	// +kubebuilder:validation:Optional
	RangePartitioning *RangePartitioningParameters `json:"rangePartitioning,omitempty" tf:"range_partitioning,omitempty"`

	// If set to true, queries over this table
	// require a partition filter that can be used for partition elimination to be
	// specified.
	// +kubebuilder:validation:Optional
	RequirePartitionFilter *bool `json:"requirePartitionFilter,omitempty" tf:"require_partition_filter,omitempty"`

	// A JSON schema for the table.
	// +kubebuilder:validation:Optional
	Schema *string `json:"schema,omitempty" tf:"schema,omitempty"`

	// Defines the primary key and foreign keys.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	TableConstraints *TableConstraintsParameters `json:"tableConstraints,omitempty" tf:"table_constraints,omitempty"`

	// +kubebuilder:validation:Optional
	TableReplicationInfo *TableReplicationInfoParameters `json:"tableReplicationInfo,omitempty" tf:"table_replication_info,omitempty"`

	// If specified, configures time-based
	// partitioning for this table. Structure is documented below.
	// +kubebuilder:validation:Optional
	TimePartitioning *TableTimePartitioningParameters `json:"timePartitioning,omitempty" tf:"time_partitioning,omitempty"`

	// If specified, configures this table as a view.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	View *TableViewParameters `json:"view,omitempty" tf:"view,omitempty"`
}

type TableReplicationInfoInitParameters struct {
	ReplicationIntervalMs *float64 `json:"replicationIntervalMs,omitempty" tf:"replication_interval_ms,omitempty"`

	// The dataset ID to create the table in.
	// Changing this forces a new resource to be created.
	SourceDatasetID *string `json:"sourceDatasetId,omitempty" tf:"source_dataset_id,omitempty"`

	// an identifier for the resource with format projects/{{project}}/datasets/{{dataset}}/tables/{{name}}
	SourceProjectID *string `json:"sourceProjectId,omitempty" tf:"source_project_id,omitempty"`

	// A unique ID for the resource.
	// Changing this forces a new resource to be created.
	SourceTableID *string `json:"sourceTableId,omitempty" tf:"source_table_id,omitempty"`
}

type TableReplicationInfoObservation struct {
	ReplicationIntervalMs *float64 `json:"replicationIntervalMs,omitempty" tf:"replication_interval_ms,omitempty"`

	// The dataset ID to create the table in.
	// Changing this forces a new resource to be created.
	SourceDatasetID *string `json:"sourceDatasetId,omitempty" tf:"source_dataset_id,omitempty"`

	// an identifier for the resource with format projects/{{project}}/datasets/{{dataset}}/tables/{{name}}
	SourceProjectID *string `json:"sourceProjectId,omitempty" tf:"source_project_id,omitempty"`

	// A unique ID for the resource.
	// Changing this forces a new resource to be created.
	SourceTableID *string `json:"sourceTableId,omitempty" tf:"source_table_id,omitempty"`
}

type TableReplicationInfoParameters struct {

	// +kubebuilder:validation:Optional
	ReplicationIntervalMs *float64 `json:"replicationIntervalMs,omitempty" tf:"replication_interval_ms,omitempty"`

	// The dataset ID to create the table in.
	// Changing this forces a new resource to be created.
	// +kubebuilder:validation:Optional
	SourceDatasetID *string `json:"sourceDatasetId" tf:"source_dataset_id,omitempty"`

	// an identifier for the resource with format projects/{{project}}/datasets/{{dataset}}/tables/{{name}}
	// +kubebuilder:validation:Optional
	SourceProjectID *string `json:"sourceProjectId" tf:"source_project_id,omitempty"`

	// A unique ID for the resource.
	// Changing this forces a new resource to be created.
	// +kubebuilder:validation:Optional
	SourceTableID *string `json:"sourceTableId" tf:"source_table_id,omitempty"`
}

type TableTimePartitioningInitParameters struct {

	// Number of milliseconds for which to keep the
	// storage for a partition.
	ExpirationMs *float64 `json:"expirationMs,omitempty" tf:"expiration_ms,omitempty"`

	// The field used to determine how to create a time-based
	// partition. If time-based partitioning is enabled without this value, the
	// table is partitioned based on the load time.
	Field *string `json:"field,omitempty" tf:"field,omitempty"`

	// If set to true, queries over this table
	// require a partition filter that can be used for partition elimination to be
	// specified. require_partition_filter is deprecated and will be removed in
	// a future major release. Use the top level field with the same name instead.
	RequirePartitionFilter *bool `json:"requirePartitionFilter,omitempty" tf:"require_partition_filter,omitempty"`

	// The supported types are DAY, HOUR, MONTH, and YEAR,
	// which will generate one partition per day, hour, month, and year, respectively.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type TableTimePartitioningObservation struct {

	// Number of milliseconds for which to keep the
	// storage for a partition.
	ExpirationMs *float64 `json:"expirationMs,omitempty" tf:"expiration_ms,omitempty"`

	// The field used to determine how to create a time-based
	// partition. If time-based partitioning is enabled without this value, the
	// table is partitioned based on the load time.
	Field *string `json:"field,omitempty" tf:"field,omitempty"`

	// If set to true, queries over this table
	// require a partition filter that can be used for partition elimination to be
	// specified. require_partition_filter is deprecated and will be removed in
	// a future major release. Use the top level field with the same name instead.
	RequirePartitionFilter *bool `json:"requirePartitionFilter,omitempty" tf:"require_partition_filter,omitempty"`

	// The supported types are DAY, HOUR, MONTH, and YEAR,
	// which will generate one partition per day, hour, month, and year, respectively.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type TableTimePartitioningParameters struct {

	// Number of milliseconds for which to keep the
	// storage for a partition.
	// +kubebuilder:validation:Optional
	ExpirationMs *float64 `json:"expirationMs,omitempty" tf:"expiration_ms,omitempty"`

	// The field used to determine how to create a time-based
	// partition. If time-based partitioning is enabled without this value, the
	// table is partitioned based on the load time.
	// +kubebuilder:validation:Optional
	Field *string `json:"field,omitempty" tf:"field,omitempty"`

	// If set to true, queries over this table
	// require a partition filter that can be used for partition elimination to be
	// specified. require_partition_filter is deprecated and will be removed in
	// a future major release. Use the top level field with the same name instead.
	// +kubebuilder:validation:Optional
	RequirePartitionFilter *bool `json:"requirePartitionFilter,omitempty" tf:"require_partition_filter,omitempty"`

	// The supported types are DAY, HOUR, MONTH, and YEAR,
	// which will generate one partition per day, hour, month, and year, respectively.
	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`
}

type TableViewInitParameters struct {

	// A query that BigQuery executes when the view is referenced.
	Query *string `json:"query,omitempty" tf:"query,omitempty"`

	// Specifies whether to use BigQuery's legacy SQL for this view.
	// The default value is true. If set to false, the view will use BigQuery's standard SQL.
	UseLegacySQL *bool `json:"useLegacySql,omitempty" tf:"use_legacy_sql,omitempty"`
}

type TableViewObservation struct {

	// A query that BigQuery executes when the view is referenced.
	Query *string `json:"query,omitempty" tf:"query,omitempty"`

	// Specifies whether to use BigQuery's legacy SQL for this view.
	// The default value is true. If set to false, the view will use BigQuery's standard SQL.
	UseLegacySQL *bool `json:"useLegacySql,omitempty" tf:"use_legacy_sql,omitempty"`
}

type TableViewParameters struct {

	// A query that BigQuery executes when the view is referenced.
	// +kubebuilder:validation:Optional
	Query *string `json:"query" tf:"query,omitempty"`

	// Specifies whether to use BigQuery's legacy SQL for this view.
	// The default value is true. If set to false, the view will use BigQuery's standard SQL.
	// +kubebuilder:validation:Optional
	UseLegacySQL *bool `json:"useLegacySql,omitempty" tf:"use_legacy_sql,omitempty"`
}

// TableSpec defines the desired state of Table
type TableSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     TableParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider TableInitParameters `json:"initProvider,omitempty"`
}

// TableStatus defines the observed state of Table.
type TableStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        TableObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status

// Table is the Schema for the Tables API. Creates a table resource in a dataset for Google BigQuery.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcp}
type Table struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              TableSpec   `json:"spec"`
	Status            TableStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// TableList contains a list of Tables
type TableList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Table `json:"items"`
}

// Repository type metadata.
var (
	Table_Kind             = "Table"
	Table_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Table_Kind}.String()
	Table_KindAPIVersion   = Table_Kind + "." + CRDGroupVersion.String()
	Table_GroupVersionKind = CRDGroupVersion.WithKind(Table_Kind)
)

func init() {
	SchemeBuilder.Register(&Table{}, &TableList{})
}
