// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1beta2

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AvroOptionsInitParameters struct {

	// If is set to true, indicates whether
	// to interpret logical types as the corresponding BigQuery data type
	// (for example, TIMESTAMP), instead of using the raw type (for example, INTEGER).
	UseAvroLogicalTypes *bool `json:"useAvroLogicalTypes,omitempty" tf:"use_avro_logical_types,omitempty"`
}

type AvroOptionsObservation struct {

	// If is set to true, indicates whether
	// to interpret logical types as the corresponding BigQuery data type
	// (for example, TIMESTAMP), instead of using the raw type (for example, INTEGER).
	UseAvroLogicalTypes *bool `json:"useAvroLogicalTypes,omitempty" tf:"use_avro_logical_types,omitempty"`
}

type AvroOptionsParameters struct {

	// If is set to true, indicates whether
	// to interpret logical types as the corresponding BigQuery data type
	// (for example, TIMESTAMP), instead of using the raw type (for example, INTEGER).
	// +kubebuilder:validation:Optional
	UseAvroLogicalTypes *bool `json:"useAvroLogicalTypes" tf:"use_avro_logical_types,omitempty"`
}

type BiglakeConfigurationInitParameters struct {

	// The connection specifying the credentials to be used to
	// read and write to external storage, such as Cloud Storage. The connection_id can
	// have the form "<project_id>.<location_id>.<connection_id>" or
	// projects/<project_id>/locations/<location_id>/connections/<connection_id>".
	ConnectionID *string `json:"connectionId,omitempty" tf:"connection_id,omitempty"`

	// The file format the table data is stored in.
	FileFormat *string `json:"fileFormat,omitempty" tf:"file_format,omitempty"`

	// The fully qualified location prefix of the external folder where table data
	// is stored. The '*' wildcard character is not allowed. The URI should be in the format "gs://bucket/path_to_table/"
	StorageURI *string `json:"storageUri,omitempty" tf:"storage_uri,omitempty"`

	// The table format the metadata only snapshots are stored in.
	TableFormat *string `json:"tableFormat,omitempty" tf:"table_format,omitempty"`
}

type BiglakeConfigurationObservation struct {

	// The connection specifying the credentials to be used to
	// read and write to external storage, such as Cloud Storage. The connection_id can
	// have the form "<project_id>.<location_id>.<connection_id>" or
	// projects/<project_id>/locations/<location_id>/connections/<connection_id>".
	ConnectionID *string `json:"connectionId,omitempty" tf:"connection_id,omitempty"`

	// The file format the table data is stored in.
	FileFormat *string `json:"fileFormat,omitempty" tf:"file_format,omitempty"`

	// The fully qualified location prefix of the external folder where table data
	// is stored. The '*' wildcard character is not allowed. The URI should be in the format "gs://bucket/path_to_table/"
	StorageURI *string `json:"storageUri,omitempty" tf:"storage_uri,omitempty"`

	// The table format the metadata only snapshots are stored in.
	TableFormat *string `json:"tableFormat,omitempty" tf:"table_format,omitempty"`
}

type BiglakeConfigurationParameters struct {

	// The connection specifying the credentials to be used to
	// read and write to external storage, such as Cloud Storage. The connection_id can
	// have the form "<project_id>.<location_id>.<connection_id>" or
	// projects/<project_id>/locations/<location_id>/connections/<connection_id>".
	// +kubebuilder:validation:Optional
	ConnectionID *string `json:"connectionId" tf:"connection_id,omitempty"`

	// The file format the table data is stored in.
	// +kubebuilder:validation:Optional
	FileFormat *string `json:"fileFormat" tf:"file_format,omitempty"`

	// The fully qualified location prefix of the external folder where table data
	// is stored. The '*' wildcard character is not allowed. The URI should be in the format "gs://bucket/path_to_table/"
	// +kubebuilder:validation:Optional
	StorageURI *string `json:"storageUri" tf:"storage_uri,omitempty"`

	// The table format the metadata only snapshots are stored in.
	// +kubebuilder:validation:Optional
	TableFormat *string `json:"tableFormat" tf:"table_format,omitempty"`
}

type BigtableOptionsInitParameters struct {

	// A list of column families to expose in the table schema along with their types. This list restricts the column families that can be referenced in queries and specifies their value types. You can use this list to do type conversions - see the 'type' field for more details. If you leave this list empty, all column families are present in the table schema and their values are read as BYTES. During a query only the column families referenced in that query are read from Bigtable.  Structure is documented below.
	ColumnFamily []ColumnFamilyInitParameters `json:"columnFamily,omitempty" tf:"column_family,omitempty"`

	// If field is true, then the column families that are not specified in columnFamilies list are not exposed in the table schema. Otherwise, they are read with BYTES type values. The default value is false.
	IgnoreUnspecifiedColumnFamilies *bool `json:"ignoreUnspecifiedColumnFamilies,omitempty" tf:"ignore_unspecified_column_families,omitempty"`

	// If field is true, then each column family will be read as a single JSON column. Otherwise they are read as a repeated cell structure containing timestamp/value tuples. The default value is false.
	OutputColumnFamiliesAsJSON *bool `json:"outputColumnFamiliesAsJson,omitempty" tf:"output_column_families_as_json,omitempty"`

	// If field is true, then the rowkey column families will be read and converted to string. Otherwise they are read with BYTES type values and users need to manually cast them with CAST if necessary. The default value is false.
	ReadRowkeyAsString *bool `json:"readRowkeyAsString,omitempty" tf:"read_rowkey_as_string,omitempty"`
}

type BigtableOptionsObservation struct {

	// A list of column families to expose in the table schema along with their types. This list restricts the column families that can be referenced in queries and specifies their value types. You can use this list to do type conversions - see the 'type' field for more details. If you leave this list empty, all column families are present in the table schema and their values are read as BYTES. During a query only the column families referenced in that query are read from Bigtable.  Structure is documented below.
	ColumnFamily []ColumnFamilyObservation `json:"columnFamily,omitempty" tf:"column_family,omitempty"`

	// If field is true, then the column families that are not specified in columnFamilies list are not exposed in the table schema. Otherwise, they are read with BYTES type values. The default value is false.
	IgnoreUnspecifiedColumnFamilies *bool `json:"ignoreUnspecifiedColumnFamilies,omitempty" tf:"ignore_unspecified_column_families,omitempty"`

	// If field is true, then each column family will be read as a single JSON column. Otherwise they are read as a repeated cell structure containing timestamp/value tuples. The default value is false.
	OutputColumnFamiliesAsJSON *bool `json:"outputColumnFamiliesAsJson,omitempty" tf:"output_column_families_as_json,omitempty"`

	// If field is true, then the rowkey column families will be read and converted to string. Otherwise they are read with BYTES type values and users need to manually cast them with CAST if necessary. The default value is false.
	ReadRowkeyAsString *bool `json:"readRowkeyAsString,omitempty" tf:"read_rowkey_as_string,omitempty"`
}

type BigtableOptionsParameters struct {

	// A list of column families to expose in the table schema along with their types. This list restricts the column families that can be referenced in queries and specifies their value types. You can use this list to do type conversions - see the 'type' field for more details. If you leave this list empty, all column families are present in the table schema and their values are read as BYTES. During a query only the column families referenced in that query are read from Bigtable.  Structure is documented below.
	// +kubebuilder:validation:Optional
	ColumnFamily []ColumnFamilyParameters `json:"columnFamily,omitempty" tf:"column_family,omitempty"`

	// If field is true, then the column families that are not specified in columnFamilies list are not exposed in the table schema. Otherwise, they are read with BYTES type values. The default value is false.
	// +kubebuilder:validation:Optional
	IgnoreUnspecifiedColumnFamilies *bool `json:"ignoreUnspecifiedColumnFamilies,omitempty" tf:"ignore_unspecified_column_families,omitempty"`

	// If field is true, then each column family will be read as a single JSON column. Otherwise they are read as a repeated cell structure containing timestamp/value tuples. The default value is false.
	// +kubebuilder:validation:Optional
	OutputColumnFamiliesAsJSON *bool `json:"outputColumnFamiliesAsJson,omitempty" tf:"output_column_families_as_json,omitempty"`

	// If field is true, then the rowkey column families will be read and converted to string. Otherwise they are read with BYTES type values and users need to manually cast them with CAST if necessary. The default value is false.
	// +kubebuilder:validation:Optional
	ReadRowkeyAsString *bool `json:"readRowkeyAsString,omitempty" tf:"read_rowkey_as_string,omitempty"`
}

type ColumnFamilyInitParameters struct {

	// A List of columns that should be exposed as individual fields as opposed to a list of (column name, value) pairs. All columns whose qualifier matches a qualifier in this list can be accessed as Other columns can be accessed as a list through column field.  Structure is documented below.
	Column []ColumnInitParameters `json:"column,omitempty" tf:"column,omitempty"`

	// The character encoding of the data. The supported values are UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE. The default value is UTF-8.
	Encoding *string `json:"encoding,omitempty" tf:"encoding,omitempty"`

	// Identifier of the column family.
	FamilyID *string `json:"familyId,omitempty" tf:"family_id,omitempty"`

	// If this is set only the latest version of value are exposed for all columns in this column family. This can be overridden for a specific column by listing that column in 'columns' and specifying a different setting for that column.
	OnlyReadLatest *bool `json:"onlyReadLatest,omitempty" tf:"only_read_latest,omitempty"`

	// Describes the table type.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ColumnFamilyObservation struct {

	// A List of columns that should be exposed as individual fields as opposed to a list of (column name, value) pairs. All columns whose qualifier matches a qualifier in this list can be accessed as Other columns can be accessed as a list through column field.  Structure is documented below.
	Column []ColumnObservation `json:"column,omitempty" tf:"column,omitempty"`

	// The character encoding of the data. The supported values are UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE. The default value is UTF-8.
	Encoding *string `json:"encoding,omitempty" tf:"encoding,omitempty"`

	// Identifier of the column family.
	FamilyID *string `json:"familyId,omitempty" tf:"family_id,omitempty"`

	// If this is set only the latest version of value are exposed for all columns in this column family. This can be overridden for a specific column by listing that column in 'columns' and specifying a different setting for that column.
	OnlyReadLatest *bool `json:"onlyReadLatest,omitempty" tf:"only_read_latest,omitempty"`

	// Describes the table type.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ColumnFamilyParameters struct {

	// A List of columns that should be exposed as individual fields as opposed to a list of (column name, value) pairs. All columns whose qualifier matches a qualifier in this list can be accessed as Other columns can be accessed as a list through column field.  Structure is documented below.
	// +kubebuilder:validation:Optional
	Column []ColumnParameters `json:"column,omitempty" tf:"column,omitempty"`

	// The character encoding of the data. The supported values are UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE. The default value is UTF-8.
	// +kubebuilder:validation:Optional
	Encoding *string `json:"encoding,omitempty" tf:"encoding,omitempty"`

	// Identifier of the column family.
	// +kubebuilder:validation:Optional
	FamilyID *string `json:"familyId,omitempty" tf:"family_id,omitempty"`

	// If this is set only the latest version of value are exposed for all columns in this column family. This can be overridden for a specific column by listing that column in 'columns' and specifying a different setting for that column.
	// +kubebuilder:validation:Optional
	OnlyReadLatest *bool `json:"onlyReadLatest,omitempty" tf:"only_read_latest,omitempty"`

	// Describes the table type.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ColumnInitParameters struct {

	// The character encoding of the data. The supported values are UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE. The default value is UTF-8.
	Encoding *string `json:"encoding,omitempty" tf:"encoding,omitempty"`

	// If the qualifier is not a valid BigQuery field identifier i.e. does not match [a-zA-Z][a-zA-Z0-9_]*, a valid identifier must be provided as the column field name and is used as field name in queries.
	FieldName *string `json:"fieldName,omitempty" tf:"field_name,omitempty"`

	// If this is set only the latest version of value are exposed for all columns in this column family. This can be overridden for a specific column by listing that column in 'columns' and specifying a different setting for that column.
	OnlyReadLatest *bool `json:"onlyReadLatest,omitempty" tf:"only_read_latest,omitempty"`

	// Qualifier of the column. Columns in the parent column family that has this exact qualifier are exposed as . field. If the qualifier is valid UTF-8 string, it can be specified in the qualifierString field. Otherwise, a base-64 encoded value must be set to qualifierEncoded. The column field name is the same as the column qualifier. However, if the qualifier is not a valid BigQuery field identifier i.e. does not match [a-zA-Z][a-zA-Z0-9_]*, a valid identifier must be provided as fieldName.
	QualifierEncoded *string `json:"qualifierEncoded,omitempty" tf:"qualifier_encoded,omitempty"`

	// Qualifier string.
	QualifierString *string `json:"qualifierString,omitempty" tf:"qualifier_string,omitempty"`

	// Describes the table type.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ColumnObservation struct {

	// The character encoding of the data. The supported values are UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE. The default value is UTF-8.
	Encoding *string `json:"encoding,omitempty" tf:"encoding,omitempty"`

	// If the qualifier is not a valid BigQuery field identifier i.e. does not match [a-zA-Z][a-zA-Z0-9_]*, a valid identifier must be provided as the column field name and is used as field name in queries.
	FieldName *string `json:"fieldName,omitempty" tf:"field_name,omitempty"`

	// If this is set only the latest version of value are exposed for all columns in this column family. This can be overridden for a specific column by listing that column in 'columns' and specifying a different setting for that column.
	OnlyReadLatest *bool `json:"onlyReadLatest,omitempty" tf:"only_read_latest,omitempty"`

	// Qualifier of the column. Columns in the parent column family that has this exact qualifier are exposed as . field. If the qualifier is valid UTF-8 string, it can be specified in the qualifierString field. Otherwise, a base-64 encoded value must be set to qualifierEncoded. The column field name is the same as the column qualifier. However, if the qualifier is not a valid BigQuery field identifier i.e. does not match [a-zA-Z][a-zA-Z0-9_]*, a valid identifier must be provided as fieldName.
	QualifierEncoded *string `json:"qualifierEncoded,omitempty" tf:"qualifier_encoded,omitempty"`

	// Qualifier string.
	QualifierString *string `json:"qualifierString,omitempty" tf:"qualifier_string,omitempty"`

	// Describes the table type.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ColumnParameters struct {

	// The character encoding of the data. The supported values are UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE. The default value is UTF-8.
	// +kubebuilder:validation:Optional
	Encoding *string `json:"encoding,omitempty" tf:"encoding,omitempty"`

	// If the qualifier is not a valid BigQuery field identifier i.e. does not match [a-zA-Z][a-zA-Z0-9_]*, a valid identifier must be provided as the column field name and is used as field name in queries.
	// +kubebuilder:validation:Optional
	FieldName *string `json:"fieldName,omitempty" tf:"field_name,omitempty"`

	// If this is set only the latest version of value are exposed for all columns in this column family. This can be overridden for a specific column by listing that column in 'columns' and specifying a different setting for that column.
	// +kubebuilder:validation:Optional
	OnlyReadLatest *bool `json:"onlyReadLatest,omitempty" tf:"only_read_latest,omitempty"`

	// Qualifier of the column. Columns in the parent column family that has this exact qualifier are exposed as . field. If the qualifier is valid UTF-8 string, it can be specified in the qualifierString field. Otherwise, a base-64 encoded value must be set to qualifierEncoded. The column field name is the same as the column qualifier. However, if the qualifier is not a valid BigQuery field identifier i.e. does not match [a-zA-Z][a-zA-Z0-9_]*, a valid identifier must be provided as fieldName.
	// +kubebuilder:validation:Optional
	QualifierEncoded *string `json:"qualifierEncoded,omitempty" tf:"qualifier_encoded,omitempty"`

	// Qualifier string.
	// +kubebuilder:validation:Optional
	QualifierString *string `json:"qualifierString,omitempty" tf:"qualifier_string,omitempty"`

	// Describes the table type.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ColumnReferencesInitParameters struct {

	// The column in the primary key that are
	// referenced by the referencingColumn
	ReferencedColumn *string `json:"referencedColumn,omitempty" tf:"referenced_column,omitempty"`

	// The column that composes the foreign key.
	ReferencingColumn *string `json:"referencingColumn,omitempty" tf:"referencing_column,omitempty"`
}

type ColumnReferencesObservation struct {

	// The column in the primary key that are
	// referenced by the referencingColumn
	ReferencedColumn *string `json:"referencedColumn,omitempty" tf:"referenced_column,omitempty"`

	// The column that composes the foreign key.
	ReferencingColumn *string `json:"referencingColumn,omitempty" tf:"referencing_column,omitempty"`
}

type ColumnReferencesParameters struct {

	// The column in the primary key that are
	// referenced by the referencingColumn
	// +kubebuilder:validation:Optional
	ReferencedColumn *string `json:"referencedColumn" tf:"referenced_column,omitempty"`

	// The column that composes the foreign key.
	// +kubebuilder:validation:Optional
	ReferencingColumn *string `json:"referencingColumn" tf:"referencing_column,omitempty"`
}

type CsvOptionsInitParameters struct {

	// Indicates if BigQuery should accept rows
	// that are missing trailing optional columns.
	AllowJaggedRows *bool `json:"allowJaggedRows,omitempty" tf:"allow_jagged_rows,omitempty"`

	// Indicates if BigQuery should allow
	// quoted data sections that contain newline characters in a CSV file.
	// The default value is false.
	AllowQuotedNewlines *bool `json:"allowQuotedNewlines,omitempty" tf:"allow_quoted_newlines,omitempty"`

	// The character encoding of the data. The supported values are UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE. The default value is UTF-8.
	Encoding *string `json:"encoding,omitempty" tf:"encoding,omitempty"`

	// The separator for fields in a CSV file.
	FieldDelimiter *string `json:"fieldDelimiter,omitempty" tf:"field_delimiter,omitempty"`

	// The value that is used to quote data sections in a
	// CSV file. If your data does not contain quoted sections, set the
	// property value to an empty string. If your data contains quoted newline
	// characters, you must also set the allow_quoted_newlines property to true.
	Quote *string `json:"quote,omitempty" tf:"quote,omitempty"`

	// The number of rows at the top of the sheet
	// that BigQuery will skip when reading the data. At least one of range or
	// skip_leading_rows must be set.
	SkipLeadingRows *float64 `json:"skipLeadingRows,omitempty" tf:"skip_leading_rows,omitempty"`
}

type CsvOptionsObservation struct {

	// Indicates if BigQuery should accept rows
	// that are missing trailing optional columns.
	AllowJaggedRows *bool `json:"allowJaggedRows,omitempty" tf:"allow_jagged_rows,omitempty"`

	// Indicates if BigQuery should allow
	// quoted data sections that contain newline characters in a CSV file.
	// The default value is false.
	AllowQuotedNewlines *bool `json:"allowQuotedNewlines,omitempty" tf:"allow_quoted_newlines,omitempty"`

	// The character encoding of the data. The supported values are UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE. The default value is UTF-8.
	Encoding *string `json:"encoding,omitempty" tf:"encoding,omitempty"`

	// The separator for fields in a CSV file.
	FieldDelimiter *string `json:"fieldDelimiter,omitempty" tf:"field_delimiter,omitempty"`

	// The value that is used to quote data sections in a
	// CSV file. If your data does not contain quoted sections, set the
	// property value to an empty string. If your data contains quoted newline
	// characters, you must also set the allow_quoted_newlines property to true.
	Quote *string `json:"quote,omitempty" tf:"quote,omitempty"`

	// The number of rows at the top of the sheet
	// that BigQuery will skip when reading the data. At least one of range or
	// skip_leading_rows must be set.
	SkipLeadingRows *float64 `json:"skipLeadingRows,omitempty" tf:"skip_leading_rows,omitempty"`
}

type CsvOptionsParameters struct {

	// Indicates if BigQuery should accept rows
	// that are missing trailing optional columns.
	// +kubebuilder:validation:Optional
	AllowJaggedRows *bool `json:"allowJaggedRows,omitempty" tf:"allow_jagged_rows,omitempty"`

	// Indicates if BigQuery should allow
	// quoted data sections that contain newline characters in a CSV file.
	// The default value is false.
	// +kubebuilder:validation:Optional
	AllowQuotedNewlines *bool `json:"allowQuotedNewlines,omitempty" tf:"allow_quoted_newlines,omitempty"`

	// The character encoding of the data. The supported values are UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE. The default value is UTF-8.
	// +kubebuilder:validation:Optional
	Encoding *string `json:"encoding,omitempty" tf:"encoding,omitempty"`

	// The separator for fields in a CSV file.
	// +kubebuilder:validation:Optional
	FieldDelimiter *string `json:"fieldDelimiter,omitempty" tf:"field_delimiter,omitempty"`

	// The value that is used to quote data sections in a
	// CSV file. If your data does not contain quoted sections, set the
	// property value to an empty string. If your data contains quoted newline
	// characters, you must also set the allow_quoted_newlines property to true.
	// +kubebuilder:validation:Optional
	Quote *string `json:"quote" tf:"quote,omitempty"`

	// The number of rows at the top of the sheet
	// that BigQuery will skip when reading the data. At least one of range or
	// skip_leading_rows must be set.
	// +kubebuilder:validation:Optional
	SkipLeadingRows *float64 `json:"skipLeadingRows,omitempty" tf:"skip_leading_rows,omitempty"`
}

type ExternalCatalogTableOptionsInitParameters struct {

	// The connection specifying the credentials to be
	// used to read external storage, such as Azure Blob, Cloud Storage, or S3. The
	// connection is needed to read the open source table from BigQuery Engine. The
	// connection_id can have the form <project_id>.<location_id>.<connection_id>
	// or projects/<project_id>/locations/<location_id>/connections/<connection_id>.
	ConnectionID *string `json:"connectionId,omitempty" tf:"connection_id,omitempty"`

	// A map of key value pairs defining the parameters and
	// properties of the open source table. Corresponds with hive meta store table
	// parameters. Maximum size of 4Mib.
	// +mapType=granular
	Parameters map[string]*string `json:"parameters,omitempty" tf:"parameters,omitempty"`

	// A storage descriptor containing information
	// about the physical storage of this table. Structure is documented below.
	StorageDescriptor *StorageDescriptorInitParameters `json:"storageDescriptor,omitempty" tf:"storage_descriptor,omitempty"`
}

type ExternalCatalogTableOptionsObservation struct {

	// The connection specifying the credentials to be
	// used to read external storage, such as Azure Blob, Cloud Storage, or S3. The
	// connection is needed to read the open source table from BigQuery Engine. The
	// connection_id can have the form <project_id>.<location_id>.<connection_id>
	// or projects/<project_id>/locations/<location_id>/connections/<connection_id>.
	ConnectionID *string `json:"connectionId,omitempty" tf:"connection_id,omitempty"`

	// A map of key value pairs defining the parameters and
	// properties of the open source table. Corresponds with hive meta store table
	// parameters. Maximum size of 4Mib.
	// +mapType=granular
	Parameters map[string]*string `json:"parameters,omitempty" tf:"parameters,omitempty"`

	// A storage descriptor containing information
	// about the physical storage of this table. Structure is documented below.
	StorageDescriptor *StorageDescriptorObservation `json:"storageDescriptor,omitempty" tf:"storage_descriptor,omitempty"`
}

type ExternalCatalogTableOptionsParameters struct {

	// The connection specifying the credentials to be
	// used to read external storage, such as Azure Blob, Cloud Storage, or S3. The
	// connection is needed to read the open source table from BigQuery Engine. The
	// connection_id can have the form <project_id>.<location_id>.<connection_id>
	// or projects/<project_id>/locations/<location_id>/connections/<connection_id>.
	// +kubebuilder:validation:Optional
	ConnectionID *string `json:"connectionId,omitempty" tf:"connection_id,omitempty"`

	// A map of key value pairs defining the parameters and
	// properties of the open source table. Corresponds with hive meta store table
	// parameters. Maximum size of 4Mib.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Parameters map[string]*string `json:"parameters,omitempty" tf:"parameters,omitempty"`

	// A storage descriptor containing information
	// about the physical storage of this table. Structure is documented below.
	// +kubebuilder:validation:Optional
	StorageDescriptor *StorageDescriptorParameters `json:"storageDescriptor,omitempty" tf:"storage_descriptor,omitempty"`
}

type ExternalDataConfigurationInitParameters struct {

	// Let BigQuery try to autodetect the schema
	// and format of the table.
	Autodetect *bool `json:"autodetect,omitempty" tf:"autodetect,omitempty"`

	// Additional options if source_format is set to
	// "AVRO".  Structure is documented below.
	AvroOptions *AvroOptionsInitParameters `json:"avroOptions,omitempty" tf:"avro_options,omitempty"`

	// Additional properties to set if
	// source_format is set to "BIGTABLE". Structure is documented below.
	BigtableOptions *BigtableOptionsInitParameters `json:"bigtableOptions,omitempty" tf:"bigtable_options,omitempty"`

	// The compression type of the data source.
	// Valid values are "NONE" or "GZIP".
	Compression *string `json:"compression,omitempty" tf:"compression,omitempty"`

	// The connection specifying the credentials to be used to read
	// external storage, such as Azure Blob, Cloud Storage, or S3. The connection_id can have
	// the form {{project}}.{{location}}.{{connection_id}}
	// or projects/{{project}}/locations/{{location}}/connections/{{connection_id}}.
	ConnectionID *string `json:"connectionId,omitempty" tf:"connection_id,omitempty"`

	// Additional properties to set if
	// source_format is set to "CSV". Structure is documented below.
	CsvOptions *CsvOptionsInitParameters `json:"csvOptions,omitempty" tf:"csv_options,omitempty"`

	// Specifies how source URIs are interpreted for constructing the file set to load.
	// By default source URIs are expanded against the underlying storage.
	// Other options include specifying manifest files. Only applicable to object storage systems. Docs
	FileSetSpecType *string `json:"fileSetSpecType,omitempty" tf:"file_set_spec_type,omitempty"`

	// Additional options if
	// source_format is set to "GOOGLE_SHEETS". Structure is
	// documented below.
	GoogleSheetsOptions *GoogleSheetsOptionsInitParameters `json:"googleSheetsOptions,omitempty" tf:"google_sheets_options,omitempty"`

	// When set, configures hive partitioning
	// support. Not all storage formats support hive partitioning -- requesting hive
	// partitioning on an unsupported format will lead to an error, as will providing
	// an invalid specification. Structure is documented below.
	HivePartitioningOptions *HivePartitioningOptionsInitParameters `json:"hivePartitioningOptions,omitempty" tf:"hive_partitioning_options,omitempty"`

	// Indicates if BigQuery should
	// allow extra values that are not represented in the table schema.
	// If true, the extra values are ignored. If false, records with
	// extra columns are treated as bad records, and if there are too
	// many bad records, an invalid error is returned in the job result.
	// The default value is false.
	IgnoreUnknownValues *bool `json:"ignoreUnknownValues,omitempty" tf:"ignore_unknown_values,omitempty"`

	// Used to indicate that a JSON variant, rather than normal JSON, is being used as the sourceFormat. This should only be used in combination with the JSON source format. Valid values are: GEOJSON.
	JSONExtension *string `json:"jsonExtension,omitempty" tf:"json_extension,omitempty"`

	// Additional properties to set if
	// source_format is set to "JSON". Structure is documented below.
	JSONOptions *JSONOptionsInitParameters `json:"jsonOptions,omitempty" tf:"json_options,omitempty"`

	// The maximum number of bad records that
	// BigQuery can ignore when reading data.
	MaxBadRecords *float64 `json:"maxBadRecords,omitempty" tf:"max_bad_records,omitempty"`

	// Metadata Cache Mode for the table. Set this to enable caching of metadata from external data source. Valid values are AUTOMATIC and MANUAL.
	MetadataCacheMode *string `json:"metadataCacheMode,omitempty" tf:"metadata_cache_mode,omitempty"`

	// Object Metadata is used to create Object Tables. Object Tables contain a listing of objects (with their metadata) found at the sourceUris. If object_metadata is set, source_format should be omitted.
	ObjectMetadata *string `json:"objectMetadata,omitempty" tf:"object_metadata,omitempty"`

	// Additional properties to set if
	// source_format is set to "PARQUET". Structure is documented below.
	ParquetOptions *ExternalDataConfigurationParquetOptionsInitParameters `json:"parquetOptions,omitempty" tf:"parquet_options,omitempty"`

	// When creating an external table, the user can provide a reference file with the table schema. This is enabled for the following formats: AVRO, PARQUET, ORC.
	ReferenceFileSchemaURI *string `json:"referenceFileSchemaUri,omitempty" tf:"reference_file_schema_uri,omitempty"`

	// A JSON schema for the external table. Schema is required
	// for CSV and JSON formats if autodetect is not on. Schema is disallowed
	// for Google Cloud Bigtable, Cloud Datastore backups, Avro, Iceberg, ORC and Parquet formats.
	// ~>NOTE: Because this field expects a JSON string, any changes to the
	// string will create a diff, even if the JSON itself hasn't changed.
	// Furthermore drift for this field cannot not be detected because BigQuery
	// only uses this schema to compute the effective schema for the table, therefore
	// any changes on the configured value will force the table to be recreated.
	// This schema is effectively only applied when creating a table from an external
	// datasource, after creation the computed schema will be stored in
	// google_bigquery_table.schema
	Schema *string `json:"schema,omitempty" tf:"schema,omitempty"`

	// The data format. Please see sourceFormat under
	// ExternalDataConfiguration
	// in Bigquery's public API documentation for supported formats. To use "GOOGLE_SHEETS"
	// the scopes must include "https://www.googleapis.com/auth/drive.readonly".
	SourceFormat *string `json:"sourceFormat,omitempty" tf:"source_format,omitempty"`

	// A list of the fully-qualified URIs that point to
	// your data in Google Cloud.
	SourceUris []*string `json:"sourceUris,omitempty" tf:"source_uris,omitempty"`
}

type ExternalDataConfigurationObservation struct {

	// Let BigQuery try to autodetect the schema
	// and format of the table.
	Autodetect *bool `json:"autodetect,omitempty" tf:"autodetect,omitempty"`

	// Additional options if source_format is set to
	// "AVRO".  Structure is documented below.
	AvroOptions *AvroOptionsObservation `json:"avroOptions,omitempty" tf:"avro_options,omitempty"`

	// Additional properties to set if
	// source_format is set to "BIGTABLE". Structure is documented below.
	BigtableOptions *BigtableOptionsObservation `json:"bigtableOptions,omitempty" tf:"bigtable_options,omitempty"`

	// The compression type of the data source.
	// Valid values are "NONE" or "GZIP".
	Compression *string `json:"compression,omitempty" tf:"compression,omitempty"`

	// The connection specifying the credentials to be used to read
	// external storage, such as Azure Blob, Cloud Storage, or S3. The connection_id can have
	// the form {{project}}.{{location}}.{{connection_id}}
	// or projects/{{project}}/locations/{{location}}/connections/{{connection_id}}.
	ConnectionID *string `json:"connectionId,omitempty" tf:"connection_id,omitempty"`

	// Additional properties to set if
	// source_format is set to "CSV". Structure is documented below.
	CsvOptions *CsvOptionsObservation `json:"csvOptions,omitempty" tf:"csv_options,omitempty"`

	// Specifies how source URIs are interpreted for constructing the file set to load.
	// By default source URIs are expanded against the underlying storage.
	// Other options include specifying manifest files. Only applicable to object storage systems. Docs
	FileSetSpecType *string `json:"fileSetSpecType,omitempty" tf:"file_set_spec_type,omitempty"`

	// Additional options if
	// source_format is set to "GOOGLE_SHEETS". Structure is
	// documented below.
	GoogleSheetsOptions *GoogleSheetsOptionsObservation `json:"googleSheetsOptions,omitempty" tf:"google_sheets_options,omitempty"`

	// When set, configures hive partitioning
	// support. Not all storage formats support hive partitioning -- requesting hive
	// partitioning on an unsupported format will lead to an error, as will providing
	// an invalid specification. Structure is documented below.
	HivePartitioningOptions *HivePartitioningOptionsObservation `json:"hivePartitioningOptions,omitempty" tf:"hive_partitioning_options,omitempty"`

	// Indicates if BigQuery should
	// allow extra values that are not represented in the table schema.
	// If true, the extra values are ignored. If false, records with
	// extra columns are treated as bad records, and if there are too
	// many bad records, an invalid error is returned in the job result.
	// The default value is false.
	IgnoreUnknownValues *bool `json:"ignoreUnknownValues,omitempty" tf:"ignore_unknown_values,omitempty"`

	// Used to indicate that a JSON variant, rather than normal JSON, is being used as the sourceFormat. This should only be used in combination with the JSON source format. Valid values are: GEOJSON.
	JSONExtension *string `json:"jsonExtension,omitempty" tf:"json_extension,omitempty"`

	// Additional properties to set if
	// source_format is set to "JSON". Structure is documented below.
	JSONOptions *JSONOptionsObservation `json:"jsonOptions,omitempty" tf:"json_options,omitempty"`

	// The maximum number of bad records that
	// BigQuery can ignore when reading data.
	MaxBadRecords *float64 `json:"maxBadRecords,omitempty" tf:"max_bad_records,omitempty"`

	// Metadata Cache Mode for the table. Set this to enable caching of metadata from external data source. Valid values are AUTOMATIC and MANUAL.
	MetadataCacheMode *string `json:"metadataCacheMode,omitempty" tf:"metadata_cache_mode,omitempty"`

	// Object Metadata is used to create Object Tables. Object Tables contain a listing of objects (with their metadata) found at the sourceUris. If object_metadata is set, source_format should be omitted.
	ObjectMetadata *string `json:"objectMetadata,omitempty" tf:"object_metadata,omitempty"`

	// Additional properties to set if
	// source_format is set to "PARQUET". Structure is documented below.
	ParquetOptions *ExternalDataConfigurationParquetOptionsObservation `json:"parquetOptions,omitempty" tf:"parquet_options,omitempty"`

	// When creating an external table, the user can provide a reference file with the table schema. This is enabled for the following formats: AVRO, PARQUET, ORC.
	ReferenceFileSchemaURI *string `json:"referenceFileSchemaUri,omitempty" tf:"reference_file_schema_uri,omitempty"`

	// A JSON schema for the external table. Schema is required
	// for CSV and JSON formats if autodetect is not on. Schema is disallowed
	// for Google Cloud Bigtable, Cloud Datastore backups, Avro, Iceberg, ORC and Parquet formats.
	// ~>NOTE: Because this field expects a JSON string, any changes to the
	// string will create a diff, even if the JSON itself hasn't changed.
	// Furthermore drift for this field cannot not be detected because BigQuery
	// only uses this schema to compute the effective schema for the table, therefore
	// any changes on the configured value will force the table to be recreated.
	// This schema is effectively only applied when creating a table from an external
	// datasource, after creation the computed schema will be stored in
	// google_bigquery_table.schema
	Schema *string `json:"schema,omitempty" tf:"schema,omitempty"`

	// The data format. Please see sourceFormat under
	// ExternalDataConfiguration
	// in Bigquery's public API documentation for supported formats. To use "GOOGLE_SHEETS"
	// the scopes must include "https://www.googleapis.com/auth/drive.readonly".
	SourceFormat *string `json:"sourceFormat,omitempty" tf:"source_format,omitempty"`

	// A list of the fully-qualified URIs that point to
	// your data in Google Cloud.
	SourceUris []*string `json:"sourceUris,omitempty" tf:"source_uris,omitempty"`
}

type ExternalDataConfigurationParameters struct {

	// Let BigQuery try to autodetect the schema
	// and format of the table.
	// +kubebuilder:validation:Optional
	Autodetect *bool `json:"autodetect" tf:"autodetect,omitempty"`

	// Additional options if source_format is set to
	// "AVRO".  Structure is documented below.
	// +kubebuilder:validation:Optional
	AvroOptions *AvroOptionsParameters `json:"avroOptions,omitempty" tf:"avro_options,omitempty"`

	// Additional properties to set if
	// source_format is set to "BIGTABLE". Structure is documented below.
	// +kubebuilder:validation:Optional
	BigtableOptions *BigtableOptionsParameters `json:"bigtableOptions,omitempty" tf:"bigtable_options,omitempty"`

	// The compression type of the data source.
	// Valid values are "NONE" or "GZIP".
	// +kubebuilder:validation:Optional
	Compression *string `json:"compression,omitempty" tf:"compression,omitempty"`

	// The connection specifying the credentials to be used to read
	// external storage, such as Azure Blob, Cloud Storage, or S3. The connection_id can have
	// the form {{project}}.{{location}}.{{connection_id}}
	// or projects/{{project}}/locations/{{location}}/connections/{{connection_id}}.
	// +kubebuilder:validation:Optional
	ConnectionID *string `json:"connectionId,omitempty" tf:"connection_id,omitempty"`

	// Additional properties to set if
	// source_format is set to "CSV". Structure is documented below.
	// +kubebuilder:validation:Optional
	CsvOptions *CsvOptionsParameters `json:"csvOptions,omitempty" tf:"csv_options,omitempty"`

	// Specifies how source URIs are interpreted for constructing the file set to load.
	// By default source URIs are expanded against the underlying storage.
	// Other options include specifying manifest files. Only applicable to object storage systems. Docs
	// +kubebuilder:validation:Optional
	FileSetSpecType *string `json:"fileSetSpecType,omitempty" tf:"file_set_spec_type,omitempty"`

	// Additional options if
	// source_format is set to "GOOGLE_SHEETS". Structure is
	// documented below.
	// +kubebuilder:validation:Optional
	GoogleSheetsOptions *GoogleSheetsOptionsParameters `json:"googleSheetsOptions,omitempty" tf:"google_sheets_options,omitempty"`

	// When set, configures hive partitioning
	// support. Not all storage formats support hive partitioning -- requesting hive
	// partitioning on an unsupported format will lead to an error, as will providing
	// an invalid specification. Structure is documented below.
	// +kubebuilder:validation:Optional
	HivePartitioningOptions *HivePartitioningOptionsParameters `json:"hivePartitioningOptions,omitempty" tf:"hive_partitioning_options,omitempty"`

	// Indicates if BigQuery should
	// allow extra values that are not represented in the table schema.
	// If true, the extra values are ignored. If false, records with
	// extra columns are treated as bad records, and if there are too
	// many bad records, an invalid error is returned in the job result.
	// The default value is false.
	// +kubebuilder:validation:Optional
	IgnoreUnknownValues *bool `json:"ignoreUnknownValues,omitempty" tf:"ignore_unknown_values,omitempty"`

	// Used to indicate that a JSON variant, rather than normal JSON, is being used as the sourceFormat. This should only be used in combination with the JSON source format. Valid values are: GEOJSON.
	// +kubebuilder:validation:Optional
	JSONExtension *string `json:"jsonExtension,omitempty" tf:"json_extension,omitempty"`

	// Additional properties to set if
	// source_format is set to "JSON". Structure is documented below.
	// +kubebuilder:validation:Optional
	JSONOptions *JSONOptionsParameters `json:"jsonOptions,omitempty" tf:"json_options,omitempty"`

	// The maximum number of bad records that
	// BigQuery can ignore when reading data.
	// +kubebuilder:validation:Optional
	MaxBadRecords *float64 `json:"maxBadRecords,omitempty" tf:"max_bad_records,omitempty"`

	// Metadata Cache Mode for the table. Set this to enable caching of metadata from external data source. Valid values are AUTOMATIC and MANUAL.
	// +kubebuilder:validation:Optional
	MetadataCacheMode *string `json:"metadataCacheMode,omitempty" tf:"metadata_cache_mode,omitempty"`

	// Object Metadata is used to create Object Tables. Object Tables contain a listing of objects (with their metadata) found at the sourceUris. If object_metadata is set, source_format should be omitted.
	// +kubebuilder:validation:Optional
	ObjectMetadata *string `json:"objectMetadata,omitempty" tf:"object_metadata,omitempty"`

	// Additional properties to set if
	// source_format is set to "PARQUET". Structure is documented below.
	// +kubebuilder:validation:Optional
	ParquetOptions *ExternalDataConfigurationParquetOptionsParameters `json:"parquetOptions,omitempty" tf:"parquet_options,omitempty"`

	// When creating an external table, the user can provide a reference file with the table schema. This is enabled for the following formats: AVRO, PARQUET, ORC.
	// +kubebuilder:validation:Optional
	ReferenceFileSchemaURI *string `json:"referenceFileSchemaUri,omitempty" tf:"reference_file_schema_uri,omitempty"`

	// A JSON schema for the external table. Schema is required
	// for CSV and JSON formats if autodetect is not on. Schema is disallowed
	// for Google Cloud Bigtable, Cloud Datastore backups, Avro, Iceberg, ORC and Parquet formats.
	// ~>NOTE: Because this field expects a JSON string, any changes to the
	// string will create a diff, even if the JSON itself hasn't changed.
	// Furthermore drift for this field cannot not be detected because BigQuery
	// only uses this schema to compute the effective schema for the table, therefore
	// any changes on the configured value will force the table to be recreated.
	// This schema is effectively only applied when creating a table from an external
	// datasource, after creation the computed schema will be stored in
	// google_bigquery_table.schema
	// +kubebuilder:validation:Optional
	Schema *string `json:"schema,omitempty" tf:"schema,omitempty"`

	// The data format. Please see sourceFormat under
	// ExternalDataConfiguration
	// in Bigquery's public API documentation for supported formats. To use "GOOGLE_SHEETS"
	// the scopes must include "https://www.googleapis.com/auth/drive.readonly".
	// +kubebuilder:validation:Optional
	SourceFormat *string `json:"sourceFormat,omitempty" tf:"source_format,omitempty"`

	// A list of the fully-qualified URIs that point to
	// your data in Google Cloud.
	// +kubebuilder:validation:Optional
	SourceUris []*string `json:"sourceUris" tf:"source_uris,omitempty"`
}

type ExternalDataConfigurationParquetOptionsInitParameters struct {

	// Indicates whether to use schema inference specifically for Parquet LIST logical type.
	EnableListInference *bool `json:"enableListInference,omitempty" tf:"enable_list_inference,omitempty"`

	// Indicates whether to infer Parquet ENUM logical type as STRING instead of BYTES by default.
	EnumAsString *bool `json:"enumAsString,omitempty" tf:"enum_as_string,omitempty"`
}

type ExternalDataConfigurationParquetOptionsObservation struct {

	// Indicates whether to use schema inference specifically for Parquet LIST logical type.
	EnableListInference *bool `json:"enableListInference,omitempty" tf:"enable_list_inference,omitempty"`

	// Indicates whether to infer Parquet ENUM logical type as STRING instead of BYTES by default.
	EnumAsString *bool `json:"enumAsString,omitempty" tf:"enum_as_string,omitempty"`
}

type ExternalDataConfigurationParquetOptionsParameters struct {

	// Indicates whether to use schema inference specifically for Parquet LIST logical type.
	// +kubebuilder:validation:Optional
	EnableListInference *bool `json:"enableListInference,omitempty" tf:"enable_list_inference,omitempty"`

	// Indicates whether to infer Parquet ENUM logical type as STRING instead of BYTES by default.
	// +kubebuilder:validation:Optional
	EnumAsString *bool `json:"enumAsString,omitempty" tf:"enum_as_string,omitempty"`
}

type ForeignKeysInitParameters struct {

	// The pair of the foreign key column and primary key column.
	// Structure is documented below.
	ColumnReferences *ColumnReferencesInitParameters `json:"columnReferences,omitempty" tf:"column_references,omitempty"`

	// Name of the SerDe. The maximum length is 256 characters.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The table that holds the primary key
	// and is referenced by this foreign key.
	// Structure is documented below.
	ReferencedTable *ReferencedTableInitParameters `json:"referencedTable,omitempty" tf:"referenced_table,omitempty"`
}

type ForeignKeysObservation struct {

	// The pair of the foreign key column and primary key column.
	// Structure is documented below.
	ColumnReferences *ColumnReferencesObservation `json:"columnReferences,omitempty" tf:"column_references,omitempty"`

	// Name of the SerDe. The maximum length is 256 characters.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The table that holds the primary key
	// and is referenced by this foreign key.
	// Structure is documented below.
	ReferencedTable *ReferencedTableObservation `json:"referencedTable,omitempty" tf:"referenced_table,omitempty"`
}

type ForeignKeysParameters struct {

	// The pair of the foreign key column and primary key column.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	ColumnReferences *ColumnReferencesParameters `json:"columnReferences" tf:"column_references,omitempty"`

	// Name of the SerDe. The maximum length is 256 characters.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The table that holds the primary key
	// and is referenced by this foreign key.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	ReferencedTable *ReferencedTableParameters `json:"referencedTable" tf:"referenced_table,omitempty"`
}

type GoogleSheetsOptionsInitParameters struct {

	// Information required to partition based on ranges.
	// Structure is documented below.
	Range *string `json:"range,omitempty" tf:"range,omitempty"`

	// The number of rows at the top of the sheet
	// that BigQuery will skip when reading the data. At least one of range or
	// skip_leading_rows must be set.
	SkipLeadingRows *float64 `json:"skipLeadingRows,omitempty" tf:"skip_leading_rows,omitempty"`
}

type GoogleSheetsOptionsObservation struct {

	// Information required to partition based on ranges.
	// Structure is documented below.
	Range *string `json:"range,omitempty" tf:"range,omitempty"`

	// The number of rows at the top of the sheet
	// that BigQuery will skip when reading the data. At least one of range or
	// skip_leading_rows must be set.
	SkipLeadingRows *float64 `json:"skipLeadingRows,omitempty" tf:"skip_leading_rows,omitempty"`
}

type GoogleSheetsOptionsParameters struct {

	// Information required to partition based on ranges.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Range *string `json:"range,omitempty" tf:"range,omitempty"`

	// The number of rows at the top of the sheet
	// that BigQuery will skip when reading the data. At least one of range or
	// skip_leading_rows must be set.
	// +kubebuilder:validation:Optional
	SkipLeadingRows *float64 `json:"skipLeadingRows,omitempty" tf:"skip_leading_rows,omitempty"`
}

type HivePartitioningOptionsInitParameters struct {

	// When set, what mode of hive partitioning to use when
	// reading data. The following modes are supported.
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// If set to true, queries over this table
	// require a partition filter that can be used for partition elimination to be
	// specified. require_partition_filter is deprecated and will be removed in
	// a future major release. Use the top level field with the same name instead.
	RequirePartitionFilter *bool `json:"requirePartitionFilter,omitempty" tf:"require_partition_filter,omitempty"`

	// When hive partition detection is requested,
	// a common for all source uris must be required. The prefix must end immediately
	// before the partition key encoding begins. For example, consider files following
	// this data layout. gs://bucket/path_to_table/dt=2019-06-01/country=USA/id=7/file.avro
	// gs://bucket/path_to_table/dt=2019-05-31/country=CA/id=3/file.avro When hive
	// partitioning is requested with either AUTO or STRINGS detection, the common prefix
	// can be either of gs://bucket/path_to_table or gs://bucket/path_to_table/.
	// Note that when mode is set to CUSTOM, you must encode the partition key schema within the source_uri_prefix by setting source_uri_prefix to gs://bucket/path_to_table/{key1:TYPE1}/{key2:TYPE2}/{key3:TYPE3}.
	SourceURIPrefix *string `json:"sourceUriPrefix,omitempty" tf:"source_uri_prefix,omitempty"`
}

type HivePartitioningOptionsObservation struct {

	// When set, what mode of hive partitioning to use when
	// reading data. The following modes are supported.
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// If set to true, queries over this table
	// require a partition filter that can be used for partition elimination to be
	// specified. require_partition_filter is deprecated and will be removed in
	// a future major release. Use the top level field with the same name instead.
	RequirePartitionFilter *bool `json:"requirePartitionFilter,omitempty" tf:"require_partition_filter,omitempty"`

	// When hive partition detection is requested,
	// a common for all source uris must be required. The prefix must end immediately
	// before the partition key encoding begins. For example, consider files following
	// this data layout. gs://bucket/path_to_table/dt=2019-06-01/country=USA/id=7/file.avro
	// gs://bucket/path_to_table/dt=2019-05-31/country=CA/id=3/file.avro When hive
	// partitioning is requested with either AUTO or STRINGS detection, the common prefix
	// can be either of gs://bucket/path_to_table or gs://bucket/path_to_table/.
	// Note that when mode is set to CUSTOM, you must encode the partition key schema within the source_uri_prefix by setting source_uri_prefix to gs://bucket/path_to_table/{key1:TYPE1}/{key2:TYPE2}/{key3:TYPE3}.
	SourceURIPrefix *string `json:"sourceUriPrefix,omitempty" tf:"source_uri_prefix,omitempty"`
}

type HivePartitioningOptionsParameters struct {

	// When set, what mode of hive partitioning to use when
	// reading data. The following modes are supported.
	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// If set to true, queries over this table
	// require a partition filter that can be used for partition elimination to be
	// specified. require_partition_filter is deprecated and will be removed in
	// a future major release. Use the top level field with the same name instead.
	// +kubebuilder:validation:Optional
	RequirePartitionFilter *bool `json:"requirePartitionFilter,omitempty" tf:"require_partition_filter,omitempty"`

	// When hive partition detection is requested,
	// a common for all source uris must be required. The prefix must end immediately
	// before the partition key encoding begins. For example, consider files following
	// this data layout. gs://bucket/path_to_table/dt=2019-06-01/country=USA/id=7/file.avro
	// gs://bucket/path_to_table/dt=2019-05-31/country=CA/id=3/file.avro When hive
	// partitioning is requested with either AUTO or STRINGS detection, the common prefix
	// can be either of gs://bucket/path_to_table or gs://bucket/path_to_table/.
	// Note that when mode is set to CUSTOM, you must encode the partition key schema within the source_uri_prefix by setting source_uri_prefix to gs://bucket/path_to_table/{key1:TYPE1}/{key2:TYPE2}/{key3:TYPE3}.
	// +kubebuilder:validation:Optional
	SourceURIPrefix *string `json:"sourceUriPrefix,omitempty" tf:"source_uri_prefix,omitempty"`
}

type JSONOptionsInitParameters struct {

	// The character encoding of the data. The supported values are UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE. The default value is UTF-8.
	Encoding *string `json:"encoding,omitempty" tf:"encoding,omitempty"`
}

type JSONOptionsObservation struct {

	// The character encoding of the data. The supported values are UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE. The default value is UTF-8.
	Encoding *string `json:"encoding,omitempty" tf:"encoding,omitempty"`
}

type JSONOptionsParameters struct {

	// The character encoding of the data. The supported values are UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE. The default value is UTF-8.
	// +kubebuilder:validation:Optional
	Encoding *string `json:"encoding,omitempty" tf:"encoding,omitempty"`
}

type MaterializedViewInitParameters struct {

	// Allow non incremental materialized view definition.
	// The default value is false.
	AllowNonIncrementalDefinition *bool `json:"allowNonIncrementalDefinition,omitempty" tf:"allow_non_incremental_definition,omitempty"`

	// Specifies whether to use BigQuery's automatic refresh for this materialized view when the base table is updated.
	// The default value is true.
	EnableRefresh *bool `json:"enableRefresh,omitempty" tf:"enable_refresh,omitempty"`

	// A query whose result is persisted.
	Query *string `json:"query,omitempty" tf:"query,omitempty"`

	// The maximum frequency at which this materialized view will be refreshed.
	// The default value is 1800000
	RefreshIntervalMs *float64 `json:"refreshIntervalMs,omitempty" tf:"refresh_interval_ms,omitempty"`
}

type MaterializedViewObservation struct {

	// Allow non incremental materialized view definition.
	// The default value is false.
	AllowNonIncrementalDefinition *bool `json:"allowNonIncrementalDefinition,omitempty" tf:"allow_non_incremental_definition,omitempty"`

	// Specifies whether to use BigQuery's automatic refresh for this materialized view when the base table is updated.
	// The default value is true.
	EnableRefresh *bool `json:"enableRefresh,omitempty" tf:"enable_refresh,omitempty"`

	// A query whose result is persisted.
	Query *string `json:"query,omitempty" tf:"query,omitempty"`

	// The maximum frequency at which this materialized view will be refreshed.
	// The default value is 1800000
	RefreshIntervalMs *float64 `json:"refreshIntervalMs,omitempty" tf:"refresh_interval_ms,omitempty"`
}

type MaterializedViewParameters struct {

	// Allow non incremental materialized view definition.
	// The default value is false.
	// +kubebuilder:validation:Optional
	AllowNonIncrementalDefinition *bool `json:"allowNonIncrementalDefinition,omitempty" tf:"allow_non_incremental_definition,omitempty"`

	// Specifies whether to use BigQuery's automatic refresh for this materialized view when the base table is updated.
	// The default value is true.
	// +kubebuilder:validation:Optional
	EnableRefresh *bool `json:"enableRefresh,omitempty" tf:"enable_refresh,omitempty"`

	// A query whose result is persisted.
	// +kubebuilder:validation:Optional
	Query *string `json:"query" tf:"query,omitempty"`

	// The maximum frequency at which this materialized view will be refreshed.
	// The default value is 1800000
	// +kubebuilder:validation:Optional
	RefreshIntervalMs *float64 `json:"refreshIntervalMs,omitempty" tf:"refresh_interval_ms,omitempty"`
}

type PrimaryKeyInitParameters struct {

	// The columns that are composed of the primary key constraint.
	Columns []*string `json:"columns,omitempty" tf:"columns,omitempty"`
}

type PrimaryKeyObservation struct {

	// The columns that are composed of the primary key constraint.
	Columns []*string `json:"columns,omitempty" tf:"columns,omitempty"`
}

type PrimaryKeyParameters struct {

	// The columns that are composed of the primary key constraint.
	// +kubebuilder:validation:Optional
	Columns []*string `json:"columns" tf:"columns,omitempty"`
}

type RangeInitParameters struct {

	// End of the range partitioning, exclusive.
	End *float64 `json:"end,omitempty" tf:"end,omitempty"`

	// The width of each range within the partition.
	Interval *float64 `json:"interval,omitempty" tf:"interval,omitempty"`

	// Start of the range partitioning, inclusive.
	Start *float64 `json:"start,omitempty" tf:"start,omitempty"`
}

type RangeObservation struct {

	// End of the range partitioning, exclusive.
	End *float64 `json:"end,omitempty" tf:"end,omitempty"`

	// The width of each range within the partition.
	Interval *float64 `json:"interval,omitempty" tf:"interval,omitempty"`

	// Start of the range partitioning, inclusive.
	Start *float64 `json:"start,omitempty" tf:"start,omitempty"`
}

type RangeParameters struct {

	// End of the range partitioning, exclusive.
	// +kubebuilder:validation:Optional
	End *float64 `json:"end" tf:"end,omitempty"`

	// The width of each range within the partition.
	// +kubebuilder:validation:Optional
	Interval *float64 `json:"interval" tf:"interval,omitempty"`

	// Start of the range partitioning, inclusive.
	// +kubebuilder:validation:Optional
	Start *float64 `json:"start" tf:"start,omitempty"`
}

type RangePartitioningInitParameters struct {

	// The field used to determine how to create a range-based
	// partition.
	Field *string `json:"field,omitempty" tf:"field,omitempty"`

	// Information required to partition based on ranges.
	// Structure is documented below.
	Range *RangeInitParameters `json:"range,omitempty" tf:"range,omitempty"`
}

type RangePartitioningObservation struct {

	// The field used to determine how to create a range-based
	// partition.
	Field *string `json:"field,omitempty" tf:"field,omitempty"`

	// Information required to partition based on ranges.
	// Structure is documented below.
	Range *RangeObservation `json:"range,omitempty" tf:"range,omitempty"`
}

type RangePartitioningParameters struct {

	// The field used to determine how to create a range-based
	// partition.
	// +kubebuilder:validation:Optional
	Field *string `json:"field" tf:"field,omitempty"`

	// Information required to partition based on ranges.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Range *RangeParameters `json:"range" tf:"range,omitempty"`
}

type ReferencedTableInitParameters struct {

	// The ID of the project containing this table.
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// A unique ID for the resource.
	// Changing this forces a new resource to be created.
	TableID *string `json:"tableId,omitempty" tf:"table_id,omitempty"`
}

type ReferencedTableObservation struct {

	// The ID of the dataset containing this table.
	DatasetID *string `json:"datasetId,omitempty" tf:"dataset_id,omitempty"`

	// The ID of the project containing this table.
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// A unique ID for the resource.
	// Changing this forces a new resource to be created.
	TableID *string `json:"tableId,omitempty" tf:"table_id,omitempty"`
}

type ReferencedTableParameters struct {

	// The ID of the dataset containing this table.
	// +kubebuilder:validation:Required
	DatasetID *string `json:"datasetId" tf:"dataset_id,omitempty"`

	// The ID of the project containing this table.
	// +kubebuilder:validation:Optional
	ProjectID *string `json:"projectId" tf:"project_id,omitempty"`

	// A unique ID for the resource.
	// Changing this forces a new resource to be created.
	// +kubebuilder:validation:Optional
	TableID *string `json:"tableId" tf:"table_id,omitempty"`
}

type SchemaForeignTypeInfoInitParameters struct {

	// Specifies the system which defines the foreign data
	// type.
	TypeSystem *string `json:"typeSystem,omitempty" tf:"type_system,omitempty"`
}

type SchemaForeignTypeInfoObservation struct {

	// Specifies the system which defines the foreign data
	// type.
	TypeSystem *string `json:"typeSystem,omitempty" tf:"type_system,omitempty"`
}

type SchemaForeignTypeInfoParameters struct {

	// Specifies the system which defines the foreign data
	// type.
	// +kubebuilder:validation:Optional
	TypeSystem *string `json:"typeSystem" tf:"type_system,omitempty"`
}

type SerdeInfoInitParameters struct {

	// Name of the SerDe. The maximum length is 256 characters.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Key-value pairs that define the initialization
	// parameters for the serialization library. Maximum size 10 Kib.
	// +mapType=granular
	Parameters map[string]*string `json:"parameters,omitempty" tf:"parameters,omitempty"`

	// Specifies a fully-qualified class name of
	// the serialization library that is responsible for the translation of data
	// between table representation and the underlying low-level input and output
	// format structures. The maximum length is 256 characters.
	SerializationLibrary *string `json:"serializationLibrary,omitempty" tf:"serialization_library,omitempty"`
}

type SerdeInfoObservation struct {

	// Name of the SerDe. The maximum length is 256 characters.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Key-value pairs that define the initialization
	// parameters for the serialization library. Maximum size 10 Kib.
	// +mapType=granular
	Parameters map[string]*string `json:"parameters,omitempty" tf:"parameters,omitempty"`

	// Specifies a fully-qualified class name of
	// the serialization library that is responsible for the translation of data
	// between table representation and the underlying low-level input and output
	// format structures. The maximum length is 256 characters.
	SerializationLibrary *string `json:"serializationLibrary,omitempty" tf:"serialization_library,omitempty"`
}

type SerdeInfoParameters struct {

	// Name of the SerDe. The maximum length is 256 characters.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Key-value pairs that define the initialization
	// parameters for the serialization library. Maximum size 10 Kib.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Parameters map[string]*string `json:"parameters,omitempty" tf:"parameters,omitempty"`

	// Specifies a fully-qualified class name of
	// the serialization library that is responsible for the translation of data
	// between table representation and the underlying low-level input and output
	// format structures. The maximum length is 256 characters.
	// +kubebuilder:validation:Optional
	SerializationLibrary *string `json:"serializationLibrary" tf:"serialization_library,omitempty"`
}

type StorageDescriptorInitParameters struct {

	// Specifies the fully qualified class name of the
	// InputFormat (e.g. "org.apache.hadoop.hive.ql.io.orc.OrcInputFormat"). The
	// maximum length is 128 characters.
	InputFormat *string `json:"inputFormat,omitempty" tf:"input_format,omitempty"`

	// The physical location of the table (e.g.
	// 'gs://spark-dataproc-data/pangea-data/case_sensitive/' or
	// 'gs://spark-dataproc-data/pangea-data/*'). The maximum length is 2056 bytes.
	LocationURI *string `json:"locationUri,omitempty" tf:"location_uri,omitempty"`

	// Specifies the fully qualified class name of the
	// OutputFormat (e.g. "org.apache.hadoop.hive.ql.io.orc.OrcOutputFormat"). The
	// maximum length is 128 characters.
	OutputFormat *string `json:"outputFormat,omitempty" tf:"output_format,omitempty"`

	// Serializer and deserializer information. Structure
	// is documented below.
	SerdeInfo *SerdeInfoInitParameters `json:"serdeInfo,omitempty" tf:"serde_info,omitempty"`
}

type StorageDescriptorObservation struct {

	// Specifies the fully qualified class name of the
	// InputFormat (e.g. "org.apache.hadoop.hive.ql.io.orc.OrcInputFormat"). The
	// maximum length is 128 characters.
	InputFormat *string `json:"inputFormat,omitempty" tf:"input_format,omitempty"`

	// The physical location of the table (e.g.
	// 'gs://spark-dataproc-data/pangea-data/case_sensitive/' or
	// 'gs://spark-dataproc-data/pangea-data/*'). The maximum length is 2056 bytes.
	LocationURI *string `json:"locationUri,omitempty" tf:"location_uri,omitempty"`

	// Specifies the fully qualified class name of the
	// OutputFormat (e.g. "org.apache.hadoop.hive.ql.io.orc.OrcOutputFormat"). The
	// maximum length is 128 characters.
	OutputFormat *string `json:"outputFormat,omitempty" tf:"output_format,omitempty"`

	// Serializer and deserializer information. Structure
	// is documented below.
	SerdeInfo *SerdeInfoObservation `json:"serdeInfo,omitempty" tf:"serde_info,omitempty"`
}

type StorageDescriptorParameters struct {

	// Specifies the fully qualified class name of the
	// InputFormat (e.g. "org.apache.hadoop.hive.ql.io.orc.OrcInputFormat"). The
	// maximum length is 128 characters.
	// +kubebuilder:validation:Optional
	InputFormat *string `json:"inputFormat,omitempty" tf:"input_format,omitempty"`

	// The physical location of the table (e.g.
	// 'gs://spark-dataproc-data/pangea-data/case_sensitive/' or
	// 'gs://spark-dataproc-data/pangea-data/*'). The maximum length is 2056 bytes.
	// +kubebuilder:validation:Optional
	LocationURI *string `json:"locationUri,omitempty" tf:"location_uri,omitempty"`

	// Specifies the fully qualified class name of the
	// OutputFormat (e.g. "org.apache.hadoop.hive.ql.io.orc.OrcOutputFormat"). The
	// maximum length is 128 characters.
	// +kubebuilder:validation:Optional
	OutputFormat *string `json:"outputFormat,omitempty" tf:"output_format,omitempty"`

	// Serializer and deserializer information. Structure
	// is documented below.
	// +kubebuilder:validation:Optional
	SerdeInfo *SerdeInfoParameters `json:"serdeInfo,omitempty" tf:"serde_info,omitempty"`
}

type TableConstraintsInitParameters struct {

	// Present only if the table has a foreign key.
	// The foreign key is not enforced.
	// Structure is documented below.
	ForeignKeys []ForeignKeysInitParameters `json:"foreignKeys,omitempty" tf:"foreign_keys,omitempty"`

	// Represents the primary key constraint
	// on a table's columns. Present only if the table has a primary key.
	// The primary key is not enforced.
	// Structure is documented below.
	PrimaryKey *PrimaryKeyInitParameters `json:"primaryKey,omitempty" tf:"primary_key,omitempty"`
}

type TableConstraintsObservation struct {

	// Present only if the table has a foreign key.
	// The foreign key is not enforced.
	// Structure is documented below.
	ForeignKeys []ForeignKeysObservation `json:"foreignKeys,omitempty" tf:"foreign_keys,omitempty"`

	// Represents the primary key constraint
	// on a table's columns. Present only if the table has a primary key.
	// The primary key is not enforced.
	// Structure is documented below.
	PrimaryKey *PrimaryKeyObservation `json:"primaryKey,omitempty" tf:"primary_key,omitempty"`
}

type TableConstraintsParameters struct {

	// Present only if the table has a foreign key.
	// The foreign key is not enforced.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	ForeignKeys []ForeignKeysParameters `json:"foreignKeys,omitempty" tf:"foreign_keys,omitempty"`

	// Represents the primary key constraint
	// on a table's columns. Present only if the table has a primary key.
	// The primary key is not enforced.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	PrimaryKey *PrimaryKeyParameters `json:"primaryKey,omitempty" tf:"primary_key,omitempty"`
}

type TableEncryptionConfigurationInitParameters struct {

	// The self link or full name of a key which should be used to
	// encrypt this table.  Note that the default bigquery service account will need to have
	// encrypt/decrypt permissions on this key - you may want to see the
	// google_bigquery_default_service_account datasource and the
	// google_kms_crypto_key_iam_binding resource.
	KMSKeyName *string `json:"kmsKeyName,omitempty" tf:"kms_key_name,omitempty"`
}

type TableEncryptionConfigurationObservation struct {

	// The self link or full name of a key which should be used to
	// encrypt this table.  Note that the default bigquery service account will need to have
	// encrypt/decrypt permissions on this key - you may want to see the
	// google_bigquery_default_service_account datasource and the
	// google_kms_crypto_key_iam_binding resource.
	KMSKeyName *string `json:"kmsKeyName,omitempty" tf:"kms_key_name,omitempty"`

	// The self link or full name of the kms key version used to encrypt this table.
	KMSKeyVersion *string `json:"kmsKeyVersion,omitempty" tf:"kms_key_version,omitempty"`
}

type TableEncryptionConfigurationParameters struct {

	// The self link or full name of a key which should be used to
	// encrypt this table.  Note that the default bigquery service account will need to have
	// encrypt/decrypt permissions on this key - you may want to see the
	// google_bigquery_default_service_account datasource and the
	// google_kms_crypto_key_iam_binding resource.
	// +kubebuilder:validation:Optional
	KMSKeyName *string `json:"kmsKeyName" tf:"kms_key_name,omitempty"`
}

type TableInitParameters struct {

	// Specifies the configuration of a BigLake managed table. Structure is documented below
	BiglakeConfiguration *BiglakeConfigurationInitParameters `json:"biglakeConfiguration,omitempty" tf:"biglake_configuration,omitempty"`

	// Specifies column names to use for data clustering.
	// Up to four top-level columns are allowed, and should be specified in
	// descending priority order.
	Clustering []*string `json:"clustering,omitempty" tf:"clustering,omitempty"`

	// When the field is set to false, deleting the table is allowed..
	DeletionProtection *bool `json:"deletionProtection,omitempty" tf:"deletion_protection,omitempty"`

	// The field description.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Specifies how the table should be encrypted.
	// If left blank, the table will be encrypted with a Google-managed key; that process
	// is transparent to the user.  Structure is documented below.
	EncryptionConfiguration *TableEncryptionConfigurationInitParameters `json:"encryptionConfiguration,omitempty" tf:"encryption_configuration,omitempty"`

	// The time when this table expires, in
	// milliseconds since the epoch. If not present, the table will persist
	// indefinitely. Expired tables will be deleted and their storage
	// reclaimed.
	ExpirationTime *float64 `json:"expirationTime,omitempty" tf:"expiration_time,omitempty"`

	// Options defining open source
	// compatible table. Structure is documented below.
	ExternalCatalogTableOptions *ExternalCatalogTableOptionsInitParameters `json:"externalCatalogTableOptions,omitempty" tf:"external_catalog_table_options,omitempty"`

	// Describes the data format,
	// location, and other properties of a table stored outside of BigQuery.
	// By defining these properties, the data source can then be queried as
	// if it were a standard BigQuery table. Structure is documented below.
	ExternalDataConfiguration *ExternalDataConfigurationInitParameters `json:"externalDataConfiguration,omitempty" tf:"external_data_configuration,omitempty"`

	// A descriptive name for the table.
	FriendlyName *string `json:"friendlyName,omitempty" tf:"friendly_name,omitempty"`

	// A list of fields which should be ignored for each column in schema.
	// NOTE: Right now only dataPolicies field is supported. We might support others in the future.
	IgnoreSchemaChanges []*string `json:"ignoreSchemaChanges,omitempty" tf:"ignore_schema_changes,omitempty"`

	// A mapping of labels to assign to the resource.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// If specified, configures this table as a materialized view.
	// Structure is documented below.
	MaterializedView *MaterializedViewInitParameters `json:"materializedView,omitempty" tf:"materialized_view,omitempty"`

	// The maximum staleness of data that could be
	// returned when the table (or stale MV) is queried. Staleness encoded as a
	// string encoding of SQL IntervalValue
	// type.
	MaxStaleness *string `json:"maxStaleness,omitempty" tf:"max_staleness,omitempty"`

	// If specified, configures range-based
	// partitioning for this table. Structure is documented below.
	RangePartitioning *RangePartitioningInitParameters `json:"rangePartitioning,omitempty" tf:"range_partitioning,omitempty"`

	// If set to true, queries over this table
	// require a partition filter that can be used for partition elimination to be
	// specified.
	RequirePartitionFilter *bool `json:"requirePartitionFilter,omitempty" tf:"require_partition_filter,omitempty"`

	// The tags attached to this table. Tag keys are
	// globally unique. Tag key is expected to be in the namespaced format, for
	// example "123456789012/environment" where 123456789012 is the ID of the
	// parent organization or project resource for this tag key. Tag value is
	// expected to be the short name, for example "Production". See Tag definitions
	// for more details.
	// +mapType=granular
	ResourceTags map[string]*string `json:"resourceTags,omitempty" tf:"resource_tags,omitempty"`

	// A JSON schema for the table.
	Schema *string `json:"schema,omitempty" tf:"schema,omitempty"`

	// Specifies metadata of the foreign data
	// type definition in field schema. Structure is documented below.
	SchemaForeignTypeInfo *SchemaForeignTypeInfoInitParameters `json:"schemaForeignTypeInfo,omitempty" tf:"schema_foreign_type_info,omitempty"`

	// Defines the primary key and foreign keys.
	// Structure is documented below.
	TableConstraints *TableConstraintsInitParameters `json:"tableConstraints,omitempty" tf:"table_constraints,omitempty"`

	// If specified, configures this table as a view.
	// Structure is documented below.
	TableMetadataView *string `json:"tableMetadataView,omitempty" tf:"table_metadata_view,omitempty"`

	// Replication info of a table created
	// using "AS REPLICA" DDL like:
	// CREATE MATERIALIZED VIEW mv1 AS REPLICA OF src_mv.
	// Structure is documented below.
	TableReplicationInfo *TableReplicationInfoInitParameters `json:"tableReplicationInfo,omitempty" tf:"table_replication_info,omitempty"`

	// If specified, configures time-based
	// partitioning for this table. Structure is documented below.
	TimePartitioning *TableTimePartitioningInitParameters `json:"timePartitioning,omitempty" tf:"time_partitioning,omitempty"`

	// If specified, configures this table as a view.
	// Structure is documented below.
	View *TableViewInitParameters `json:"view,omitempty" tf:"view,omitempty"`
}

type TableObservation struct {

	// Specifies the configuration of a BigLake managed table. Structure is documented below
	BiglakeConfiguration *BiglakeConfigurationObservation `json:"biglakeConfiguration,omitempty" tf:"biglake_configuration,omitempty"`

	// Specifies column names to use for data clustering.
	// Up to four top-level columns are allowed, and should be specified in
	// descending priority order.
	Clustering []*string `json:"clustering,omitempty" tf:"clustering,omitempty"`

	// The time when this table was created, in milliseconds since the epoch.
	CreationTime *float64 `json:"creationTime,omitempty" tf:"creation_time,omitempty"`

	// The dataset ID to create the table in.
	// Changing this forces a new resource to be created.
	DatasetID *string `json:"datasetId,omitempty" tf:"dataset_id,omitempty"`

	// When the field is set to false, deleting the table is allowed..
	DeletionProtection *bool `json:"deletionProtection,omitempty" tf:"deletion_protection,omitempty"`

	// The field description.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +mapType=granular
	EffectiveLabels map[string]*string `json:"effectiveLabels,omitempty" tf:"effective_labels,omitempty"`

	// Specifies how the table should be encrypted.
	// If left blank, the table will be encrypted with a Google-managed key; that process
	// is transparent to the user.  Structure is documented below.
	EncryptionConfiguration *TableEncryptionConfigurationObservation `json:"encryptionConfiguration,omitempty" tf:"encryption_configuration,omitempty"`

	// A hash of the resource.
	Etag *string `json:"etag,omitempty" tf:"etag,omitempty"`

	// The time when this table expires, in
	// milliseconds since the epoch. If not present, the table will persist
	// indefinitely. Expired tables will be deleted and their storage
	// reclaimed.
	ExpirationTime *float64 `json:"expirationTime,omitempty" tf:"expiration_time,omitempty"`

	// Options defining open source
	// compatible table. Structure is documented below.
	ExternalCatalogTableOptions *ExternalCatalogTableOptionsObservation `json:"externalCatalogTableOptions,omitempty" tf:"external_catalog_table_options,omitempty"`

	// Describes the data format,
	// location, and other properties of a table stored outside of BigQuery.
	// By defining these properties, the data source can then be queried as
	// if it were a standard BigQuery table. Structure is documented below.
	ExternalDataConfiguration *ExternalDataConfigurationObservation `json:"externalDataConfiguration,omitempty" tf:"external_data_configuration,omitempty"`

	// A descriptive name for the table.
	FriendlyName *string `json:"friendlyName,omitempty" tf:"friendly_name,omitempty"`

	// An identifier for the resource with format projects/{{project}}/datasets/{{dataset}}/tables/{{name}}
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// A list of fields which should be ignored for each column in schema.
	// NOTE: Right now only dataPolicies field is supported. We might support others in the future.
	IgnoreSchemaChanges []*string `json:"ignoreSchemaChanges,omitempty" tf:"ignore_schema_changes,omitempty"`

	// A mapping of labels to assign to the resource.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The time when this table was last modified, in milliseconds since the epoch.
	LastModifiedTime *float64 `json:"lastModifiedTime,omitempty" tf:"last_modified_time,omitempty"`

	// The geographic location where the table resides. This value is inherited from the dataset.
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// If specified, configures this table as a materialized view.
	// Structure is documented below.
	MaterializedView *MaterializedViewObservation `json:"materializedView,omitempty" tf:"materialized_view,omitempty"`

	// The maximum staleness of data that could be
	// returned when the table (or stale MV) is queried. Staleness encoded as a
	// string encoding of SQL IntervalValue
	// type.
	MaxStaleness *string `json:"maxStaleness,omitempty" tf:"max_staleness,omitempty"`

	// The size of this table in bytes, excluding any data in the streaming buffer.
	NumBytes *float64 `json:"numBytes,omitempty" tf:"num_bytes,omitempty"`

	// The number of bytes in the table that are considered "long-term storage".
	NumLongTermBytes *float64 `json:"numLongTermBytes,omitempty" tf:"num_long_term_bytes,omitempty"`

	// The number of rows of data in this table, excluding any data in the streaming buffer.
	NumRows *float64 `json:"numRows,omitempty" tf:"num_rows,omitempty"`

	// The ID of the project in which the resource belongs. If it
	// is not provided, the provider project is used.
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// If specified, configures range-based
	// partitioning for this table. Structure is documented below.
	RangePartitioning *RangePartitioningObservation `json:"rangePartitioning,omitempty" tf:"range_partitioning,omitempty"`

	// If set to true, queries over this table
	// require a partition filter that can be used for partition elimination to be
	// specified.
	RequirePartitionFilter *bool `json:"requirePartitionFilter,omitempty" tf:"require_partition_filter,omitempty"`

	// The tags attached to this table. Tag keys are
	// globally unique. Tag key is expected to be in the namespaced format, for
	// example "123456789012/environment" where 123456789012 is the ID of the
	// parent organization or project resource for this tag key. Tag value is
	// expected to be the short name, for example "Production". See Tag definitions
	// for more details.
	// +mapType=granular
	ResourceTags map[string]*string `json:"resourceTags,omitempty" tf:"resource_tags,omitempty"`

	// A JSON schema for the table.
	Schema *string `json:"schema,omitempty" tf:"schema,omitempty"`

	// Specifies metadata of the foreign data
	// type definition in field schema. Structure is documented below.
	SchemaForeignTypeInfo *SchemaForeignTypeInfoObservation `json:"schemaForeignTypeInfo,omitempty" tf:"schema_foreign_type_info,omitempty"`

	// The URI of the created resource.
	SelfLink *string `json:"selfLink,omitempty" tf:"self_link,omitempty"`

	// Defines the primary key and foreign keys.
	// Structure is documented below.
	TableConstraints *TableConstraintsObservation `json:"tableConstraints,omitempty" tf:"table_constraints,omitempty"`

	// If specified, configures this table as a view.
	// Structure is documented below.
	TableMetadataView *string `json:"tableMetadataView,omitempty" tf:"table_metadata_view,omitempty"`

	// Replication info of a table created
	// using "AS REPLICA" DDL like:
	// CREATE MATERIALIZED VIEW mv1 AS REPLICA OF src_mv.
	// Structure is documented below.
	TableReplicationInfo *TableReplicationInfoObservation `json:"tableReplicationInfo,omitempty" tf:"table_replication_info,omitempty"`

	// The combination of labels configured directly on the resource and default labels configured on the provider.
	// +mapType=granular
	TerraformLabels map[string]*string `json:"terraformLabels,omitempty" tf:"terraform_labels,omitempty"`

	// If specified, configures time-based
	// partitioning for this table. Structure is documented below.
	TimePartitioning *TableTimePartitioningObservation `json:"timePartitioning,omitempty" tf:"time_partitioning,omitempty"`

	// Describes the table type.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// If specified, configures this table as a view.
	// Structure is documented below.
	View *TableViewObservation `json:"view,omitempty" tf:"view,omitempty"`
}

type TableParameters struct {

	// Specifies the configuration of a BigLake managed table. Structure is documented below
	// +kubebuilder:validation:Optional
	BiglakeConfiguration *BiglakeConfigurationParameters `json:"biglakeConfiguration,omitempty" tf:"biglake_configuration,omitempty"`

	// Specifies column names to use for data clustering.
	// Up to four top-level columns are allowed, and should be specified in
	// descending priority order.
	// +kubebuilder:validation:Optional
	Clustering []*string `json:"clustering,omitempty" tf:"clustering,omitempty"`

	// The dataset ID to create the table in.
	// Changing this forces a new resource to be created.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/bigquery/v1beta2.Dataset
	// +kubebuilder:validation:Optional
	DatasetID *string `json:"datasetId,omitempty" tf:"dataset_id,omitempty"`

	// Reference to a Dataset in bigquery to populate datasetId.
	// +kubebuilder:validation:Optional
	DatasetIDRef *v1.Reference `json:"datasetIdRef,omitempty" tf:"-"`

	// Selector for a Dataset in bigquery to populate datasetId.
	// +kubebuilder:validation:Optional
	DatasetIDSelector *v1.Selector `json:"datasetIdSelector,omitempty" tf:"-"`

	// When the field is set to false, deleting the table is allowed..
	// +kubebuilder:validation:Optional
	DeletionProtection *bool `json:"deletionProtection,omitempty" tf:"deletion_protection,omitempty"`

	// The field description.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Specifies how the table should be encrypted.
	// If left blank, the table will be encrypted with a Google-managed key; that process
	// is transparent to the user.  Structure is documented below.
	// +kubebuilder:validation:Optional
	EncryptionConfiguration *TableEncryptionConfigurationParameters `json:"encryptionConfiguration,omitempty" tf:"encryption_configuration,omitempty"`

	// The time when this table expires, in
	// milliseconds since the epoch. If not present, the table will persist
	// indefinitely. Expired tables will be deleted and their storage
	// reclaimed.
	// +kubebuilder:validation:Optional
	ExpirationTime *float64 `json:"expirationTime,omitempty" tf:"expiration_time,omitempty"`

	// Options defining open source
	// compatible table. Structure is documented below.
	// +kubebuilder:validation:Optional
	ExternalCatalogTableOptions *ExternalCatalogTableOptionsParameters `json:"externalCatalogTableOptions,omitempty" tf:"external_catalog_table_options,omitempty"`

	// Describes the data format,
	// location, and other properties of a table stored outside of BigQuery.
	// By defining these properties, the data source can then be queried as
	// if it were a standard BigQuery table. Structure is documented below.
	// +kubebuilder:validation:Optional
	ExternalDataConfiguration *ExternalDataConfigurationParameters `json:"externalDataConfiguration,omitempty" tf:"external_data_configuration,omitempty"`

	// A descriptive name for the table.
	// +kubebuilder:validation:Optional
	FriendlyName *string `json:"friendlyName,omitempty" tf:"friendly_name,omitempty"`

	// A list of fields which should be ignored for each column in schema.
	// NOTE: Right now only dataPolicies field is supported. We might support others in the future.
	// +kubebuilder:validation:Optional
	IgnoreSchemaChanges []*string `json:"ignoreSchemaChanges,omitempty" tf:"ignore_schema_changes,omitempty"`

	// A mapping of labels to assign to the resource.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// If specified, configures this table as a materialized view.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	MaterializedView *MaterializedViewParameters `json:"materializedView,omitempty" tf:"materialized_view,omitempty"`

	// The maximum staleness of data that could be
	// returned when the table (or stale MV) is queried. Staleness encoded as a
	// string encoding of SQL IntervalValue
	// type.
	// +kubebuilder:validation:Optional
	MaxStaleness *string `json:"maxStaleness,omitempty" tf:"max_staleness,omitempty"`

	// The ID of the project in which the resource belongs. If it
	// is not provided, the provider project is used.
	// +kubebuilder:validation:Optional
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// If specified, configures range-based
	// partitioning for this table. Structure is documented below.
	// +kubebuilder:validation:Optional
	RangePartitioning *RangePartitioningParameters `json:"rangePartitioning,omitempty" tf:"range_partitioning,omitempty"`

	// If set to true, queries over this table
	// require a partition filter that can be used for partition elimination to be
	// specified.
	// +kubebuilder:validation:Optional
	RequirePartitionFilter *bool `json:"requirePartitionFilter,omitempty" tf:"require_partition_filter,omitempty"`

	// The tags attached to this table. Tag keys are
	// globally unique. Tag key is expected to be in the namespaced format, for
	// example "123456789012/environment" where 123456789012 is the ID of the
	// parent organization or project resource for this tag key. Tag value is
	// expected to be the short name, for example "Production". See Tag definitions
	// for more details.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	ResourceTags map[string]*string `json:"resourceTags,omitempty" tf:"resource_tags,omitempty"`

	// A JSON schema for the table.
	// +kubebuilder:validation:Optional
	Schema *string `json:"schema,omitempty" tf:"schema,omitempty"`

	// Specifies metadata of the foreign data
	// type definition in field schema. Structure is documented below.
	// +kubebuilder:validation:Optional
	SchemaForeignTypeInfo *SchemaForeignTypeInfoParameters `json:"schemaForeignTypeInfo,omitempty" tf:"schema_foreign_type_info,omitempty"`

	// Defines the primary key and foreign keys.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	TableConstraints *TableConstraintsParameters `json:"tableConstraints,omitempty" tf:"table_constraints,omitempty"`

	// If specified, configures this table as a view.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	TableMetadataView *string `json:"tableMetadataView,omitempty" tf:"table_metadata_view,omitempty"`

	// Replication info of a table created
	// using "AS REPLICA" DDL like:
	// CREATE MATERIALIZED VIEW mv1 AS REPLICA OF src_mv.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	TableReplicationInfo *TableReplicationInfoParameters `json:"tableReplicationInfo,omitempty" tf:"table_replication_info,omitempty"`

	// If specified, configures time-based
	// partitioning for this table. Structure is documented below.
	// +kubebuilder:validation:Optional
	TimePartitioning *TableTimePartitioningParameters `json:"timePartitioning,omitempty" tf:"time_partitioning,omitempty"`

	// If specified, configures this table as a view.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	View *TableViewParameters `json:"view,omitempty" tf:"view,omitempty"`
}

type TableReplicationInfoInitParameters struct {

	// The interval at which the source
	// materialized view is polled for updates. The default is 300000.
	ReplicationIntervalMs *float64 `json:"replicationIntervalMs,omitempty" tf:"replication_interval_ms,omitempty"`

	// The ID of the source dataset.
	SourceDatasetID *string `json:"sourceDatasetId,omitempty" tf:"source_dataset_id,omitempty"`

	// The ID of the source project.
	SourceProjectID *string `json:"sourceProjectId,omitempty" tf:"source_project_id,omitempty"`

	// The ID of the source materialized view.
	SourceTableID *string `json:"sourceTableId,omitempty" tf:"source_table_id,omitempty"`
}

type TableReplicationInfoObservation struct {

	// The interval at which the source
	// materialized view is polled for updates. The default is 300000.
	ReplicationIntervalMs *float64 `json:"replicationIntervalMs,omitempty" tf:"replication_interval_ms,omitempty"`

	// The ID of the source dataset.
	SourceDatasetID *string `json:"sourceDatasetId,omitempty" tf:"source_dataset_id,omitempty"`

	// The ID of the source project.
	SourceProjectID *string `json:"sourceProjectId,omitempty" tf:"source_project_id,omitempty"`

	// The ID of the source materialized view.
	SourceTableID *string `json:"sourceTableId,omitempty" tf:"source_table_id,omitempty"`
}

type TableReplicationInfoParameters struct {

	// The interval at which the source
	// materialized view is polled for updates. The default is 300000.
	// +kubebuilder:validation:Optional
	ReplicationIntervalMs *float64 `json:"replicationIntervalMs,omitempty" tf:"replication_interval_ms,omitempty"`

	// The ID of the source dataset.
	// +kubebuilder:validation:Optional
	SourceDatasetID *string `json:"sourceDatasetId" tf:"source_dataset_id,omitempty"`

	// The ID of the source project.
	// +kubebuilder:validation:Optional
	SourceProjectID *string `json:"sourceProjectId" tf:"source_project_id,omitempty"`

	// The ID of the source materialized view.
	// +kubebuilder:validation:Optional
	SourceTableID *string `json:"sourceTableId" tf:"source_table_id,omitempty"`
}

type TableTimePartitioningInitParameters struct {

	// Number of milliseconds for which to keep the
	// storage for a partition.
	ExpirationMs *float64 `json:"expirationMs,omitempty" tf:"expiration_ms,omitempty"`

	// The field used to determine how to create a time-based
	// partition. If time-based partitioning is enabled without this value, the
	// table is partitioned based on the load time.
	Field *string `json:"field,omitempty" tf:"field,omitempty"`

	// If set to true, queries over this table
	// require a partition filter that can be used for partition elimination to be
	// specified. require_partition_filter is deprecated and will be removed in
	// a future major release. Use the top level field with the same name instead.
	RequirePartitionFilter *bool `json:"requirePartitionFilter,omitempty" tf:"require_partition_filter,omitempty"`

	// The supported types are DAY, HOUR, MONTH, and YEAR,
	// which will generate one partition per day, hour, month, and year, respectively.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type TableTimePartitioningObservation struct {

	// Number of milliseconds for which to keep the
	// storage for a partition.
	ExpirationMs *float64 `json:"expirationMs,omitempty" tf:"expiration_ms,omitempty"`

	// The field used to determine how to create a time-based
	// partition. If time-based partitioning is enabled without this value, the
	// table is partitioned based on the load time.
	Field *string `json:"field,omitempty" tf:"field,omitempty"`

	// If set to true, queries over this table
	// require a partition filter that can be used for partition elimination to be
	// specified. require_partition_filter is deprecated and will be removed in
	// a future major release. Use the top level field with the same name instead.
	RequirePartitionFilter *bool `json:"requirePartitionFilter,omitempty" tf:"require_partition_filter,omitempty"`

	// The supported types are DAY, HOUR, MONTH, and YEAR,
	// which will generate one partition per day, hour, month, and year, respectively.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type TableTimePartitioningParameters struct {

	// Number of milliseconds for which to keep the
	// storage for a partition.
	// +kubebuilder:validation:Optional
	ExpirationMs *float64 `json:"expirationMs,omitempty" tf:"expiration_ms,omitempty"`

	// The field used to determine how to create a time-based
	// partition. If time-based partitioning is enabled without this value, the
	// table is partitioned based on the load time.
	// +kubebuilder:validation:Optional
	Field *string `json:"field,omitempty" tf:"field,omitempty"`

	// If set to true, queries over this table
	// require a partition filter that can be used for partition elimination to be
	// specified. require_partition_filter is deprecated and will be removed in
	// a future major release. Use the top level field with the same name instead.
	// +kubebuilder:validation:Optional
	RequirePartitionFilter *bool `json:"requirePartitionFilter,omitempty" tf:"require_partition_filter,omitempty"`

	// The supported types are DAY, HOUR, MONTH, and YEAR,
	// which will generate one partition per day, hour, month, and year, respectively.
	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`
}

type TableViewInitParameters struct {

	// A query that BigQuery executes when the view is referenced.
	Query *string `json:"query,omitempty" tf:"query,omitempty"`

	// Specifies whether to use BigQuery's legacy SQL for this view.
	// The default value is true. If set to false, the view will use BigQuery's standard SQL.
	UseLegacySQL *bool `json:"useLegacySql,omitempty" tf:"use_legacy_sql,omitempty"`
}

type TableViewObservation struct {

	// A query that BigQuery executes when the view is referenced.
	Query *string `json:"query,omitempty" tf:"query,omitempty"`

	// Specifies whether to use BigQuery's legacy SQL for this view.
	// The default value is true. If set to false, the view will use BigQuery's standard SQL.
	UseLegacySQL *bool `json:"useLegacySql,omitempty" tf:"use_legacy_sql,omitempty"`
}

type TableViewParameters struct {

	// A query that BigQuery executes when the view is referenced.
	// +kubebuilder:validation:Optional
	Query *string `json:"query" tf:"query,omitempty"`

	// Specifies whether to use BigQuery's legacy SQL for this view.
	// The default value is true. If set to false, the view will use BigQuery's standard SQL.
	// +kubebuilder:validation:Optional
	UseLegacySQL *bool `json:"useLegacySql,omitempty" tf:"use_legacy_sql,omitempty"`
}

// TableSpec defines the desired state of Table
type TableSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     TableParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider TableInitParameters `json:"initProvider,omitempty"`
}

// TableStatus defines the observed state of Table.
type TableStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        TableObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status

// Table is the Schema for the Tables API. Creates a table resource in a dataset for Google BigQuery.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcp}
type Table struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              TableSpec   `json:"spec"`
	Status            TableStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// TableList contains a list of Tables
type TableList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Table `json:"items"`
}

// Repository type metadata.
var (
	Table_Kind             = "Table"
	Table_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Table_Kind}.String()
	Table_KindAPIVersion   = Table_Kind + "." + CRDGroupVersion.String()
	Table_GroupVersionKind = CRDGroupVersion.WithKind(Table_Kind)
)

func init() {
	SchemeBuilder.Register(&Table{}, &TableList{})
}
