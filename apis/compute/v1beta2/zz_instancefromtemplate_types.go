// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1beta2

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type BootDiskInitializeParamsInitParameters struct {
	Architecture *string `json:"architecture,omitempty" tf:"architecture,omitempty"`

	EnableConfidentialCompute *bool `json:"enableConfidentialCompute,omitempty" tf:"enable_confidential_compute,omitempty"`

	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	Labels map[string]string `json:"labels,omitempty" tf:"labels,omitempty"`

	ProvisionedIops *float64 `json:"provisionedIops,omitempty" tf:"provisioned_iops,omitempty"`

	ProvisionedThroughput *float64 `json:"provisionedThroughput,omitempty" tf:"provisioned_throughput,omitempty"`

	// +mapType=granular
	ResourceManagerTags map[string]*string `json:"resourceManagerTags,omitempty" tf:"resource_manager_tags,omitempty"`

	ResourcePolicies []*string `json:"resourcePolicies,omitempty" tf:"resource_policies,omitempty"`

	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`

	Snapshot *string `json:"snapshot,omitempty" tf:"snapshot,omitempty"`

	SourceImageEncryptionKey *BootDiskInitializeParamsSourceImageEncryptionKeyInitParameters `json:"sourceImageEncryptionKey,omitempty" tf:"source_image_encryption_key,omitempty"`

	SourceSnapshotEncryptionKey *BootDiskInitializeParamsSourceSnapshotEncryptionKeyInitParameters `json:"sourceSnapshotEncryptionKey,omitempty" tf:"source_snapshot_encryption_key,omitempty"`

	StoragePool *string `json:"storagePool,omitempty" tf:"storage_pool,omitempty"`

	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type BootDiskInitializeParamsObservation struct {
	Architecture *string `json:"architecture,omitempty" tf:"architecture,omitempty"`

	EnableConfidentialCompute *bool `json:"enableConfidentialCompute,omitempty" tf:"enable_confidential_compute,omitempty"`

	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	Labels map[string]string `json:"labels,omitempty" tf:"labels,omitempty"`

	ProvisionedIops *float64 `json:"provisionedIops,omitempty" tf:"provisioned_iops,omitempty"`

	ProvisionedThroughput *float64 `json:"provisionedThroughput,omitempty" tf:"provisioned_throughput,omitempty"`

	// +mapType=granular
	ResourceManagerTags map[string]*string `json:"resourceManagerTags,omitempty" tf:"resource_manager_tags,omitempty"`

	ResourcePolicies []*string `json:"resourcePolicies,omitempty" tf:"resource_policies,omitempty"`

	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`

	Snapshot *string `json:"snapshot,omitempty" tf:"snapshot,omitempty"`

	SourceImageEncryptionKey *BootDiskInitializeParamsSourceImageEncryptionKeyObservation `json:"sourceImageEncryptionKey,omitempty" tf:"source_image_encryption_key,omitempty"`

	SourceSnapshotEncryptionKey *BootDiskInitializeParamsSourceSnapshotEncryptionKeyObservation `json:"sourceSnapshotEncryptionKey,omitempty" tf:"source_snapshot_encryption_key,omitempty"`

	StoragePool *string `json:"storagePool,omitempty" tf:"storage_pool,omitempty"`

	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type BootDiskInitializeParamsParameters struct {

	// +kubebuilder:validation:Optional
	Architecture *string `json:"architecture,omitempty" tf:"architecture,omitempty"`

	// +kubebuilder:validation:Optional
	EnableConfidentialCompute *bool `json:"enableConfidentialCompute,omitempty" tf:"enable_confidential_compute,omitempty"`

	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// +kubebuilder:validation:Optional
	Labels map[string]string `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Optional
	ProvisionedIops *float64 `json:"provisionedIops,omitempty" tf:"provisioned_iops,omitempty"`

	// +kubebuilder:validation:Optional
	ProvisionedThroughput *float64 `json:"provisionedThroughput,omitempty" tf:"provisioned_throughput,omitempty"`

	// +kubebuilder:validation:Optional
	// +mapType=granular
	ResourceManagerTags map[string]*string `json:"resourceManagerTags,omitempty" tf:"resource_manager_tags,omitempty"`

	// +kubebuilder:validation:Optional
	ResourcePolicies []*string `json:"resourcePolicies,omitempty" tf:"resource_policies,omitempty"`

	// +kubebuilder:validation:Optional
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`

	// +kubebuilder:validation:Optional
	Snapshot *string `json:"snapshot,omitempty" tf:"snapshot,omitempty"`

	// +kubebuilder:validation:Optional
	SourceImageEncryptionKey *BootDiskInitializeParamsSourceImageEncryptionKeyParameters `json:"sourceImageEncryptionKey,omitempty" tf:"source_image_encryption_key,omitempty"`

	// +kubebuilder:validation:Optional
	SourceSnapshotEncryptionKey *BootDiskInitializeParamsSourceSnapshotEncryptionKeyParameters `json:"sourceSnapshotEncryptionKey,omitempty" tf:"source_snapshot_encryption_key,omitempty"`

	// +kubebuilder:validation:Optional
	StoragePool *string `json:"storagePool,omitempty" tf:"storage_pool,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type BootDiskInitializeParamsSourceImageEncryptionKeyInitParameters struct {
	KMSKeySelfLink *string `json:"kmsKeySelfLink,omitempty" tf:"kms_key_self_link,omitempty"`

	KMSKeyServiceAccount *string `json:"kmsKeyServiceAccount,omitempty" tf:"kms_key_service_account,omitempty"`

	RawKeySecretRef *v1.SecretKeySelector `json:"rawKeySecretRef,omitempty" tf:"-"`

	RsaEncryptedKeySecretRef *v1.SecretKeySelector `json:"rsaEncryptedKeySecretRef,omitempty" tf:"-"`
}

type BootDiskInitializeParamsSourceImageEncryptionKeyObservation struct {
	KMSKeySelfLink *string `json:"kmsKeySelfLink,omitempty" tf:"kms_key_self_link,omitempty"`

	KMSKeyServiceAccount *string `json:"kmsKeyServiceAccount,omitempty" tf:"kms_key_service_account,omitempty"`

	Sha256 *string `json:"sha256,omitempty" tf:"sha256,omitempty"`
}

type BootDiskInitializeParamsSourceImageEncryptionKeyParameters struct {

	// +kubebuilder:validation:Optional
	KMSKeySelfLink *string `json:"kmsKeySelfLink,omitempty" tf:"kms_key_self_link,omitempty"`

	// +kubebuilder:validation:Optional
	KMSKeyServiceAccount *string `json:"kmsKeyServiceAccount,omitempty" tf:"kms_key_service_account,omitempty"`

	// +kubebuilder:validation:Optional
	RawKeySecretRef *v1.SecretKeySelector `json:"rawKeySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	RsaEncryptedKeySecretRef *v1.SecretKeySelector `json:"rsaEncryptedKeySecretRef,omitempty" tf:"-"`
}

type BootDiskInitializeParamsSourceSnapshotEncryptionKeyInitParameters struct {
	KMSKeySelfLink *string `json:"kmsKeySelfLink,omitempty" tf:"kms_key_self_link,omitempty"`

	KMSKeyServiceAccount *string `json:"kmsKeyServiceAccount,omitempty" tf:"kms_key_service_account,omitempty"`

	RawKeySecretRef *v1.SecretKeySelector `json:"rawKeySecretRef,omitempty" tf:"-"`

	RsaEncryptedKeySecretRef *v1.SecretKeySelector `json:"rsaEncryptedKeySecretRef,omitempty" tf:"-"`
}

type BootDiskInitializeParamsSourceSnapshotEncryptionKeyObservation struct {
	KMSKeySelfLink *string `json:"kmsKeySelfLink,omitempty" tf:"kms_key_self_link,omitempty"`

	KMSKeyServiceAccount *string `json:"kmsKeyServiceAccount,omitempty" tf:"kms_key_service_account,omitempty"`

	Sha256 *string `json:"sha256,omitempty" tf:"sha256,omitempty"`
}

type BootDiskInitializeParamsSourceSnapshotEncryptionKeyParameters struct {

	// +kubebuilder:validation:Optional
	KMSKeySelfLink *string `json:"kmsKeySelfLink,omitempty" tf:"kms_key_self_link,omitempty"`

	// +kubebuilder:validation:Optional
	KMSKeyServiceAccount *string `json:"kmsKeyServiceAccount,omitempty" tf:"kms_key_service_account,omitempty"`

	// +kubebuilder:validation:Optional
	RawKeySecretRef *v1.SecretKeySelector `json:"rawKeySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	RsaEncryptedKeySecretRef *v1.SecretKeySelector `json:"rsaEncryptedKeySecretRef,omitempty" tf:"-"`
}

type InstanceFromTemplateAdvancedMachineFeaturesInitParameters struct {
	EnableNestedVirtualization *bool `json:"enableNestedVirtualization,omitempty" tf:"enable_nested_virtualization,omitempty"`

	EnableUefiNetworking *bool `json:"enableUefiNetworking,omitempty" tf:"enable_uefi_networking,omitempty"`

	PerformanceMonitoringUnit *string `json:"performanceMonitoringUnit,omitempty" tf:"performance_monitoring_unit,omitempty"`

	ThreadsPerCore *float64 `json:"threadsPerCore,omitempty" tf:"threads_per_core,omitempty"`

	TurboMode *string `json:"turboMode,omitempty" tf:"turbo_mode,omitempty"`

	VisibleCoreCount *float64 `json:"visibleCoreCount,omitempty" tf:"visible_core_count,omitempty"`
}

type InstanceFromTemplateAdvancedMachineFeaturesObservation struct {
	EnableNestedVirtualization *bool `json:"enableNestedVirtualization,omitempty" tf:"enable_nested_virtualization,omitempty"`

	EnableUefiNetworking *bool `json:"enableUefiNetworking,omitempty" tf:"enable_uefi_networking,omitempty"`

	PerformanceMonitoringUnit *string `json:"performanceMonitoringUnit,omitempty" tf:"performance_monitoring_unit,omitempty"`

	ThreadsPerCore *float64 `json:"threadsPerCore,omitempty" tf:"threads_per_core,omitempty"`

	TurboMode *string `json:"turboMode,omitempty" tf:"turbo_mode,omitempty"`

	VisibleCoreCount *float64 `json:"visibleCoreCount,omitempty" tf:"visible_core_count,omitempty"`
}

type InstanceFromTemplateAdvancedMachineFeaturesParameters struct {

	// +kubebuilder:validation:Optional
	EnableNestedVirtualization *bool `json:"enableNestedVirtualization,omitempty" tf:"enable_nested_virtualization,omitempty"`

	// +kubebuilder:validation:Optional
	EnableUefiNetworking *bool `json:"enableUefiNetworking,omitempty" tf:"enable_uefi_networking,omitempty"`

	// +kubebuilder:validation:Optional
	PerformanceMonitoringUnit *string `json:"performanceMonitoringUnit,omitempty" tf:"performance_monitoring_unit,omitempty"`

	// +kubebuilder:validation:Optional
	ThreadsPerCore *float64 `json:"threadsPerCore,omitempty" tf:"threads_per_core,omitempty"`

	// +kubebuilder:validation:Optional
	TurboMode *string `json:"turboMode,omitempty" tf:"turbo_mode,omitempty"`

	// +kubebuilder:validation:Optional
	VisibleCoreCount *float64 `json:"visibleCoreCount,omitempty" tf:"visible_core_count,omitempty"`
}

type InstanceFromTemplateAttachedDiskInitParameters struct {

	// A unique name for the resource, required by GCE.
	// Changing this forces a new resource to be created.
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	DiskEncryptionKeyRawSecretRef *v1.SecretKeySelector `json:"diskEncryptionKeyRawSecretRef,omitempty" tf:"-"`

	DiskEncryptionKeyRsaSecretRef *v1.SecretKeySelector `json:"diskEncryptionKeyRsaSecretRef,omitempty" tf:"-"`

	DiskEncryptionServiceAccount *string `json:"diskEncryptionServiceAccount,omitempty" tf:"disk_encryption_service_account,omitempty"`

	ForceAttach *bool `json:"forceAttach,omitempty" tf:"force_attach,omitempty"`

	KMSKeySelfLink *string `json:"kmsKeySelfLink,omitempty" tf:"kms_key_self_link,omitempty"`

	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	Source *string `json:"source,omitempty" tf:"source,omitempty"`
}

type InstanceFromTemplateAttachedDiskObservation struct {

	// A unique name for the resource, required by GCE.
	// Changing this forces a new resource to be created.
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	DiskEncryptionKeySha256 *string `json:"diskEncryptionKeySha256,omitempty" tf:"disk_encryption_key_sha256,omitempty"`

	DiskEncryptionServiceAccount *string `json:"diskEncryptionServiceAccount,omitempty" tf:"disk_encryption_service_account,omitempty"`

	ForceAttach *bool `json:"forceAttach,omitempty" tf:"force_attach,omitempty"`

	KMSKeySelfLink *string `json:"kmsKeySelfLink,omitempty" tf:"kms_key_self_link,omitempty"`

	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	Source *string `json:"source,omitempty" tf:"source,omitempty"`
}

type InstanceFromTemplateAttachedDiskParameters struct {

	// A unique name for the resource, required by GCE.
	// Changing this forces a new resource to be created.
	// +kubebuilder:validation:Optional
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	// +kubebuilder:validation:Optional
	DiskEncryptionKeyRawSecretRef *v1.SecretKeySelector `json:"diskEncryptionKeyRawSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	DiskEncryptionKeyRsaSecretRef *v1.SecretKeySelector `json:"diskEncryptionKeyRsaSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	DiskEncryptionServiceAccount *string `json:"diskEncryptionServiceAccount,omitempty" tf:"disk_encryption_service_account,omitempty"`

	// +kubebuilder:validation:Optional
	ForceAttach *bool `json:"forceAttach,omitempty" tf:"force_attach,omitempty"`

	// +kubebuilder:validation:Optional
	KMSKeySelfLink *string `json:"kmsKeySelfLink,omitempty" tf:"kms_key_self_link,omitempty"`

	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// +kubebuilder:validation:Optional
	Source *string `json:"source" tf:"source,omitempty"`
}

type InstanceFromTemplateBootDiskInitParameters struct {

	// Default is 6 minutes.
	AutoDelete *bool `json:"autoDelete,omitempty" tf:"auto_delete,omitempty"`

	// A unique name for the resource, required by GCE.
	// Changing this forces a new resource to be created.
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	DiskEncryptionKeyRawSecretRef *v1.SecretKeySelector `json:"diskEncryptionKeyRawSecretRef,omitempty" tf:"-"`

	DiskEncryptionKeyRsaSecretRef *v1.SecretKeySelector `json:"diskEncryptionKeyRsaSecretRef,omitempty" tf:"-"`

	DiskEncryptionServiceAccount *string `json:"diskEncryptionServiceAccount,omitempty" tf:"disk_encryption_service_account,omitempty"`

	ForceAttach *bool `json:"forceAttach,omitempty" tf:"force_attach,omitempty"`

	GuestOsFeatures []*string `json:"guestOsFeatures,omitempty" tf:"guest_os_features,omitempty"`

	InitializeParams *BootDiskInitializeParamsInitParameters `json:"initializeParams,omitempty" tf:"initialize_params,omitempty"`

	Interface *string `json:"interface,omitempty" tf:"interface,omitempty"`

	KMSKeySelfLink *string `json:"kmsKeySelfLink,omitempty" tf:"kms_key_self_link,omitempty"`

	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	Source *string `json:"source,omitempty" tf:"source,omitempty"`
}

type InstanceFromTemplateBootDiskObservation struct {

	// Default is 6 minutes.
	AutoDelete *bool `json:"autoDelete,omitempty" tf:"auto_delete,omitempty"`

	// A unique name for the resource, required by GCE.
	// Changing this forces a new resource to be created.
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	DiskEncryptionKeySha256 *string `json:"diskEncryptionKeySha256,omitempty" tf:"disk_encryption_key_sha256,omitempty"`

	DiskEncryptionServiceAccount *string `json:"diskEncryptionServiceAccount,omitempty" tf:"disk_encryption_service_account,omitempty"`

	ForceAttach *bool `json:"forceAttach,omitempty" tf:"force_attach,omitempty"`

	GuestOsFeatures []*string `json:"guestOsFeatures,omitempty" tf:"guest_os_features,omitempty"`

	InitializeParams *BootDiskInitializeParamsObservation `json:"initializeParams,omitempty" tf:"initialize_params,omitempty"`

	Interface *string `json:"interface,omitempty" tf:"interface,omitempty"`

	KMSKeySelfLink *string `json:"kmsKeySelfLink,omitempty" tf:"kms_key_self_link,omitempty"`

	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	Source *string `json:"source,omitempty" tf:"source,omitempty"`
}

type InstanceFromTemplateBootDiskParameters struct {

	// Default is 6 minutes.
	// +kubebuilder:validation:Optional
	AutoDelete *bool `json:"autoDelete,omitempty" tf:"auto_delete,omitempty"`

	// A unique name for the resource, required by GCE.
	// Changing this forces a new resource to be created.
	// +kubebuilder:validation:Optional
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	// +kubebuilder:validation:Optional
	DiskEncryptionKeyRawSecretRef *v1.SecretKeySelector `json:"diskEncryptionKeyRawSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	DiskEncryptionKeyRsaSecretRef *v1.SecretKeySelector `json:"diskEncryptionKeyRsaSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	DiskEncryptionServiceAccount *string `json:"diskEncryptionServiceAccount,omitempty" tf:"disk_encryption_service_account,omitempty"`

	// +kubebuilder:validation:Optional
	ForceAttach *bool `json:"forceAttach,omitempty" tf:"force_attach,omitempty"`

	// +kubebuilder:validation:Optional
	GuestOsFeatures []*string `json:"guestOsFeatures,omitempty" tf:"guest_os_features,omitempty"`

	// +kubebuilder:validation:Optional
	InitializeParams *BootDiskInitializeParamsParameters `json:"initializeParams,omitempty" tf:"initialize_params,omitempty"`

	// +kubebuilder:validation:Optional
	Interface *string `json:"interface,omitempty" tf:"interface,omitempty"`

	// +kubebuilder:validation:Optional
	KMSKeySelfLink *string `json:"kmsKeySelfLink,omitempty" tf:"kms_key_self_link,omitempty"`

	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// +kubebuilder:validation:Optional
	Source *string `json:"source,omitempty" tf:"source,omitempty"`
}

type InstanceFromTemplateConfidentialInstanceConfigInitParameters struct {
	ConfidentialInstanceType *string `json:"confidentialInstanceType,omitempty" tf:"confidential_instance_type,omitempty"`

	EnableConfidentialCompute *bool `json:"enableConfidentialCompute,omitempty" tf:"enable_confidential_compute,omitempty"`
}

type InstanceFromTemplateConfidentialInstanceConfigObservation struct {
	ConfidentialInstanceType *string `json:"confidentialInstanceType,omitempty" tf:"confidential_instance_type,omitempty"`

	EnableConfidentialCompute *bool `json:"enableConfidentialCompute,omitempty" tf:"enable_confidential_compute,omitempty"`
}

type InstanceFromTemplateConfidentialInstanceConfigParameters struct {

	// +kubebuilder:validation:Optional
	ConfidentialInstanceType *string `json:"confidentialInstanceType,omitempty" tf:"confidential_instance_type,omitempty"`

	// +kubebuilder:validation:Optional
	EnableConfidentialCompute *bool `json:"enableConfidentialCompute,omitempty" tf:"enable_confidential_compute,omitempty"`
}

type InstanceFromTemplateGuestAcceleratorInitParameters struct {
	Count *float64 `json:"count,omitempty" tf:"count,omitempty"`

	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type InstanceFromTemplateGuestAcceleratorObservation struct {
	Count *float64 `json:"count,omitempty" tf:"count,omitempty"`

	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type InstanceFromTemplateGuestAcceleratorParameters struct {

	// +kubebuilder:validation:Optional
	Count *float64 `json:"count" tf:"count,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`
}

type InstanceFromTemplateInitParameters struct {
	AdvancedMachineFeatures *InstanceFromTemplateAdvancedMachineFeaturesInitParameters `json:"advancedMachineFeatures,omitempty" tf:"advanced_machine_features,omitempty"`

	// Default is 6 minutes.
	AllowStoppingForUpdate *bool `json:"allowStoppingForUpdate,omitempty" tf:"allow_stopping_for_update,omitempty"`

	AttachedDisk []InstanceFromTemplateAttachedDiskInitParameters `json:"attachedDisk,omitempty" tf:"attached_disk,omitempty"`

	BootDisk *InstanceFromTemplateBootDiskInitParameters `json:"bootDisk,omitempty" tf:"boot_disk,omitempty"`

	CanIPForward *bool `json:"canIpForward,omitempty" tf:"can_ip_forward,omitempty"`

	ConfidentialInstanceConfig *InstanceFromTemplateConfidentialInstanceConfigInitParameters `json:"confidentialInstanceConfig,omitempty" tf:"confidential_instance_config,omitempty"`

	DeletionProtection *bool `json:"deletionProtection,omitempty" tf:"deletion_protection,omitempty"`

	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	DesiredStatus *string `json:"desiredStatus,omitempty" tf:"desired_status,omitempty"`

	EnableDisplay *bool `json:"enableDisplay,omitempty" tf:"enable_display,omitempty"`

	GuestAccelerator []InstanceFromTemplateGuestAcceleratorInitParameters `json:"guestAccelerator,omitempty" tf:"guest_accelerator,omitempty"`

	// A unique name for the resource, required by GCE.
	// Changing this forces a new resource to be created.
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	InstanceEncryptionKey *InstanceFromTemplateInstanceEncryptionKeyInitParameters `json:"instanceEncryptionKey,omitempty" tf:"instance_encryption_key,omitempty"`

	KeyRevocationActionType *string `json:"keyRevocationActionType,omitempty" tf:"key_revocation_action_type,omitempty"`

	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	MachineType *string `json:"machineType,omitempty" tf:"machine_type,omitempty"`

	Metadata map[string]string `json:"metadata,omitempty" tf:"metadata,omitempty"`

	MetadataStartupScript *string `json:"metadataStartupScript,omitempty" tf:"metadata_startup_script,omitempty"`

	MinCPUPlatform *string `json:"minCpuPlatform,omitempty" tf:"min_cpu_platform,omitempty"`

	// A unique name for the resource, required by GCE.
	// Changing this forces a new resource to be created.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	NetworkInterface []InstanceFromTemplateNetworkInterfaceInitParameters `json:"networkInterface,omitempty" tf:"network_interface,omitempty"`

	NetworkPerformanceConfig *InstanceFromTemplateNetworkPerformanceConfigInitParameters `json:"networkPerformanceConfig,omitempty" tf:"network_performance_config,omitempty"`

	Params *InstanceFromTemplateParamsInitParameters `json:"params,omitempty" tf:"params,omitempty"`

	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	ReservationAffinity *InstanceFromTemplateReservationAffinityInitParameters `json:"reservationAffinity,omitempty" tf:"reservation_affinity,omitempty"`

	ResourcePolicies []*string `json:"resourcePolicies,omitempty" tf:"resource_policies,omitempty"`

	Scheduling *InstanceFromTemplateSchedulingInitParameters `json:"scheduling,omitempty" tf:"scheduling,omitempty"`

	ScratchDisk []InstanceFromTemplateScratchDiskInitParameters `json:"scratchDisk,omitempty" tf:"scratch_disk,omitempty"`

	ServiceAccount *InstanceFromTemplateServiceAccountInitParameters `json:"serviceAccount,omitempty" tf:"service_account,omitempty"`

	ShieldedInstanceConfig *InstanceFromTemplateShieldedInstanceConfigInitParameters `json:"shieldedInstanceConfig,omitempty" tf:"shielded_instance_config,omitempty"`

	// Name or self link of an instance
	// template to create the instance based on. It is recommended to reference
	// instance templates through their unique id (self_link_unique attribute).
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta2.InstanceTemplate
	// +crossplane:generate:reference:extractor=github.com/upbound/provider-gcp/config/common.ExtractResourceID()
	SourceInstanceTemplate *string `json:"sourceInstanceTemplate,omitempty" tf:"source_instance_template,omitempty"`

	// Reference to a InstanceTemplate in compute to populate sourceInstanceTemplate.
	// +kubebuilder:validation:Optional
	SourceInstanceTemplateRef *v1.Reference `json:"sourceInstanceTemplateRef,omitempty" tf:"-"`

	// Selector for a InstanceTemplate in compute to populate sourceInstanceTemplate.
	// +kubebuilder:validation:Optional
	SourceInstanceTemplateSelector *v1.Selector `json:"sourceInstanceTemplateSelector,omitempty" tf:"-"`

	// +listType=set
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The zone that the machine should be created in. If not
	// set, the provider zone is used.
	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type InstanceFromTemplateInstanceEncryptionKeyInitParameters struct {
	KMSKeySelfLink *string `json:"kmsKeySelfLink,omitempty" tf:"kms_key_self_link,omitempty"`

	KMSKeyServiceAccount *string `json:"kmsKeyServiceAccount,omitempty" tf:"kms_key_service_account,omitempty"`
}

type InstanceFromTemplateInstanceEncryptionKeyObservation struct {
	KMSKeySelfLink *string `json:"kmsKeySelfLink,omitempty" tf:"kms_key_self_link,omitempty"`

	KMSKeyServiceAccount *string `json:"kmsKeyServiceAccount,omitempty" tf:"kms_key_service_account,omitempty"`

	Sha256 *string `json:"sha256,omitempty" tf:"sha256,omitempty"`
}

type InstanceFromTemplateInstanceEncryptionKeyParameters struct {

	// +kubebuilder:validation:Optional
	KMSKeySelfLink *string `json:"kmsKeySelfLink,omitempty" tf:"kms_key_self_link,omitempty"`

	// +kubebuilder:validation:Optional
	KMSKeyServiceAccount *string `json:"kmsKeyServiceAccount,omitempty" tf:"kms_key_service_account,omitempty"`
}

type InstanceFromTemplateNetworkInterfaceInitParameters struct {
	AccessConfig []NetworkInterfaceAccessConfigInitParameters `json:"accessConfig,omitempty" tf:"access_config,omitempty"`

	AliasIPRange []NetworkInterfaceAliasIPRangeInitParameters `json:"aliasIpRange,omitempty" tf:"alias_ip_range,omitempty"`

	IPv6AccessConfig []NetworkInterfaceIPv6AccessConfigInitParameters `json:"ipv6AccessConfig,omitempty" tf:"ipv6_access_config,omitempty"`

	IPv6Address *string `json:"ipv6Address,omitempty" tf:"ipv6_address,omitempty"`

	InternalIPv6PrefixLength *float64 `json:"internalIpv6PrefixLength,omitempty" tf:"internal_ipv6_prefix_length,omitempty"`

	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.Network
	Network *string `json:"network,omitempty" tf:"network,omitempty"`

	NetworkAttachment *string `json:"networkAttachment,omitempty" tf:"network_attachment,omitempty"`

	NetworkIP *string `json:"networkIp,omitempty" tf:"network_ip,omitempty"`

	// Reference to a Network in compute to populate network.
	// +kubebuilder:validation:Optional
	NetworkRef *v1.Reference `json:"networkRef,omitempty" tf:"-"`

	// Selector for a Network in compute to populate network.
	// +kubebuilder:validation:Optional
	NetworkSelector *v1.Selector `json:"networkSelector,omitempty" tf:"-"`

	NicType *string `json:"nicType,omitempty" tf:"nic_type,omitempty"`

	QueueCount *float64 `json:"queueCount,omitempty" tf:"queue_count,omitempty"`

	StackType *string `json:"stackType,omitempty" tf:"stack_type,omitempty"`

	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta2.Subnetwork
	Subnetwork *string `json:"subnetwork,omitempty" tf:"subnetwork,omitempty"`

	SubnetworkProject *string `json:"subnetworkProject,omitempty" tf:"subnetwork_project,omitempty"`

	// Reference to a Subnetwork in compute to populate subnetwork.
	// +kubebuilder:validation:Optional
	SubnetworkRef *v1.Reference `json:"subnetworkRef,omitempty" tf:"-"`

	// Selector for a Subnetwork in compute to populate subnetwork.
	// +kubebuilder:validation:Optional
	SubnetworkSelector *v1.Selector `json:"subnetworkSelector,omitempty" tf:"-"`
}

type InstanceFromTemplateNetworkInterfaceObservation struct {
	AccessConfig []NetworkInterfaceAccessConfigObservation `json:"accessConfig,omitempty" tf:"access_config,omitempty"`

	AliasIPRange []NetworkInterfaceAliasIPRangeObservation `json:"aliasIpRange,omitempty" tf:"alias_ip_range,omitempty"`

	IPv6AccessConfig []NetworkInterfaceIPv6AccessConfigObservation `json:"ipv6AccessConfig,omitempty" tf:"ipv6_access_config,omitempty"`

	IPv6AccessType *string `json:"ipv6AccessType,omitempty" tf:"ipv6_access_type,omitempty"`

	IPv6Address *string `json:"ipv6Address,omitempty" tf:"ipv6_address,omitempty"`

	InternalIPv6PrefixLength *float64 `json:"internalIpv6PrefixLength,omitempty" tf:"internal_ipv6_prefix_length,omitempty"`

	// A unique name for the resource, required by GCE.
	// Changing this forces a new resource to be created.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	Network *string `json:"network,omitempty" tf:"network,omitempty"`

	NetworkAttachment *string `json:"networkAttachment,omitempty" tf:"network_attachment,omitempty"`

	NetworkIP *string `json:"networkIp,omitempty" tf:"network_ip,omitempty"`

	NicType *string `json:"nicType,omitempty" tf:"nic_type,omitempty"`

	QueueCount *float64 `json:"queueCount,omitempty" tf:"queue_count,omitempty"`

	StackType *string `json:"stackType,omitempty" tf:"stack_type,omitempty"`

	Subnetwork *string `json:"subnetwork,omitempty" tf:"subnetwork,omitempty"`

	SubnetworkProject *string `json:"subnetworkProject,omitempty" tf:"subnetwork_project,omitempty"`
}

type InstanceFromTemplateNetworkInterfaceParameters struct {

	// +kubebuilder:validation:Optional
	AccessConfig []NetworkInterfaceAccessConfigParameters `json:"accessConfig,omitempty" tf:"access_config,omitempty"`

	// +kubebuilder:validation:Optional
	AliasIPRange []NetworkInterfaceAliasIPRangeParameters `json:"aliasIpRange,omitempty" tf:"alias_ip_range,omitempty"`

	// +kubebuilder:validation:Optional
	IPv6AccessConfig []NetworkInterfaceIPv6AccessConfigParameters `json:"ipv6AccessConfig,omitempty" tf:"ipv6_access_config,omitempty"`

	// +kubebuilder:validation:Optional
	IPv6Address *string `json:"ipv6Address,omitempty" tf:"ipv6_address,omitempty"`

	// +kubebuilder:validation:Optional
	InternalIPv6PrefixLength *float64 `json:"internalIpv6PrefixLength,omitempty" tf:"internal_ipv6_prefix_length,omitempty"`

	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.Network
	// +kubebuilder:validation:Optional
	Network *string `json:"network,omitempty" tf:"network,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkAttachment *string `json:"networkAttachment,omitempty" tf:"network_attachment,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkIP *string `json:"networkIp,omitempty" tf:"network_ip,omitempty"`

	// Reference to a Network in compute to populate network.
	// +kubebuilder:validation:Optional
	NetworkRef *v1.Reference `json:"networkRef,omitempty" tf:"-"`

	// Selector for a Network in compute to populate network.
	// +kubebuilder:validation:Optional
	NetworkSelector *v1.Selector `json:"networkSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	NicType *string `json:"nicType,omitempty" tf:"nic_type,omitempty"`

	// +kubebuilder:validation:Optional
	QueueCount *float64 `json:"queueCount,omitempty" tf:"queue_count,omitempty"`

	// +kubebuilder:validation:Optional
	StackType *string `json:"stackType,omitempty" tf:"stack_type,omitempty"`

	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta2.Subnetwork
	// +kubebuilder:validation:Optional
	Subnetwork *string `json:"subnetwork,omitempty" tf:"subnetwork,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetworkProject *string `json:"subnetworkProject,omitempty" tf:"subnetwork_project,omitempty"`

	// Reference to a Subnetwork in compute to populate subnetwork.
	// +kubebuilder:validation:Optional
	SubnetworkRef *v1.Reference `json:"subnetworkRef,omitempty" tf:"-"`

	// Selector for a Subnetwork in compute to populate subnetwork.
	// +kubebuilder:validation:Optional
	SubnetworkSelector *v1.Selector `json:"subnetworkSelector,omitempty" tf:"-"`
}

type InstanceFromTemplateNetworkPerformanceConfigInitParameters struct {
	TotalEgressBandwidthTier *string `json:"totalEgressBandwidthTier,omitempty" tf:"total_egress_bandwidth_tier,omitempty"`
}

type InstanceFromTemplateNetworkPerformanceConfigObservation struct {
	TotalEgressBandwidthTier *string `json:"totalEgressBandwidthTier,omitempty" tf:"total_egress_bandwidth_tier,omitempty"`
}

type InstanceFromTemplateNetworkPerformanceConfigParameters struct {

	// +kubebuilder:validation:Optional
	TotalEgressBandwidthTier *string `json:"totalEgressBandwidthTier" tf:"total_egress_bandwidth_tier,omitempty"`
}

type InstanceFromTemplateObservation struct {
	AdvancedMachineFeatures *InstanceFromTemplateAdvancedMachineFeaturesObservation `json:"advancedMachineFeatures,omitempty" tf:"advanced_machine_features,omitempty"`

	// Default is 6 minutes.
	AllowStoppingForUpdate *bool `json:"allowStoppingForUpdate,omitempty" tf:"allow_stopping_for_update,omitempty"`

	AttachedDisk []InstanceFromTemplateAttachedDiskObservation `json:"attachedDisk,omitempty" tf:"attached_disk,omitempty"`

	BootDisk *InstanceFromTemplateBootDiskObservation `json:"bootDisk,omitempty" tf:"boot_disk,omitempty"`

	CPUPlatform *string `json:"cpuPlatform,omitempty" tf:"cpu_platform,omitempty"`

	CanIPForward *bool `json:"canIpForward,omitempty" tf:"can_ip_forward,omitempty"`

	ConfidentialInstanceConfig *InstanceFromTemplateConfidentialInstanceConfigObservation `json:"confidentialInstanceConfig,omitempty" tf:"confidential_instance_config,omitempty"`

	CreationTimestamp *string `json:"creationTimestamp,omitempty" tf:"creation_timestamp,omitempty"`

	CurrentStatus *string `json:"currentStatus,omitempty" tf:"current_status,omitempty"`

	DeletionProtection *bool `json:"deletionProtection,omitempty" tf:"deletion_protection,omitempty"`

	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	DesiredStatus *string `json:"desiredStatus,omitempty" tf:"desired_status,omitempty"`

	// +mapType=granular
	EffectiveLabels map[string]*string `json:"effectiveLabels,omitempty" tf:"effective_labels,omitempty"`

	EnableDisplay *bool `json:"enableDisplay,omitempty" tf:"enable_display,omitempty"`

	GuestAccelerator []InstanceFromTemplateGuestAcceleratorObservation `json:"guestAccelerator,omitempty" tf:"guest_accelerator,omitempty"`

	// A unique name for the resource, required by GCE.
	// Changing this forces a new resource to be created.
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	InstanceEncryptionKey *InstanceFromTemplateInstanceEncryptionKeyObservation `json:"instanceEncryptionKey,omitempty" tf:"instance_encryption_key,omitempty"`

	InstanceID *string `json:"instanceId,omitempty" tf:"instance_id,omitempty"`

	KeyRevocationActionType *string `json:"keyRevocationActionType,omitempty" tf:"key_revocation_action_type,omitempty"`

	LabelFingerprint *string `json:"labelFingerprint,omitempty" tf:"label_fingerprint,omitempty"`

	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	MachineType *string `json:"machineType,omitempty" tf:"machine_type,omitempty"`

	Metadata map[string]string `json:"metadata,omitempty" tf:"metadata,omitempty"`

	MetadataFingerprint *string `json:"metadataFingerprint,omitempty" tf:"metadata_fingerprint,omitempty"`

	MetadataStartupScript *string `json:"metadataStartupScript,omitempty" tf:"metadata_startup_script,omitempty"`

	MinCPUPlatform *string `json:"minCpuPlatform,omitempty" tf:"min_cpu_platform,omitempty"`

	// A unique name for the resource, required by GCE.
	// Changing this forces a new resource to be created.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	NetworkInterface []InstanceFromTemplateNetworkInterfaceObservation `json:"networkInterface,omitempty" tf:"network_interface,omitempty"`

	NetworkPerformanceConfig *InstanceFromTemplateNetworkPerformanceConfigObservation `json:"networkPerformanceConfig,omitempty" tf:"network_performance_config,omitempty"`

	Params *InstanceFromTemplateParamsObservation `json:"params,omitempty" tf:"params,omitempty"`

	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	ReservationAffinity *InstanceFromTemplateReservationAffinityObservation `json:"reservationAffinity,omitempty" tf:"reservation_affinity,omitempty"`

	ResourcePolicies []*string `json:"resourcePolicies,omitempty" tf:"resource_policies,omitempty"`

	Scheduling *InstanceFromTemplateSchedulingObservation `json:"scheduling,omitempty" tf:"scheduling,omitempty"`

	ScratchDisk []InstanceFromTemplateScratchDiskObservation `json:"scratchDisk,omitempty" tf:"scratch_disk,omitempty"`

	SelfLink *string `json:"selfLink,omitempty" tf:"self_link,omitempty"`

	ServiceAccount *InstanceFromTemplateServiceAccountObservation `json:"serviceAccount,omitempty" tf:"service_account,omitempty"`

	ShieldedInstanceConfig *InstanceFromTemplateShieldedInstanceConfigObservation `json:"shieldedInstanceConfig,omitempty" tf:"shielded_instance_config,omitempty"`

	// Name or self link of an instance
	// template to create the instance based on. It is recommended to reference
	// instance templates through their unique id (self_link_unique attribute).
	SourceInstanceTemplate *string `json:"sourceInstanceTemplate,omitempty" tf:"source_instance_template,omitempty"`

	// +listType=set
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	TagsFingerprint *string `json:"tagsFingerprint,omitempty" tf:"tags_fingerprint,omitempty"`

	// +mapType=granular
	TerraformLabels map[string]*string `json:"terraformLabels,omitempty" tf:"terraform_labels,omitempty"`

	// The zone that the machine should be created in. If not
	// set, the provider zone is used.
	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type InstanceFromTemplateParameters struct {

	// +kubebuilder:validation:Optional
	AdvancedMachineFeatures *InstanceFromTemplateAdvancedMachineFeaturesParameters `json:"advancedMachineFeatures,omitempty" tf:"advanced_machine_features,omitempty"`

	// Default is 6 minutes.
	// +kubebuilder:validation:Optional
	AllowStoppingForUpdate *bool `json:"allowStoppingForUpdate,omitempty" tf:"allow_stopping_for_update,omitempty"`

	// +kubebuilder:validation:Optional
	AttachedDisk []InstanceFromTemplateAttachedDiskParameters `json:"attachedDisk,omitempty" tf:"attached_disk,omitempty"`

	// +kubebuilder:validation:Optional
	BootDisk *InstanceFromTemplateBootDiskParameters `json:"bootDisk,omitempty" tf:"boot_disk,omitempty"`

	// +kubebuilder:validation:Optional
	CanIPForward *bool `json:"canIpForward,omitempty" tf:"can_ip_forward,omitempty"`

	// +kubebuilder:validation:Optional
	ConfidentialInstanceConfig *InstanceFromTemplateConfidentialInstanceConfigParameters `json:"confidentialInstanceConfig,omitempty" tf:"confidential_instance_config,omitempty"`

	// +kubebuilder:validation:Optional
	DeletionProtection *bool `json:"deletionProtection,omitempty" tf:"deletion_protection,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	DesiredStatus *string `json:"desiredStatus,omitempty" tf:"desired_status,omitempty"`

	// +kubebuilder:validation:Optional
	EnableDisplay *bool `json:"enableDisplay,omitempty" tf:"enable_display,omitempty"`

	// +kubebuilder:validation:Optional
	GuestAccelerator []InstanceFromTemplateGuestAcceleratorParameters `json:"guestAccelerator,omitempty" tf:"guest_accelerator,omitempty"`

	// A unique name for the resource, required by GCE.
	// Changing this forces a new resource to be created.
	// +kubebuilder:validation:Optional
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// +kubebuilder:validation:Optional
	InstanceEncryptionKey *InstanceFromTemplateInstanceEncryptionKeyParameters `json:"instanceEncryptionKey,omitempty" tf:"instance_encryption_key,omitempty"`

	// +kubebuilder:validation:Optional
	KeyRevocationActionType *string `json:"keyRevocationActionType,omitempty" tf:"key_revocation_action_type,omitempty"`

	// +kubebuilder:validation:Optional
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Optional
	MachineType *string `json:"machineType,omitempty" tf:"machine_type,omitempty"`

	// +kubebuilder:validation:Optional
	Metadata map[string]string `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// +kubebuilder:validation:Optional
	MetadataStartupScript *string `json:"metadataStartupScript,omitempty" tf:"metadata_startup_script,omitempty"`

	// +kubebuilder:validation:Optional
	MinCPUPlatform *string `json:"minCpuPlatform,omitempty" tf:"min_cpu_platform,omitempty"`

	// A unique name for the resource, required by GCE.
	// Changing this forces a new resource to be created.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkInterface []InstanceFromTemplateNetworkInterfaceParameters `json:"networkInterface,omitempty" tf:"network_interface,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkPerformanceConfig *InstanceFromTemplateNetworkPerformanceConfigParameters `json:"networkPerformanceConfig,omitempty" tf:"network_performance_config,omitempty"`

	// +kubebuilder:validation:Optional
	Params *InstanceFromTemplateParamsParameters `json:"params,omitempty" tf:"params,omitempty"`

	// +kubebuilder:validation:Optional
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// +kubebuilder:validation:Optional
	ReservationAffinity *InstanceFromTemplateReservationAffinityParameters `json:"reservationAffinity,omitempty" tf:"reservation_affinity,omitempty"`

	// +kubebuilder:validation:Optional
	ResourcePolicies []*string `json:"resourcePolicies,omitempty" tf:"resource_policies,omitempty"`

	// +kubebuilder:validation:Optional
	Scheduling *InstanceFromTemplateSchedulingParameters `json:"scheduling,omitempty" tf:"scheduling,omitempty"`

	// +kubebuilder:validation:Optional
	ScratchDisk []InstanceFromTemplateScratchDiskParameters `json:"scratchDisk,omitempty" tf:"scratch_disk,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceAccount *InstanceFromTemplateServiceAccountParameters `json:"serviceAccount,omitempty" tf:"service_account,omitempty"`

	// +kubebuilder:validation:Optional
	ShieldedInstanceConfig *InstanceFromTemplateShieldedInstanceConfigParameters `json:"shieldedInstanceConfig,omitempty" tf:"shielded_instance_config,omitempty"`

	// Name or self link of an instance
	// template to create the instance based on. It is recommended to reference
	// instance templates through their unique id (self_link_unique attribute).
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta2.InstanceTemplate
	// +crossplane:generate:reference:extractor=github.com/upbound/provider-gcp/config/common.ExtractResourceID()
	// +kubebuilder:validation:Optional
	SourceInstanceTemplate *string `json:"sourceInstanceTemplate,omitempty" tf:"source_instance_template,omitempty"`

	// Reference to a InstanceTemplate in compute to populate sourceInstanceTemplate.
	// +kubebuilder:validation:Optional
	SourceInstanceTemplateRef *v1.Reference `json:"sourceInstanceTemplateRef,omitempty" tf:"-"`

	// Selector for a InstanceTemplate in compute to populate sourceInstanceTemplate.
	// +kubebuilder:validation:Optional
	SourceInstanceTemplateSelector *v1.Selector `json:"sourceInstanceTemplateSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	// +listType=set
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The zone that the machine should be created in. If not
	// set, the provider zone is used.
	// +kubebuilder:validation:Optional
	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type InstanceFromTemplateParamsInitParameters struct {

	// +mapType=granular
	ResourceManagerTags map[string]*string `json:"resourceManagerTags,omitempty" tf:"resource_manager_tags,omitempty"`
}

type InstanceFromTemplateParamsObservation struct {

	// +mapType=granular
	ResourceManagerTags map[string]*string `json:"resourceManagerTags,omitempty" tf:"resource_manager_tags,omitempty"`
}

type InstanceFromTemplateParamsParameters struct {

	// +kubebuilder:validation:Optional
	// +mapType=granular
	ResourceManagerTags map[string]*string `json:"resourceManagerTags,omitempty" tf:"resource_manager_tags,omitempty"`
}

type InstanceFromTemplateReservationAffinityInitParameters struct {
	SpecificReservation *ReservationAffinitySpecificReservationInitParameters `json:"specificReservation,omitempty" tf:"specific_reservation,omitempty"`

	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type InstanceFromTemplateReservationAffinityObservation struct {
	SpecificReservation *ReservationAffinitySpecificReservationObservation `json:"specificReservation,omitempty" tf:"specific_reservation,omitempty"`

	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type InstanceFromTemplateReservationAffinityParameters struct {

	// +kubebuilder:validation:Optional
	SpecificReservation *ReservationAffinitySpecificReservationParameters `json:"specificReservation,omitempty" tf:"specific_reservation,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`
}

type InstanceFromTemplateSchedulingInitParameters struct {
	AutomaticRestart *bool `json:"automaticRestart,omitempty" tf:"automatic_restart,omitempty"`

	AvailabilityDomain *float64 `json:"availabilityDomain,omitempty" tf:"availability_domain,omitempty"`

	InstanceTerminationAction *string `json:"instanceTerminationAction,omitempty" tf:"instance_termination_action,omitempty"`

	LocalSsdRecoveryTimeout *SchedulingLocalSsdRecoveryTimeoutInitParameters `json:"localSsdRecoveryTimeout,omitempty" tf:"local_ssd_recovery_timeout,omitempty"`

	MaxRunDuration *SchedulingMaxRunDurationInitParameters `json:"maxRunDuration,omitempty" tf:"max_run_duration,omitempty"`

	MinNodeCpus *float64 `json:"minNodeCpus,omitempty" tf:"min_node_cpus,omitempty"`

	NodeAffinities []SchedulingNodeAffinitiesInitParameters `json:"nodeAffinities,omitempty" tf:"node_affinities,omitempty"`

	OnHostMaintenance *string `json:"onHostMaintenance,omitempty" tf:"on_host_maintenance,omitempty"`

	OnInstanceStopAction *SchedulingOnInstanceStopActionInitParameters `json:"onInstanceStopAction,omitempty" tf:"on_instance_stop_action,omitempty"`

	Preemptible *bool `json:"preemptible,omitempty" tf:"preemptible,omitempty"`

	ProvisioningModel *string `json:"provisioningModel,omitempty" tf:"provisioning_model,omitempty"`

	TerminationTime *string `json:"terminationTime,omitempty" tf:"termination_time,omitempty"`
}

type InstanceFromTemplateSchedulingObservation struct {
	AutomaticRestart *bool `json:"automaticRestart,omitempty" tf:"automatic_restart,omitempty"`

	AvailabilityDomain *float64 `json:"availabilityDomain,omitempty" tf:"availability_domain,omitempty"`

	InstanceTerminationAction *string `json:"instanceTerminationAction,omitempty" tf:"instance_termination_action,omitempty"`

	LocalSsdRecoveryTimeout *SchedulingLocalSsdRecoveryTimeoutObservation `json:"localSsdRecoveryTimeout,omitempty" tf:"local_ssd_recovery_timeout,omitempty"`

	MaxRunDuration *SchedulingMaxRunDurationObservation `json:"maxRunDuration,omitempty" tf:"max_run_duration,omitempty"`

	MinNodeCpus *float64 `json:"minNodeCpus,omitempty" tf:"min_node_cpus,omitempty"`

	NodeAffinities []SchedulingNodeAffinitiesObservation `json:"nodeAffinities,omitempty" tf:"node_affinities,omitempty"`

	OnHostMaintenance *string `json:"onHostMaintenance,omitempty" tf:"on_host_maintenance,omitempty"`

	OnInstanceStopAction *SchedulingOnInstanceStopActionObservation `json:"onInstanceStopAction,omitempty" tf:"on_instance_stop_action,omitempty"`

	Preemptible *bool `json:"preemptible,omitempty" tf:"preemptible,omitempty"`

	ProvisioningModel *string `json:"provisioningModel,omitempty" tf:"provisioning_model,omitempty"`

	TerminationTime *string `json:"terminationTime,omitempty" tf:"termination_time,omitempty"`
}

type InstanceFromTemplateSchedulingParameters struct {

	// +kubebuilder:validation:Optional
	AutomaticRestart *bool `json:"automaticRestart,omitempty" tf:"automatic_restart,omitempty"`

	// +kubebuilder:validation:Optional
	AvailabilityDomain *float64 `json:"availabilityDomain,omitempty" tf:"availability_domain,omitempty"`

	// +kubebuilder:validation:Optional
	InstanceTerminationAction *string `json:"instanceTerminationAction,omitempty" tf:"instance_termination_action,omitempty"`

	// +kubebuilder:validation:Optional
	LocalSsdRecoveryTimeout *SchedulingLocalSsdRecoveryTimeoutParameters `json:"localSsdRecoveryTimeout,omitempty" tf:"local_ssd_recovery_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	MaxRunDuration *SchedulingMaxRunDurationParameters `json:"maxRunDuration,omitempty" tf:"max_run_duration,omitempty"`

	// +kubebuilder:validation:Optional
	MinNodeCpus *float64 `json:"minNodeCpus,omitempty" tf:"min_node_cpus,omitempty"`

	// +kubebuilder:validation:Optional
	NodeAffinities []SchedulingNodeAffinitiesParameters `json:"nodeAffinities,omitempty" tf:"node_affinities,omitempty"`

	// +kubebuilder:validation:Optional
	OnHostMaintenance *string `json:"onHostMaintenance,omitempty" tf:"on_host_maintenance,omitempty"`

	// +kubebuilder:validation:Optional
	OnInstanceStopAction *SchedulingOnInstanceStopActionParameters `json:"onInstanceStopAction,omitempty" tf:"on_instance_stop_action,omitempty"`

	// +kubebuilder:validation:Optional
	Preemptible *bool `json:"preemptible,omitempty" tf:"preemptible,omitempty"`

	// +kubebuilder:validation:Optional
	ProvisioningModel *string `json:"provisioningModel,omitempty" tf:"provisioning_model,omitempty"`

	// +kubebuilder:validation:Optional
	TerminationTime *string `json:"terminationTime,omitempty" tf:"termination_time,omitempty"`
}

type InstanceFromTemplateScratchDiskInitParameters struct {

	// A unique name for the resource, required by GCE.
	// Changing this forces a new resource to be created.
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	Interface *string `json:"interface,omitempty" tf:"interface,omitempty"`

	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`
}

type InstanceFromTemplateScratchDiskObservation struct {

	// A unique name for the resource, required by GCE.
	// Changing this forces a new resource to be created.
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	Interface *string `json:"interface,omitempty" tf:"interface,omitempty"`

	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`
}

type InstanceFromTemplateScratchDiskParameters struct {

	// A unique name for the resource, required by GCE.
	// Changing this forces a new resource to be created.
	// +kubebuilder:validation:Optional
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	// +kubebuilder:validation:Optional
	Interface *string `json:"interface" tf:"interface,omitempty"`

	// +kubebuilder:validation:Optional
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`
}

type InstanceFromTemplateServiceAccountInitParameters struct {
	Email *string `json:"email,omitempty" tf:"email,omitempty"`

	// +listType=set
	Scopes []*string `json:"scopes,omitempty" tf:"scopes,omitempty"`
}

type InstanceFromTemplateServiceAccountObservation struct {
	Email *string `json:"email,omitempty" tf:"email,omitempty"`

	// +listType=set
	Scopes []*string `json:"scopes,omitempty" tf:"scopes,omitempty"`
}

type InstanceFromTemplateServiceAccountParameters struct {

	// +kubebuilder:validation:Optional
	Email *string `json:"email,omitempty" tf:"email,omitempty"`

	// +kubebuilder:validation:Optional
	// +listType=set
	Scopes []*string `json:"scopes" tf:"scopes,omitempty"`
}

type InstanceFromTemplateShieldedInstanceConfigInitParameters struct {
	EnableIntegrityMonitoring *bool `json:"enableIntegrityMonitoring,omitempty" tf:"enable_integrity_monitoring,omitempty"`

	EnableSecureBoot *bool `json:"enableSecureBoot,omitempty" tf:"enable_secure_boot,omitempty"`

	EnableVtpm *bool `json:"enableVtpm,omitempty" tf:"enable_vtpm,omitempty"`
}

type InstanceFromTemplateShieldedInstanceConfigObservation struct {
	EnableIntegrityMonitoring *bool `json:"enableIntegrityMonitoring,omitempty" tf:"enable_integrity_monitoring,omitempty"`

	EnableSecureBoot *bool `json:"enableSecureBoot,omitempty" tf:"enable_secure_boot,omitempty"`

	EnableVtpm *bool `json:"enableVtpm,omitempty" tf:"enable_vtpm,omitempty"`
}

type InstanceFromTemplateShieldedInstanceConfigParameters struct {

	// +kubebuilder:validation:Optional
	EnableIntegrityMonitoring *bool `json:"enableIntegrityMonitoring,omitempty" tf:"enable_integrity_monitoring,omitempty"`

	// +kubebuilder:validation:Optional
	EnableSecureBoot *bool `json:"enableSecureBoot,omitempty" tf:"enable_secure_boot,omitempty"`

	// +kubebuilder:validation:Optional
	EnableVtpm *bool `json:"enableVtpm,omitempty" tf:"enable_vtpm,omitempty"`
}

type NetworkInterfaceAccessConfigInitParameters struct {
	NATIP *string `json:"natIp,omitempty" tf:"nat_ip,omitempty"`

	NetworkTier *string `json:"networkTier,omitempty" tf:"network_tier,omitempty"`

	// A unique name for the resource, required by GCE.
	// Changing this forces a new resource to be created.
	PublicPtrDomainName *string `json:"publicPtrDomainName,omitempty" tf:"public_ptr_domain_name,omitempty"`
}

type NetworkInterfaceAccessConfigObservation struct {
	NATIP *string `json:"natIp,omitempty" tf:"nat_ip,omitempty"`

	NetworkTier *string `json:"networkTier,omitempty" tf:"network_tier,omitempty"`

	// A unique name for the resource, required by GCE.
	// Changing this forces a new resource to be created.
	PublicPtrDomainName *string `json:"publicPtrDomainName,omitempty" tf:"public_ptr_domain_name,omitempty"`
}

type NetworkInterfaceAccessConfigParameters struct {

	// +kubebuilder:validation:Optional
	NATIP *string `json:"natIp,omitempty" tf:"nat_ip,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkTier *string `json:"networkTier,omitempty" tf:"network_tier,omitempty"`

	// A unique name for the resource, required by GCE.
	// Changing this forces a new resource to be created.
	// +kubebuilder:validation:Optional
	PublicPtrDomainName *string `json:"publicPtrDomainName,omitempty" tf:"public_ptr_domain_name,omitempty"`
}

type NetworkInterfaceAliasIPRangeInitParameters struct {
	IPCidrRange *string `json:"ipCidrRange,omitempty" tf:"ip_cidr_range,omitempty"`

	// A unique name for the resource, required by GCE.
	// Changing this forces a new resource to be created.
	SubnetworkRangeName *string `json:"subnetworkRangeName,omitempty" tf:"subnetwork_range_name,omitempty"`
}

type NetworkInterfaceAliasIPRangeObservation struct {
	IPCidrRange *string `json:"ipCidrRange,omitempty" tf:"ip_cidr_range,omitempty"`

	// A unique name for the resource, required by GCE.
	// Changing this forces a new resource to be created.
	SubnetworkRangeName *string `json:"subnetworkRangeName,omitempty" tf:"subnetwork_range_name,omitempty"`
}

type NetworkInterfaceAliasIPRangeParameters struct {

	// +kubebuilder:validation:Optional
	IPCidrRange *string `json:"ipCidrRange" tf:"ip_cidr_range,omitempty"`

	// A unique name for the resource, required by GCE.
	// Changing this forces a new resource to be created.
	// +kubebuilder:validation:Optional
	SubnetworkRangeName *string `json:"subnetworkRangeName,omitempty" tf:"subnetwork_range_name,omitempty"`
}

type NetworkInterfaceIPv6AccessConfigInitParameters struct {
	ExternalIPv6 *string `json:"externalIpv6,omitempty" tf:"external_ipv6,omitempty"`

	ExternalIPv6PrefixLength *string `json:"externalIpv6PrefixLength,omitempty" tf:"external_ipv6_prefix_length,omitempty"`

	// A unique name for the resource, required by GCE.
	// Changing this forces a new resource to be created.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	NetworkTier *string `json:"networkTier,omitempty" tf:"network_tier,omitempty"`

	// A unique name for the resource, required by GCE.
	// Changing this forces a new resource to be created.
	PublicPtrDomainName *string `json:"publicPtrDomainName,omitempty" tf:"public_ptr_domain_name,omitempty"`
}

type NetworkInterfaceIPv6AccessConfigObservation struct {
	ExternalIPv6 *string `json:"externalIpv6,omitempty" tf:"external_ipv6,omitempty"`

	ExternalIPv6PrefixLength *string `json:"externalIpv6PrefixLength,omitempty" tf:"external_ipv6_prefix_length,omitempty"`

	// A unique name for the resource, required by GCE.
	// Changing this forces a new resource to be created.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	NetworkTier *string `json:"networkTier,omitempty" tf:"network_tier,omitempty"`

	// A unique name for the resource, required by GCE.
	// Changing this forces a new resource to be created.
	PublicPtrDomainName *string `json:"publicPtrDomainName,omitempty" tf:"public_ptr_domain_name,omitempty"`
}

type NetworkInterfaceIPv6AccessConfigParameters struct {

	// +kubebuilder:validation:Optional
	ExternalIPv6 *string `json:"externalIpv6,omitempty" tf:"external_ipv6,omitempty"`

	// +kubebuilder:validation:Optional
	ExternalIPv6PrefixLength *string `json:"externalIpv6PrefixLength,omitempty" tf:"external_ipv6_prefix_length,omitempty"`

	// A unique name for the resource, required by GCE.
	// Changing this forces a new resource to be created.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkTier *string `json:"networkTier" tf:"network_tier,omitempty"`

	// A unique name for the resource, required by GCE.
	// Changing this forces a new resource to be created.
	// +kubebuilder:validation:Optional
	PublicPtrDomainName *string `json:"publicPtrDomainName,omitempty" tf:"public_ptr_domain_name,omitempty"`
}

type ReservationAffinitySpecificReservationInitParameters struct {
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type ReservationAffinitySpecificReservationObservation struct {
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type ReservationAffinitySpecificReservationParameters struct {

	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Values []*string `json:"values" tf:"values,omitempty"`
}

type SchedulingLocalSsdRecoveryTimeoutInitParameters struct {
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type SchedulingLocalSsdRecoveryTimeoutObservation struct {
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type SchedulingLocalSsdRecoveryTimeoutParameters struct {

	// +kubebuilder:validation:Optional
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// +kubebuilder:validation:Optional
	Seconds *float64 `json:"seconds" tf:"seconds,omitempty"`
}

type SchedulingMaxRunDurationInitParameters struct {
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type SchedulingMaxRunDurationObservation struct {
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type SchedulingMaxRunDurationParameters struct {

	// +kubebuilder:validation:Optional
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// +kubebuilder:validation:Optional
	Seconds *float64 `json:"seconds" tf:"seconds,omitempty"`
}

type SchedulingNodeAffinitiesInitParameters struct {
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// +listType=set
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type SchedulingNodeAffinitiesObservation struct {
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// +listType=set
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type SchedulingNodeAffinitiesParameters struct {

	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// +kubebuilder:validation:Optional
	// +listType=set
	Values []*string `json:"values" tf:"values,omitempty"`
}

type SchedulingOnInstanceStopActionInitParameters struct {
	DiscardLocalSsd *bool `json:"discardLocalSsd,omitempty" tf:"discard_local_ssd,omitempty"`
}

type SchedulingOnInstanceStopActionObservation struct {
	DiscardLocalSsd *bool `json:"discardLocalSsd,omitempty" tf:"discard_local_ssd,omitempty"`
}

type SchedulingOnInstanceStopActionParameters struct {

	// +kubebuilder:validation:Optional
	DiscardLocalSsd *bool `json:"discardLocalSsd,omitempty" tf:"discard_local_ssd,omitempty"`
}

// InstanceFromTemplateSpec defines the desired state of InstanceFromTemplate
type InstanceFromTemplateSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     InstanceFromTemplateParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider InstanceFromTemplateInitParameters `json:"initProvider,omitempty"`
}

// InstanceFromTemplateStatus defines the observed state of InstanceFromTemplate.
type InstanceFromTemplateStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        InstanceFromTemplateObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status

// InstanceFromTemplate is the Schema for the InstanceFromTemplates API. Manages a VM instance resource within GCE.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcp}
type InstanceFromTemplate struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	Spec   InstanceFromTemplateSpec   `json:"spec"`
	Status InstanceFromTemplateStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// InstanceFromTemplateList contains a list of InstanceFromTemplates
type InstanceFromTemplateList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []InstanceFromTemplate `json:"items"`
}

// Repository type metadata.
var (
	InstanceFromTemplate_Kind             = "InstanceFromTemplate"
	InstanceFromTemplate_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: InstanceFromTemplate_Kind}.String()
	InstanceFromTemplate_KindAPIVersion   = InstanceFromTemplate_Kind + "." + CRDGroupVersion.String()
	InstanceFromTemplate_GroupVersionKind = CRDGroupVersion.WithKind(InstanceFromTemplate_Kind)
)

func init() {
	SchemeBuilder.Register(&InstanceFromTemplate{}, &InstanceFromTemplateList{})
}
