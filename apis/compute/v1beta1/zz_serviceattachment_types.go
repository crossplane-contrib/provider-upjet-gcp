// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ConnectedEndpointsInitParameters struct {
}

type ConnectedEndpointsObservation struct {

	// (Output)
	// The url of the consumer network.
	ConsumerNetwork *string `json:"consumerNetwork,omitempty" tf:"consumer_network,omitempty"`

	// (Output)
	// The URL of the consumer forwarding rule.
	Endpoint *string `json:"endpoint,omitempty" tf:"endpoint,omitempty"`

	// (Output)
	// The number of consumer Network Connectivity Center spokes that the connected Private Service Connect endpoint has propagated to.
	PropagatedConnectionCount *float64 `json:"propagatedConnectionCount,omitempty" tf:"propagated_connection_count,omitempty"`

	// (Output)
	// The PSC connection id of the connected endpoint.
	PscConnectionID *string `json:"pscConnectionId,omitempty" tf:"psc_connection_id,omitempty"`

	// (Output)
	// The status of the connection from the consumer forwarding rule to
	// this service attachment.
	Status *string `json:"status,omitempty" tf:"status,omitempty"`
}

type ConnectedEndpointsParameters struct {
}

type ConsumerAcceptListsInitParameters struct {

	// The number of consumer forwarding rules the consumer project can
	// create.
	ConnectionLimit *float64 `json:"connectionLimit,omitempty" tf:"connection_limit,omitempty"`

	// The network that is allowed to connect to this service attachment.
	// Only one of project_id_or_num and network_url may be set.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.Network
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("self_link",true)
	NetworkURL *string `json:"networkUrl,omitempty" tf:"network_url,omitempty"`

	// Reference to a Network in compute to populate networkUrl.
	// +kubebuilder:validation:Optional
	NetworkURLRef *v1.Reference `json:"networkUrlRef,omitempty" tf:"-"`

	// Selector for a Network in compute to populate networkUrl.
	// +kubebuilder:validation:Optional
	NetworkURLSelector *v1.Selector `json:"networkUrlSelector,omitempty" tf:"-"`

	// A project that is allowed to connect to this service attachment.
	// Only one of project_id_or_num and network_url may be set.
	ProjectIDOrNum *string `json:"projectIdOrNum,omitempty" tf:"project_id_or_num,omitempty"`
}

type ConsumerAcceptListsObservation struct {

	// The number of consumer forwarding rules the consumer project can
	// create.
	ConnectionLimit *float64 `json:"connectionLimit,omitempty" tf:"connection_limit,omitempty"`

	// The network that is allowed to connect to this service attachment.
	// Only one of project_id_or_num and network_url may be set.
	NetworkURL *string `json:"networkUrl,omitempty" tf:"network_url,omitempty"`

	// A project that is allowed to connect to this service attachment.
	// Only one of project_id_or_num and network_url may be set.
	ProjectIDOrNum *string `json:"projectIdOrNum,omitempty" tf:"project_id_or_num,omitempty"`
}

type ConsumerAcceptListsParameters struct {

	// The number of consumer forwarding rules the consumer project can
	// create.
	// +kubebuilder:validation:Optional
	ConnectionLimit *float64 `json:"connectionLimit" tf:"connection_limit,omitempty"`

	// The network that is allowed to connect to this service attachment.
	// Only one of project_id_or_num and network_url may be set.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.Network
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("self_link",true)
	// +kubebuilder:validation:Optional
	NetworkURL *string `json:"networkUrl,omitempty" tf:"network_url,omitempty"`

	// Reference to a Network in compute to populate networkUrl.
	// +kubebuilder:validation:Optional
	NetworkURLRef *v1.Reference `json:"networkUrlRef,omitempty" tf:"-"`

	// Selector for a Network in compute to populate networkUrl.
	// +kubebuilder:validation:Optional
	NetworkURLSelector *v1.Selector `json:"networkUrlSelector,omitempty" tf:"-"`

	// A project that is allowed to connect to this service attachment.
	// Only one of project_id_or_num and network_url may be set.
	// +kubebuilder:validation:Optional
	ProjectIDOrNum *string `json:"projectIdOrNum,omitempty" tf:"project_id_or_num,omitempty"`
}

type ServiceAttachmentInitParameters struct {

	// The connection preference to use for this service attachment. Valid
	// values include "ACCEPT_AUTOMATIC", "ACCEPT_MANUAL".
	ConnectionPreference *string `json:"connectionPreference,omitempty" tf:"connection_preference,omitempty"`

	// An array of projects that are allowed to connect to this service
	// attachment.
	// Structure is documented below.
	ConsumerAcceptLists []ConsumerAcceptListsInitParameters `json:"consumerAcceptLists,omitempty" tf:"consumer_accept_lists,omitempty"`

	// An array of projects that are not allowed to connect to this service
	// attachment.
	ConsumerRejectLists []*string `json:"consumerRejectLists,omitempty" tf:"consumer_reject_lists,omitempty"`

	// An optional description of this resource.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// If specified, the domain name will be used during the integration between
	// the PSC connected endpoints and the Cloud DNS. For example, this is a
	// valid domain name: "p.mycompany.com.". Current max number of domain names
	// supported is 1.
	DomainNames []*string `json:"domainNames,omitempty" tf:"domain_names,omitempty"`

	// If true, enable the proxy protocol which is for supplying client TCP/IP
	// address data in TCP connections that traverse proxies on their way to
	// destination servers.
	EnableProxyProtocol *bool `json:"enableProxyProtocol,omitempty" tf:"enable_proxy_protocol,omitempty"`

	// An array of subnets that is provided for NAT in this service attachment.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta2.Subnetwork
	NATSubnets []*string `json:"natSubnets,omitempty" tf:"nat_subnets,omitempty"`

	// References to Subnetwork in compute to populate natSubnets.
	// +kubebuilder:validation:Optional
	NATSubnetsRefs []v1.Reference `json:"natSubnetsRefs,omitempty" tf:"-"`

	// Selector for a list of Subnetwork in compute to populate natSubnets.
	// +kubebuilder:validation:Optional
	NATSubnetsSelector *v1.Selector `json:"natSubnetsSelector,omitempty" tf:"-"`

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// The number of consumer spokes that connected Private Service Connect endpoints can be propagated to through Network Connectivity Center.
	// This limit lets the service producer limit how many propagated Private Service Connect connections can be established to this service attachment from a single consumer.
	// If the connection preference of the service attachment is ACCEPT_MANUAL, the limit applies to each project or network that is listed in the consumer accept list.
	// If the connection preference of the service attachment is ACCEPT_AUTOMATIC, the limit applies to each project that contains a connected endpoint.
	// If unspecified, the default propagated connection limit is 250. To explicitly send a zero value, set send_propagated_connection_limit_if_zero = true.
	PropagatedConnectionLimit *float64 `json:"propagatedConnectionLimit,omitempty" tf:"propagated_connection_limit,omitempty"`

	// This flag determines whether a consumer accept/reject list change can reconcile the statuses of existing ACCEPTED or REJECTED PSC endpoints.
	// If false, connection policy update will only affect existing PENDING PSC endpoints. Existing ACCEPTED/REJECTED endpoints will remain untouched regardless how the connection policy is modified .
	// If true, update will affect both PENDING and ACCEPTED/REJECTED PSC endpoints. For example, an ACCEPTED PSC endpoint will be moved to REJECTED if its project is added to the reject list.
	ReconcileConnections *bool `json:"reconcileConnections,omitempty" tf:"reconcile_connections,omitempty"`

	// Controls the behavior of propagated_connection_limit.
	// When false, setting propagated_connection_limit to zero causes the provider to use to the API's default value.
	// When true, the provider will set propagated_connection_limit to zero.
	// Defaults to false.
	SendPropagatedConnectionLimitIfZero *bool `json:"sendPropagatedConnectionLimitIfZero,omitempty" tf:"send_propagated_connection_limit_if_zero,omitempty"`

	// The URL of a service serving the endpoint identified by this service attachment.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta2.ForwardingRule
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	TargetService *string `json:"targetService,omitempty" tf:"target_service,omitempty"`

	// Reference to a ForwardingRule in compute to populate targetService.
	// +kubebuilder:validation:Optional
	TargetServiceRef *v1.Reference `json:"targetServiceRef,omitempty" tf:"-"`

	// Selector for a ForwardingRule in compute to populate targetService.
	// +kubebuilder:validation:Optional
	TargetServiceSelector *v1.Selector `json:"targetServiceSelector,omitempty" tf:"-"`
}

type ServiceAttachmentObservation struct {

	// An array of the consumer forwarding rules connected to this service
	// attachment.
	// Structure is documented below.
	ConnectedEndpoints []ConnectedEndpointsObservation `json:"connectedEndpoints,omitempty" tf:"connected_endpoints,omitempty"`

	// The connection preference to use for this service attachment. Valid
	// values include "ACCEPT_AUTOMATIC", "ACCEPT_MANUAL".
	ConnectionPreference *string `json:"connectionPreference,omitempty" tf:"connection_preference,omitempty"`

	// An array of projects that are allowed to connect to this service
	// attachment.
	// Structure is documented below.
	ConsumerAcceptLists []ConsumerAcceptListsObservation `json:"consumerAcceptLists,omitempty" tf:"consumer_accept_lists,omitempty"`

	// An array of projects that are not allowed to connect to this service
	// attachment.
	ConsumerRejectLists []*string `json:"consumerRejectLists,omitempty" tf:"consumer_reject_lists,omitempty"`

	// An optional description of this resource.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// If specified, the domain name will be used during the integration between
	// the PSC connected endpoints and the Cloud DNS. For example, this is a
	// valid domain name: "p.mycompany.com.". Current max number of domain names
	// supported is 1.
	DomainNames []*string `json:"domainNames,omitempty" tf:"domain_names,omitempty"`

	// If true, enable the proxy protocol which is for supplying client TCP/IP
	// address data in TCP connections that traverse proxies on their way to
	// destination servers.
	EnableProxyProtocol *bool `json:"enableProxyProtocol,omitempty" tf:"enable_proxy_protocol,omitempty"`

	// Fingerprint of this resource. This field is used internally during
	// updates of this resource.
	Fingerprint *string `json:"fingerprint,omitempty" tf:"fingerprint,omitempty"`

	// an identifier for the resource with format projects/{{project}}/regions/{{region}}/serviceAttachments/{{name}}
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// An array of subnets that is provided for NAT in this service attachment.
	NATSubnets []*string `json:"natSubnets,omitempty" tf:"nat_subnets,omitempty"`

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// The number of consumer spokes that connected Private Service Connect endpoints can be propagated to through Network Connectivity Center.
	// This limit lets the service producer limit how many propagated Private Service Connect connections can be established to this service attachment from a single consumer.
	// If the connection preference of the service attachment is ACCEPT_MANUAL, the limit applies to each project or network that is listed in the consumer accept list.
	// If the connection preference of the service attachment is ACCEPT_AUTOMATIC, the limit applies to each project that contains a connected endpoint.
	// If unspecified, the default propagated connection limit is 250. To explicitly send a zero value, set send_propagated_connection_limit_if_zero = true.
	PropagatedConnectionLimit *float64 `json:"propagatedConnectionLimit,omitempty" tf:"propagated_connection_limit,omitempty"`

	// This flag determines whether a consumer accept/reject list change can reconcile the statuses of existing ACCEPTED or REJECTED PSC endpoints.
	// If false, connection policy update will only affect existing PENDING PSC endpoints. Existing ACCEPTED/REJECTED endpoints will remain untouched regardless how the connection policy is modified .
	// If true, update will affect both PENDING and ACCEPTED/REJECTED PSC endpoints. For example, an ACCEPTED PSC endpoint will be moved to REJECTED if its project is added to the reject list.
	ReconcileConnections *bool `json:"reconcileConnections,omitempty" tf:"reconcile_connections,omitempty"`

	// URL of the region where the resource resides.
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// The URI of the created resource.
	SelfLink *string `json:"selfLink,omitempty" tf:"self_link,omitempty"`

	// Controls the behavior of propagated_connection_limit.
	// When false, setting propagated_connection_limit to zero causes the provider to use to the API's default value.
	// When true, the provider will set propagated_connection_limit to zero.
	// Defaults to false.
	SendPropagatedConnectionLimitIfZero *bool `json:"sendPropagatedConnectionLimitIfZero,omitempty" tf:"send_propagated_connection_limit_if_zero,omitempty"`

	// The URL of a service serving the endpoint identified by this service attachment.
	TargetService *string `json:"targetService,omitempty" tf:"target_service,omitempty"`
}

type ServiceAttachmentParameters struct {

	// The connection preference to use for this service attachment. Valid
	// values include "ACCEPT_AUTOMATIC", "ACCEPT_MANUAL".
	// +kubebuilder:validation:Optional
	ConnectionPreference *string `json:"connectionPreference,omitempty" tf:"connection_preference,omitempty"`

	// An array of projects that are allowed to connect to this service
	// attachment.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	ConsumerAcceptLists []ConsumerAcceptListsParameters `json:"consumerAcceptLists,omitempty" tf:"consumer_accept_lists,omitempty"`

	// An array of projects that are not allowed to connect to this service
	// attachment.
	// +kubebuilder:validation:Optional
	ConsumerRejectLists []*string `json:"consumerRejectLists,omitempty" tf:"consumer_reject_lists,omitempty"`

	// An optional description of this resource.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// If specified, the domain name will be used during the integration between
	// the PSC connected endpoints and the Cloud DNS. For example, this is a
	// valid domain name: "p.mycompany.com.". Current max number of domain names
	// supported is 1.
	// +kubebuilder:validation:Optional
	DomainNames []*string `json:"domainNames,omitempty" tf:"domain_names,omitempty"`

	// If true, enable the proxy protocol which is for supplying client TCP/IP
	// address data in TCP connections that traverse proxies on their way to
	// destination servers.
	// +kubebuilder:validation:Optional
	EnableProxyProtocol *bool `json:"enableProxyProtocol,omitempty" tf:"enable_proxy_protocol,omitempty"`

	// An array of subnets that is provided for NAT in this service attachment.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta2.Subnetwork
	// +kubebuilder:validation:Optional
	NATSubnets []*string `json:"natSubnets,omitempty" tf:"nat_subnets,omitempty"`

	// References to Subnetwork in compute to populate natSubnets.
	// +kubebuilder:validation:Optional
	NATSubnetsRefs []v1.Reference `json:"natSubnetsRefs,omitempty" tf:"-"`

	// Selector for a list of Subnetwork in compute to populate natSubnets.
	// +kubebuilder:validation:Optional
	NATSubnetsSelector *v1.Selector `json:"natSubnetsSelector,omitempty" tf:"-"`

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	// +kubebuilder:validation:Optional
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// The number of consumer spokes that connected Private Service Connect endpoints can be propagated to through Network Connectivity Center.
	// This limit lets the service producer limit how many propagated Private Service Connect connections can be established to this service attachment from a single consumer.
	// If the connection preference of the service attachment is ACCEPT_MANUAL, the limit applies to each project or network that is listed in the consumer accept list.
	// If the connection preference of the service attachment is ACCEPT_AUTOMATIC, the limit applies to each project that contains a connected endpoint.
	// If unspecified, the default propagated connection limit is 250. To explicitly send a zero value, set send_propagated_connection_limit_if_zero = true.
	// +kubebuilder:validation:Optional
	PropagatedConnectionLimit *float64 `json:"propagatedConnectionLimit,omitempty" tf:"propagated_connection_limit,omitempty"`

	// This flag determines whether a consumer accept/reject list change can reconcile the statuses of existing ACCEPTED or REJECTED PSC endpoints.
	// If false, connection policy update will only affect existing PENDING PSC endpoints. Existing ACCEPTED/REJECTED endpoints will remain untouched regardless how the connection policy is modified .
	// If true, update will affect both PENDING and ACCEPTED/REJECTED PSC endpoints. For example, an ACCEPTED PSC endpoint will be moved to REJECTED if its project is added to the reject list.
	// +kubebuilder:validation:Optional
	ReconcileConnections *bool `json:"reconcileConnections,omitempty" tf:"reconcile_connections,omitempty"`

	// URL of the region where the resource resides.
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"region,omitempty"`

	// Controls the behavior of propagated_connection_limit.
	// When false, setting propagated_connection_limit to zero causes the provider to use to the API's default value.
	// When true, the provider will set propagated_connection_limit to zero.
	// Defaults to false.
	// +kubebuilder:validation:Optional
	SendPropagatedConnectionLimitIfZero *bool `json:"sendPropagatedConnectionLimitIfZero,omitempty" tf:"send_propagated_connection_limit_if_zero,omitempty"`

	// The URL of a service serving the endpoint identified by this service attachment.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta2.ForwardingRule
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	TargetService *string `json:"targetService,omitempty" tf:"target_service,omitempty"`

	// Reference to a ForwardingRule in compute to populate targetService.
	// +kubebuilder:validation:Optional
	TargetServiceRef *v1.Reference `json:"targetServiceRef,omitempty" tf:"-"`

	// Selector for a ForwardingRule in compute to populate targetService.
	// +kubebuilder:validation:Optional
	TargetServiceSelector *v1.Selector `json:"targetServiceSelector,omitempty" tf:"-"`
}

// ServiceAttachmentSpec defines the desired state of ServiceAttachment
type ServiceAttachmentSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ServiceAttachmentParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider ServiceAttachmentInitParameters `json:"initProvider,omitempty"`
}

// ServiceAttachmentStatus defines the observed state of ServiceAttachment.
type ServiceAttachmentStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ServiceAttachmentObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// ServiceAttachment is the Schema for the ServiceAttachments API. Represents a ServiceAttachment resource.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcp}
type ServiceAttachment struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.connectionPreference) || (has(self.initProvider) && has(self.initProvider.connectionPreference))",message="spec.forProvider.connectionPreference is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.enableProxyProtocol) || (has(self.initProvider) && has(self.initProvider.enableProxyProtocol))",message="spec.forProvider.enableProxyProtocol is a required parameter"
	Spec   ServiceAttachmentSpec   `json:"spec"`
	Status ServiceAttachmentStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ServiceAttachmentList contains a list of ServiceAttachments
type ServiceAttachmentList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ServiceAttachment `json:"items"`
}

// Repository type metadata.
var (
	ServiceAttachment_Kind             = "ServiceAttachment"
	ServiceAttachment_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ServiceAttachment_Kind}.String()
	ServiceAttachment_KindAPIVersion   = ServiceAttachment_Kind + "." + CRDGroupVersion.String()
	ServiceAttachment_GroupVersionKind = CRDGroupVersion.WithKind(ServiceAttachment_Kind)
)

func init() {
	SchemeBuilder.Register(&ServiceAttachment{}, &ServiceAttachmentList{})
}
