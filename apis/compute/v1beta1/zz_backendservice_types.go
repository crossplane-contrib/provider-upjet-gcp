// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type BackendInitParameters struct {

	// Specifies the balancing mode for this backend.
	// For global HTTP(S) or TCP/SSL load balancing, the default is
	// UTILIZATION. Valid values are UTILIZATION, RATE (for HTTP(S))
	// and CONNECTION (for TCP/SSL).
	// See the Backend Services Overview
	// for an explanation of load balancing modes.
	// Default value is UTILIZATION.
	// Possible values are: UTILIZATION, RATE, CONNECTION.
	BalancingMode *string `json:"balancingMode,omitempty" tf:"balancing_mode,omitempty"`

	// A multiplier applied to the group's maximum servicing capacity
	// (based on UTILIZATION, RATE or CONNECTION).
	// Default value is 1, which means the group will serve up to 100%
	// of its configured capacity (depending on balancingMode). A
	// setting of 0 means the group is completely drained, offering
	// 0% of its available Capacity. Valid range is [0.0,1.0].
	CapacityScaler *float64 `json:"capacityScaler,omitempty" tf:"capacity_scaler,omitempty"`

	// An optional description of this resource.
	// Provide this property when you create the resource.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The fully-qualified URL of an Instance Group or Network Endpoint
	// Group resource. In case of instance group this defines the list
	// of instances that serve traffic. Member virtual machine
	// instances from each instance group must live in the same zone as
	// the instance group itself. No two backends in a backend service
	// are allowed to use same Instance Group resource.
	// For Network Endpoint Groups this defines list of endpoints. All
	// endpoints of Network Endpoint Group must be hosted on instances
	// located in the same zone as the Network Endpoint Group.
	// Backend services cannot mix Instance Group and
	// Network Endpoint Group backends.
	// Note that you must specify an Instance Group or Network Endpoint
	// Group resource using the fully-qualified URL, rather than a
	// partial URL.
	// +crossplane:generate:reference:type=InstanceGroupManager
	// +crossplane:generate:reference:extractor=github.com/upbound/provider-gcp/config/compute.InstanceGroupExtractor()
	Group *string `json:"group,omitempty" tf:"group,omitempty"`

	// Reference to a InstanceGroupManager to populate group.
	// +kubebuilder:validation:Optional
	GroupRef *v1.Reference `json:"groupRef,omitempty" tf:"-"`

	// Selector for a InstanceGroupManager to populate group.
	// +kubebuilder:validation:Optional
	GroupSelector *v1.Selector `json:"groupSelector,omitempty" tf:"-"`

	// The max number of simultaneous connections for the group. Can
	// be used with either CONNECTION or UTILIZATION balancing modes.
	// For CONNECTION mode, either maxConnections or one
	// of maxConnectionsPerInstance or maxConnectionsPerEndpoint,
	// as appropriate for group type, must be set.
	MaxConnections *float64 `json:"maxConnections,omitempty" tf:"max_connections,omitempty"`

	// The max number of simultaneous connections that a single backend
	// network endpoint can handle. This is used to calculate the
	// capacity of the group. Can be used in either CONNECTION or
	// UTILIZATION balancing modes.
	// For CONNECTION mode, either
	// maxConnections or maxConnectionsPerEndpoint must be set.
	MaxConnectionsPerEndpoint *float64 `json:"maxConnectionsPerEndpoint,omitempty" tf:"max_connections_per_endpoint,omitempty"`

	// The max number of simultaneous connections that a single
	// backend instance can handle. This is used to calculate the
	// capacity of the group. Can be used in either CONNECTION or
	// UTILIZATION balancing modes.
	// For CONNECTION mode, either maxConnections or
	// maxConnectionsPerInstance must be set.
	MaxConnectionsPerInstance *float64 `json:"maxConnectionsPerInstance,omitempty" tf:"max_connections_per_instance,omitempty"`

	// The max requests per second (RPS) of the group.
	// Can be used with either RATE or UTILIZATION balancing modes,
	// but required if RATE mode. For RATE mode, either maxRate or one
	// of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
	// group type, must be set.
	MaxRate *float64 `json:"maxRate,omitempty" tf:"max_rate,omitempty"`

	// The max requests per second (RPS) that a single backend network
	// endpoint can handle. This is used to calculate the capacity of
	// the group. Can be used in either balancing mode. For RATE mode,
	// either maxRate or maxRatePerEndpoint must be set.
	MaxRatePerEndpoint *float64 `json:"maxRatePerEndpoint,omitempty" tf:"max_rate_per_endpoint,omitempty"`

	// The max requests per second (RPS) that a single backend
	// instance can handle. This is used to calculate the capacity of
	// the group. Can be used in either balancing mode. For RATE mode,
	// either maxRate or maxRatePerInstance must be set.
	MaxRatePerInstance *float64 `json:"maxRatePerInstance,omitempty" tf:"max_rate_per_instance,omitempty"`

	// Used when balancingMode is UTILIZATION. This ratio defines the
	// CPU utilization target for the group. Valid range is [0.0, 1.0].
	MaxUtilization *float64 `json:"maxUtilization,omitempty" tf:"max_utilization,omitempty"`
}

type BackendObservation struct {

	// Specifies the balancing mode for this backend.
	// For global HTTP(S) or TCP/SSL load balancing, the default is
	// UTILIZATION. Valid values are UTILIZATION, RATE (for HTTP(S))
	// and CONNECTION (for TCP/SSL).
	// See the Backend Services Overview
	// for an explanation of load balancing modes.
	// Default value is UTILIZATION.
	// Possible values are: UTILIZATION, RATE, CONNECTION.
	BalancingMode *string `json:"balancingMode,omitempty" tf:"balancing_mode,omitempty"`

	// A multiplier applied to the group's maximum servicing capacity
	// (based on UTILIZATION, RATE or CONNECTION).
	// Default value is 1, which means the group will serve up to 100%
	// of its configured capacity (depending on balancingMode). A
	// setting of 0 means the group is completely drained, offering
	// 0% of its available Capacity. Valid range is [0.0,1.0].
	CapacityScaler *float64 `json:"capacityScaler,omitempty" tf:"capacity_scaler,omitempty"`

	// An optional description of this resource.
	// Provide this property when you create the resource.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The fully-qualified URL of an Instance Group or Network Endpoint
	// Group resource. In case of instance group this defines the list
	// of instances that serve traffic. Member virtual machine
	// instances from each instance group must live in the same zone as
	// the instance group itself. No two backends in a backend service
	// are allowed to use same Instance Group resource.
	// For Network Endpoint Groups this defines list of endpoints. All
	// endpoints of Network Endpoint Group must be hosted on instances
	// located in the same zone as the Network Endpoint Group.
	// Backend services cannot mix Instance Group and
	// Network Endpoint Group backends.
	// Note that you must specify an Instance Group or Network Endpoint
	// Group resource using the fully-qualified URL, rather than a
	// partial URL.
	Group *string `json:"group,omitempty" tf:"group,omitempty"`

	// The max number of simultaneous connections for the group. Can
	// be used with either CONNECTION or UTILIZATION balancing modes.
	// For CONNECTION mode, either maxConnections or one
	// of maxConnectionsPerInstance or maxConnectionsPerEndpoint,
	// as appropriate for group type, must be set.
	MaxConnections *float64 `json:"maxConnections,omitempty" tf:"max_connections,omitempty"`

	// The max number of simultaneous connections that a single backend
	// network endpoint can handle. This is used to calculate the
	// capacity of the group. Can be used in either CONNECTION or
	// UTILIZATION balancing modes.
	// For CONNECTION mode, either
	// maxConnections or maxConnectionsPerEndpoint must be set.
	MaxConnectionsPerEndpoint *float64 `json:"maxConnectionsPerEndpoint,omitempty" tf:"max_connections_per_endpoint,omitempty"`

	// The max number of simultaneous connections that a single
	// backend instance can handle. This is used to calculate the
	// capacity of the group. Can be used in either CONNECTION or
	// UTILIZATION balancing modes.
	// For CONNECTION mode, either maxConnections or
	// maxConnectionsPerInstance must be set.
	MaxConnectionsPerInstance *float64 `json:"maxConnectionsPerInstance,omitempty" tf:"max_connections_per_instance,omitempty"`

	// The max requests per second (RPS) of the group.
	// Can be used with either RATE or UTILIZATION balancing modes,
	// but required if RATE mode. For RATE mode, either maxRate or one
	// of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
	// group type, must be set.
	MaxRate *float64 `json:"maxRate,omitempty" tf:"max_rate,omitempty"`

	// The max requests per second (RPS) that a single backend network
	// endpoint can handle. This is used to calculate the capacity of
	// the group. Can be used in either balancing mode. For RATE mode,
	// either maxRate or maxRatePerEndpoint must be set.
	MaxRatePerEndpoint *float64 `json:"maxRatePerEndpoint,omitempty" tf:"max_rate_per_endpoint,omitempty"`

	// The max requests per second (RPS) that a single backend
	// instance can handle. This is used to calculate the capacity of
	// the group. Can be used in either balancing mode. For RATE mode,
	// either maxRate or maxRatePerInstance must be set.
	MaxRatePerInstance *float64 `json:"maxRatePerInstance,omitempty" tf:"max_rate_per_instance,omitempty"`

	// Used when balancingMode is UTILIZATION. This ratio defines the
	// CPU utilization target for the group. Valid range is [0.0, 1.0].
	MaxUtilization *float64 `json:"maxUtilization,omitempty" tf:"max_utilization,omitempty"`
}

type BackendParameters struct {

	// Specifies the balancing mode for this backend.
	// For global HTTP(S) or TCP/SSL load balancing, the default is
	// UTILIZATION. Valid values are UTILIZATION, RATE (for HTTP(S))
	// and CONNECTION (for TCP/SSL).
	// See the Backend Services Overview
	// for an explanation of load balancing modes.
	// Default value is UTILIZATION.
	// Possible values are: UTILIZATION, RATE, CONNECTION.
	// +kubebuilder:validation:Optional
	BalancingMode *string `json:"balancingMode,omitempty" tf:"balancing_mode,omitempty"`

	// A multiplier applied to the group's maximum servicing capacity
	// (based on UTILIZATION, RATE or CONNECTION).
	// Default value is 1, which means the group will serve up to 100%
	// of its configured capacity (depending on balancingMode). A
	// setting of 0 means the group is completely drained, offering
	// 0% of its available Capacity. Valid range is [0.0,1.0].
	// +kubebuilder:validation:Optional
	CapacityScaler *float64 `json:"capacityScaler,omitempty" tf:"capacity_scaler,omitempty"`

	// An optional description of this resource.
	// Provide this property when you create the resource.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The fully-qualified URL of an Instance Group or Network Endpoint
	// Group resource. In case of instance group this defines the list
	// of instances that serve traffic. Member virtual machine
	// instances from each instance group must live in the same zone as
	// the instance group itself. No two backends in a backend service
	// are allowed to use same Instance Group resource.
	// For Network Endpoint Groups this defines list of endpoints. All
	// endpoints of Network Endpoint Group must be hosted on instances
	// located in the same zone as the Network Endpoint Group.
	// Backend services cannot mix Instance Group and
	// Network Endpoint Group backends.
	// Note that you must specify an Instance Group or Network Endpoint
	// Group resource using the fully-qualified URL, rather than a
	// partial URL.
	// +crossplane:generate:reference:type=InstanceGroupManager
	// +crossplane:generate:reference:extractor=github.com/upbound/provider-gcp/config/compute.InstanceGroupExtractor()
	// +kubebuilder:validation:Optional
	Group *string `json:"group,omitempty" tf:"group,omitempty"`

	// Reference to a InstanceGroupManager to populate group.
	// +kubebuilder:validation:Optional
	GroupRef *v1.Reference `json:"groupRef,omitempty" tf:"-"`

	// Selector for a InstanceGroupManager to populate group.
	// +kubebuilder:validation:Optional
	GroupSelector *v1.Selector `json:"groupSelector,omitempty" tf:"-"`

	// The max number of simultaneous connections for the group. Can
	// be used with either CONNECTION or UTILIZATION balancing modes.
	// For CONNECTION mode, either maxConnections or one
	// of maxConnectionsPerInstance or maxConnectionsPerEndpoint,
	// as appropriate for group type, must be set.
	// +kubebuilder:validation:Optional
	MaxConnections *float64 `json:"maxConnections,omitempty" tf:"max_connections,omitempty"`

	// The max number of simultaneous connections that a single backend
	// network endpoint can handle. This is used to calculate the
	// capacity of the group. Can be used in either CONNECTION or
	// UTILIZATION balancing modes.
	// For CONNECTION mode, either
	// maxConnections or maxConnectionsPerEndpoint must be set.
	// +kubebuilder:validation:Optional
	MaxConnectionsPerEndpoint *float64 `json:"maxConnectionsPerEndpoint,omitempty" tf:"max_connections_per_endpoint,omitempty"`

	// The max number of simultaneous connections that a single
	// backend instance can handle. This is used to calculate the
	// capacity of the group. Can be used in either CONNECTION or
	// UTILIZATION balancing modes.
	// For CONNECTION mode, either maxConnections or
	// maxConnectionsPerInstance must be set.
	// +kubebuilder:validation:Optional
	MaxConnectionsPerInstance *float64 `json:"maxConnectionsPerInstance,omitempty" tf:"max_connections_per_instance,omitempty"`

	// The max requests per second (RPS) of the group.
	// Can be used with either RATE or UTILIZATION balancing modes,
	// but required if RATE mode. For RATE mode, either maxRate or one
	// of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
	// group type, must be set.
	// +kubebuilder:validation:Optional
	MaxRate *float64 `json:"maxRate,omitempty" tf:"max_rate,omitempty"`

	// The max requests per second (RPS) that a single backend network
	// endpoint can handle. This is used to calculate the capacity of
	// the group. Can be used in either balancing mode. For RATE mode,
	// either maxRate or maxRatePerEndpoint must be set.
	// +kubebuilder:validation:Optional
	MaxRatePerEndpoint *float64 `json:"maxRatePerEndpoint,omitempty" tf:"max_rate_per_endpoint,omitempty"`

	// The max requests per second (RPS) that a single backend
	// instance can handle. This is used to calculate the capacity of
	// the group. Can be used in either balancing mode. For RATE mode,
	// either maxRate or maxRatePerInstance must be set.
	// +kubebuilder:validation:Optional
	MaxRatePerInstance *float64 `json:"maxRatePerInstance,omitempty" tf:"max_rate_per_instance,omitempty"`

	// Used when balancingMode is UTILIZATION. This ratio defines the
	// CPU utilization target for the group. Valid range is [0.0, 1.0].
	// +kubebuilder:validation:Optional
	MaxUtilization *float64 `json:"maxUtilization,omitempty" tf:"max_utilization,omitempty"`
}

type BackendServiceCdnPolicyInitParameters struct {

	// Bypass the cache when the specified request headers are matched - e.g. Pragma or Authorization headers. Up to 5 headers can be specified.
	// The cache is bypassed for all cdnPolicy.cacheMode settings.
	// Structure is documented below.
	BypassCacheOnRequestHeaders []CdnPolicyBypassCacheOnRequestHeadersInitParameters `json:"bypassCacheOnRequestHeaders,omitempty" tf:"bypass_cache_on_request_headers,omitempty"`

	// The CacheKeyPolicy for this CdnPolicy.
	// Structure is documented below.
	CacheKeyPolicy []CdnPolicyCacheKeyPolicyInitParameters `json:"cacheKeyPolicy,omitempty" tf:"cache_key_policy,omitempty"`

	// Specifies the cache setting for all responses from this backend.
	// The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
	// Possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL, CACHE_ALL_STATIC.
	CacheMode *string `json:"cacheMode,omitempty" tf:"cache_mode,omitempty"`

	// Specifies the maximum allowed TTL for cached content served by this origin.
	ClientTTL *float64 `json:"clientTtl,omitempty" tf:"client_ttl,omitempty"`

	// Specifies the default TTL for cached content served by this origin for responses
	// that do not have an existing valid TTL (max-age or s-max-age).
	DefaultTTL *float64 `json:"defaultTtl,omitempty" tf:"default_ttl,omitempty"`

	// Specifies the maximum allowed TTL for cached content served by this origin.
	MaxTTL *float64 `json:"maxTtl,omitempty" tf:"max_ttl,omitempty"`

	// Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
	NegativeCaching *bool `json:"negativeCaching,omitempty" tf:"negative_caching,omitempty"`

	// Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
	// Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
	// Structure is documented below.
	NegativeCachingPolicy []CdnPolicyNegativeCachingPolicyInitParameters `json:"negativeCachingPolicy,omitempty" tf:"negative_caching_policy,omitempty"`

	// Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
	ServeWhileStale *float64 `json:"serveWhileStale,omitempty" tf:"serve_while_stale,omitempty"`

	// Maximum number of seconds the response to a signed URL request
	// will be considered fresh, defaults to 1hr (3600s). After this
	// time period, the response will be revalidated before
	// being served.
	// When serving responses to signed URL requests, Cloud CDN will
	// internally behave as though all responses from this backend had a
	// "Cache-Control: public, max-age=[TTL]" header, regardless of any
	// existing Cache-Control header. The actual headers served in
	// responses will not be altered.
	SignedURLCacheMaxAgeSec *float64 `json:"signedUrlCacheMaxAgeSec,omitempty" tf:"signed_url_cache_max_age_sec,omitempty"`
}

type BackendServiceCdnPolicyObservation struct {

	// Bypass the cache when the specified request headers are matched - e.g. Pragma or Authorization headers. Up to 5 headers can be specified.
	// The cache is bypassed for all cdnPolicy.cacheMode settings.
	// Structure is documented below.
	BypassCacheOnRequestHeaders []CdnPolicyBypassCacheOnRequestHeadersObservation `json:"bypassCacheOnRequestHeaders,omitempty" tf:"bypass_cache_on_request_headers,omitempty"`

	// The CacheKeyPolicy for this CdnPolicy.
	// Structure is documented below.
	CacheKeyPolicy []CdnPolicyCacheKeyPolicyObservation `json:"cacheKeyPolicy,omitempty" tf:"cache_key_policy,omitempty"`

	// Specifies the cache setting for all responses from this backend.
	// The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
	// Possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL, CACHE_ALL_STATIC.
	CacheMode *string `json:"cacheMode,omitempty" tf:"cache_mode,omitempty"`

	// Specifies the maximum allowed TTL for cached content served by this origin.
	ClientTTL *float64 `json:"clientTtl,omitempty" tf:"client_ttl,omitempty"`

	// Specifies the default TTL for cached content served by this origin for responses
	// that do not have an existing valid TTL (max-age or s-max-age).
	DefaultTTL *float64 `json:"defaultTtl,omitempty" tf:"default_ttl,omitempty"`

	// Specifies the maximum allowed TTL for cached content served by this origin.
	MaxTTL *float64 `json:"maxTtl,omitempty" tf:"max_ttl,omitempty"`

	// Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
	NegativeCaching *bool `json:"negativeCaching,omitempty" tf:"negative_caching,omitempty"`

	// Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
	// Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
	// Structure is documented below.
	NegativeCachingPolicy []CdnPolicyNegativeCachingPolicyObservation `json:"negativeCachingPolicy,omitempty" tf:"negative_caching_policy,omitempty"`

	// Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
	ServeWhileStale *float64 `json:"serveWhileStale,omitempty" tf:"serve_while_stale,omitempty"`

	// Maximum number of seconds the response to a signed URL request
	// will be considered fresh, defaults to 1hr (3600s). After this
	// time period, the response will be revalidated before
	// being served.
	// When serving responses to signed URL requests, Cloud CDN will
	// internally behave as though all responses from this backend had a
	// "Cache-Control: public, max-age=[TTL]" header, regardless of any
	// existing Cache-Control header. The actual headers served in
	// responses will not be altered.
	SignedURLCacheMaxAgeSec *float64 `json:"signedUrlCacheMaxAgeSec,omitempty" tf:"signed_url_cache_max_age_sec,omitempty"`
}

type BackendServiceCdnPolicyParameters struct {

	// Bypass the cache when the specified request headers are matched - e.g. Pragma or Authorization headers. Up to 5 headers can be specified.
	// The cache is bypassed for all cdnPolicy.cacheMode settings.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	BypassCacheOnRequestHeaders []CdnPolicyBypassCacheOnRequestHeadersParameters `json:"bypassCacheOnRequestHeaders,omitempty" tf:"bypass_cache_on_request_headers,omitempty"`

	// The CacheKeyPolicy for this CdnPolicy.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	CacheKeyPolicy []CdnPolicyCacheKeyPolicyParameters `json:"cacheKeyPolicy,omitempty" tf:"cache_key_policy,omitempty"`

	// Specifies the cache setting for all responses from this backend.
	// The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
	// Possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL, CACHE_ALL_STATIC.
	// +kubebuilder:validation:Optional
	CacheMode *string `json:"cacheMode,omitempty" tf:"cache_mode,omitempty"`

	// Specifies the maximum allowed TTL for cached content served by this origin.
	// +kubebuilder:validation:Optional
	ClientTTL *float64 `json:"clientTtl,omitempty" tf:"client_ttl,omitempty"`

	// Specifies the default TTL for cached content served by this origin for responses
	// that do not have an existing valid TTL (max-age or s-max-age).
	// +kubebuilder:validation:Optional
	DefaultTTL *float64 `json:"defaultTtl,omitempty" tf:"default_ttl,omitempty"`

	// Specifies the maximum allowed TTL for cached content served by this origin.
	// +kubebuilder:validation:Optional
	MaxTTL *float64 `json:"maxTtl,omitempty" tf:"max_ttl,omitempty"`

	// Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
	// +kubebuilder:validation:Optional
	NegativeCaching *bool `json:"negativeCaching,omitempty" tf:"negative_caching,omitempty"`

	// Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
	// Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	NegativeCachingPolicy []CdnPolicyNegativeCachingPolicyParameters `json:"negativeCachingPolicy,omitempty" tf:"negative_caching_policy,omitempty"`

	// Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
	// +kubebuilder:validation:Optional
	ServeWhileStale *float64 `json:"serveWhileStale,omitempty" tf:"serve_while_stale,omitempty"`

	// Maximum number of seconds the response to a signed URL request
	// will be considered fresh, defaults to 1hr (3600s). After this
	// time period, the response will be revalidated before
	// being served.
	// When serving responses to signed URL requests, Cloud CDN will
	// internally behave as though all responses from this backend had a
	// "Cache-Control: public, max-age=[TTL]" header, regardless of any
	// existing Cache-Control header. The actual headers served in
	// responses will not be altered.
	// +kubebuilder:validation:Optional
	SignedURLCacheMaxAgeSec *float64 `json:"signedUrlCacheMaxAgeSec,omitempty" tf:"signed_url_cache_max_age_sec,omitempty"`
}

type BackendServiceInitParameters struct {

	// Lifetime of cookies in seconds if session_affinity is
	// GENERATED_COOKIE. If set to 0, the cookie is non-persistent and lasts
	// only until the end of the browser session (or equivalent). The
	// maximum allowed value for TTL is one day.
	// When the load balancing scheme is INTERNAL, this field is not used.
	AffinityCookieTTLSec *float64 `json:"affinityCookieTtlSec,omitempty" tf:"affinity_cookie_ttl_sec,omitempty"`

	// The set of backends that serve this BackendService.
	// Structure is documented below.
	Backend []BackendInitParameters `json:"backend,omitempty" tf:"backend,omitempty"`

	// Cloud CDN configuration for this BackendService.
	// Structure is documented below.
	CdnPolicy []BackendServiceCdnPolicyInitParameters `json:"cdnPolicy,omitempty" tf:"cdn_policy,omitempty"`

	// Settings controlling the volume of connections to a backend service. This field
	// is applicable only when the load_balancing_scheme is set to INTERNAL_SELF_MANAGED.
	// Structure is documented below.
	CircuitBreakers []CircuitBreakersInitParameters `json:"circuitBreakers,omitempty" tf:"circuit_breakers,omitempty"`

	// Compress text responses using Brotli or gzip compression, based on the client's Accept-Encoding header.
	// Possible values are: AUTOMATIC, DISABLED.
	CompressionMode *string `json:"compressionMode,omitempty" tf:"compression_mode,omitempty"`

	// Time for which instance will be drained (not accept new
	// connections, but still work to finish started).
	ConnectionDrainingTimeoutSec *float64 `json:"connectionDrainingTimeoutSec,omitempty" tf:"connection_draining_timeout_sec,omitempty"`

	// Consistent Hash-based load balancing can be used to provide soft session
	// affinity based on HTTP headers, cookies or other properties. This load balancing
	// policy is applicable only for HTTP connections. The affinity to a particular
	// destination host will be lost when one or more hosts are added/removed from the
	// destination service. This field specifies parameters that control consistent
	// hashing. This field only applies if the load_balancing_scheme is set to
	// INTERNAL_SELF_MANAGED. This field is only applicable when locality_lb_policy is
	// set to MAGLEV or RING_HASH.
	// Structure is documented below.
	ConsistentHash []ConsistentHashInitParameters `json:"consistentHash,omitempty" tf:"consistent_hash,omitempty"`

	// Headers that the HTTP/S load balancer should add to proxied
	// requests.
	// +listType=set
	CustomRequestHeaders []*string `json:"customRequestHeaders,omitempty" tf:"custom_request_headers,omitempty"`

	// Headers that the HTTP/S load balancer should add to proxied
	// responses.
	// +listType=set
	CustomResponseHeaders []*string `json:"customResponseHeaders,omitempty" tf:"custom_response_headers,omitempty"`

	// An optional description of this resource.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The resource URL for the edge security policy associated with this backend service.
	EdgeSecurityPolicy *string `json:"edgeSecurityPolicy,omitempty" tf:"edge_security_policy,omitempty"`

	// If true, enable Cloud CDN for this BackendService.
	EnableCdn *bool `json:"enableCdn,omitempty" tf:"enable_cdn,omitempty"`

	// The set of URLs to the HttpHealthCheck or HttpsHealthCheck resource
	// for health checking this BackendService. Currently at most one health
	// check can be specified.
	// A health check must be specified unless the backend service uses an internet
	// or serverless NEG as a backend.
	// For internal load balancing, a URL to a HealthCheck resource must be specified instead.
	// +crossplane:generate:reference:type=HealthCheck
	// +crossplane:generate:reference:extractor=github.com/upbound/provider-gcp/config/common.SelfLinkExtractor()
	// +listType=set
	HealthChecks []*string `json:"healthChecks,omitempty" tf:"health_checks,omitempty"`

	// References to HealthCheck to populate healthChecks.
	// +kubebuilder:validation:Optional
	HealthChecksRefs []v1.Reference `json:"healthChecksRefs,omitempty" tf:"-"`

	// Selector for a list of HealthCheck to populate healthChecks.
	// +kubebuilder:validation:Optional
	HealthChecksSelector *v1.Selector `json:"healthChecksSelector,omitempty" tf:"-"`

	// Settings for enabling Cloud Identity Aware Proxy
	// Structure is documented below.
	Iap []IapInitParameters `json:"iap,omitempty" tf:"iap,omitempty"`

	// Indicates whether the backend service will be used with internal or
	// external load balancing. A backend service created for one type of
	// load balancing cannot be used with the other. For more information, refer to
	// Choosing a load balancer.
	// Default value is EXTERNAL.
	// Possible values are: EXTERNAL, INTERNAL_SELF_MANAGED, INTERNAL_MANAGED, EXTERNAL_MANAGED.
	LoadBalancingScheme *string `json:"loadBalancingScheme,omitempty" tf:"load_balancing_scheme,omitempty"`

	// A list of locality load balancing policies to be used in order of
	// preference. Either the policy or the customPolicy field should be set.
	// Overrides any value set in the localityLbPolicy field.
	// localityLbPolicies is only supported when the BackendService is referenced
	// by a URL Map that is referenced by a target gRPC proxy that has the
	// validateForProxyless field set to true.
	// Structure is documented below.
	LocalityLBPolicies []LocalityLBPoliciesInitParameters `json:"localityLbPolicies,omitempty" tf:"locality_lb_policies,omitempty"`

	// The load balancing algorithm used within the scope of the locality.
	// The possible values are:
	LocalityLBPolicy *string `json:"localityLbPolicy,omitempty" tf:"locality_lb_policy,omitempty"`

	// This field denotes the logging options for the load balancer traffic served by this backend service.
	// If logging is enabled, logs will be exported to Stackdriver.
	// Structure is documented below.
	LogConfig []LogConfigInitParameters `json:"logConfig,omitempty" tf:"log_config,omitempty"`

	// Settings controlling eviction of unhealthy hosts from the load balancing pool.
	// Applicable backend service types can be a global backend service with the
	// loadBalancingScheme set to INTERNAL_SELF_MANAGED or EXTERNAL_MANAGED.
	// Structure is documented below.
	OutlierDetection []OutlierDetectionInitParameters `json:"outlierDetection,omitempty" tf:"outlier_detection,omitempty"`

	// Name of backend port. The same name should appear in the instance
	// groups referenced by this service. Required when the load balancing
	// scheme is EXTERNAL.
	PortName *string `json:"portName,omitempty" tf:"port_name,omitempty"`

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// The protocol this BackendService uses to communicate with backends.
	// The default is HTTP. NOTE: HTTP2 is only valid for beta HTTP/2 load balancer
	// types and may result in errors if used with the GA API. NOTE: With protocol “UNSPECIFIED”,
	// the backend service can be used by Layer 4 Internal Load Balancing or Network Load Balancing
	// with TCP/UDP/L3_DEFAULT Forwarding Rule protocol.
	// Possible values are: HTTP, HTTPS, HTTP2, TCP, SSL, GRPC, UNSPECIFIED.
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// The security policy associated with this backend service.
	SecurityPolicy *string `json:"securityPolicy,omitempty" tf:"security_policy,omitempty"`

	// The security settings that apply to this backend service. This field is applicable to either
	// a regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and
	// load_balancing_scheme set to INTERNAL_MANAGED; or a global backend service with the
	// load_balancing_scheme set to INTERNAL_SELF_MANAGED.
	// Structure is documented below.
	SecuritySettings []SecuritySettingsInitParameters `json:"securitySettings,omitempty" tf:"security_settings,omitempty"`

	// Type of session affinity to use. The default is NONE. Session affinity is
	// not applicable if the protocol is UDP.
	// Possible values are: NONE, CLIENT_IP, CLIENT_IP_PORT_PROTO, CLIENT_IP_PROTO, GENERATED_COOKIE, HEADER_FIELD, HTTP_COOKIE.
	SessionAffinity *string `json:"sessionAffinity,omitempty" tf:"session_affinity,omitempty"`

	// How many seconds to wait for the backend before considering it a
	// failed request. Default is 30 seconds. Valid range is [1, 86400].
	TimeoutSec *float64 `json:"timeoutSec,omitempty" tf:"timeout_sec,omitempty"`
}

type BackendServiceObservation struct {

	// Lifetime of cookies in seconds if session_affinity is
	// GENERATED_COOKIE. If set to 0, the cookie is non-persistent and lasts
	// only until the end of the browser session (or equivalent). The
	// maximum allowed value for TTL is one day.
	// When the load balancing scheme is INTERNAL, this field is not used.
	AffinityCookieTTLSec *float64 `json:"affinityCookieTtlSec,omitempty" tf:"affinity_cookie_ttl_sec,omitempty"`

	// The set of backends that serve this BackendService.
	// Structure is documented below.
	Backend []BackendObservation `json:"backend,omitempty" tf:"backend,omitempty"`

	// Cloud CDN configuration for this BackendService.
	// Structure is documented below.
	CdnPolicy []BackendServiceCdnPolicyObservation `json:"cdnPolicy,omitempty" tf:"cdn_policy,omitempty"`

	// Settings controlling the volume of connections to a backend service. This field
	// is applicable only when the load_balancing_scheme is set to INTERNAL_SELF_MANAGED.
	// Structure is documented below.
	CircuitBreakers []CircuitBreakersObservation `json:"circuitBreakers,omitempty" tf:"circuit_breakers,omitempty"`

	// Compress text responses using Brotli or gzip compression, based on the client's Accept-Encoding header.
	// Possible values are: AUTOMATIC, DISABLED.
	CompressionMode *string `json:"compressionMode,omitempty" tf:"compression_mode,omitempty"`

	// Time for which instance will be drained (not accept new
	// connections, but still work to finish started).
	ConnectionDrainingTimeoutSec *float64 `json:"connectionDrainingTimeoutSec,omitempty" tf:"connection_draining_timeout_sec,omitempty"`

	// Consistent Hash-based load balancing can be used to provide soft session
	// affinity based on HTTP headers, cookies or other properties. This load balancing
	// policy is applicable only for HTTP connections. The affinity to a particular
	// destination host will be lost when one or more hosts are added/removed from the
	// destination service. This field specifies parameters that control consistent
	// hashing. This field only applies if the load_balancing_scheme is set to
	// INTERNAL_SELF_MANAGED. This field is only applicable when locality_lb_policy is
	// set to MAGLEV or RING_HASH.
	// Structure is documented below.
	ConsistentHash []ConsistentHashObservation `json:"consistentHash,omitempty" tf:"consistent_hash,omitempty"`

	// Creation timestamp in RFC3339 text format.
	CreationTimestamp *string `json:"creationTimestamp,omitempty" tf:"creation_timestamp,omitempty"`

	// Headers that the HTTP/S load balancer should add to proxied
	// requests.
	// +listType=set
	CustomRequestHeaders []*string `json:"customRequestHeaders,omitempty" tf:"custom_request_headers,omitempty"`

	// Headers that the HTTP/S load balancer should add to proxied
	// responses.
	// +listType=set
	CustomResponseHeaders []*string `json:"customResponseHeaders,omitempty" tf:"custom_response_headers,omitempty"`

	// An optional description of this resource.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The resource URL for the edge security policy associated with this backend service.
	EdgeSecurityPolicy *string `json:"edgeSecurityPolicy,omitempty" tf:"edge_security_policy,omitempty"`

	// If true, enable Cloud CDN for this BackendService.
	EnableCdn *bool `json:"enableCdn,omitempty" tf:"enable_cdn,omitempty"`

	// Fingerprint of this resource. A hash of the contents stored in this
	// object. This field is used in optimistic locking.
	Fingerprint *string `json:"fingerprint,omitempty" tf:"fingerprint,omitempty"`

	// The unique identifier for the resource. This identifier is defined by the server.
	GeneratedID *float64 `json:"generatedId,omitempty" tf:"generated_id,omitempty"`

	// The set of URLs to the HttpHealthCheck or HttpsHealthCheck resource
	// for health checking this BackendService. Currently at most one health
	// check can be specified.
	// A health check must be specified unless the backend service uses an internet
	// or serverless NEG as a backend.
	// For internal load balancing, a URL to a HealthCheck resource must be specified instead.
	// +listType=set
	HealthChecks []*string `json:"healthChecks,omitempty" tf:"health_checks,omitempty"`

	// an identifier for the resource with format projects/{{project}}/global/backendServices/{{name}}
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Settings for enabling Cloud Identity Aware Proxy
	// Structure is documented below.
	Iap []IapObservation `json:"iap,omitempty" tf:"iap,omitempty"`

	// Indicates whether the backend service will be used with internal or
	// external load balancing. A backend service created for one type of
	// load balancing cannot be used with the other. For more information, refer to
	// Choosing a load balancer.
	// Default value is EXTERNAL.
	// Possible values are: EXTERNAL, INTERNAL_SELF_MANAGED, INTERNAL_MANAGED, EXTERNAL_MANAGED.
	LoadBalancingScheme *string `json:"loadBalancingScheme,omitempty" tf:"load_balancing_scheme,omitempty"`

	// A list of locality load balancing policies to be used in order of
	// preference. Either the policy or the customPolicy field should be set.
	// Overrides any value set in the localityLbPolicy field.
	// localityLbPolicies is only supported when the BackendService is referenced
	// by a URL Map that is referenced by a target gRPC proxy that has the
	// validateForProxyless field set to true.
	// Structure is documented below.
	LocalityLBPolicies []LocalityLBPoliciesObservation `json:"localityLbPolicies,omitempty" tf:"locality_lb_policies,omitempty"`

	// The load balancing algorithm used within the scope of the locality.
	// The possible values are:
	LocalityLBPolicy *string `json:"localityLbPolicy,omitempty" tf:"locality_lb_policy,omitempty"`

	// This field denotes the logging options for the load balancer traffic served by this backend service.
	// If logging is enabled, logs will be exported to Stackdriver.
	// Structure is documented below.
	LogConfig []LogConfigObservation `json:"logConfig,omitempty" tf:"log_config,omitempty"`

	// Settings controlling eviction of unhealthy hosts from the load balancing pool.
	// Applicable backend service types can be a global backend service with the
	// loadBalancingScheme set to INTERNAL_SELF_MANAGED or EXTERNAL_MANAGED.
	// Structure is documented below.
	OutlierDetection []OutlierDetectionObservation `json:"outlierDetection,omitempty" tf:"outlier_detection,omitempty"`

	// Name of backend port. The same name should appear in the instance
	// groups referenced by this service. Required when the load balancing
	// scheme is EXTERNAL.
	PortName *string `json:"portName,omitempty" tf:"port_name,omitempty"`

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// The protocol this BackendService uses to communicate with backends.
	// The default is HTTP. NOTE: HTTP2 is only valid for beta HTTP/2 load balancer
	// types and may result in errors if used with the GA API. NOTE: With protocol “UNSPECIFIED”,
	// the backend service can be used by Layer 4 Internal Load Balancing or Network Load Balancing
	// with TCP/UDP/L3_DEFAULT Forwarding Rule protocol.
	// Possible values are: HTTP, HTTPS, HTTP2, TCP, SSL, GRPC, UNSPECIFIED.
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// The security policy associated with this backend service.
	SecurityPolicy *string `json:"securityPolicy,omitempty" tf:"security_policy,omitempty"`

	// The security settings that apply to this backend service. This field is applicable to either
	// a regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and
	// load_balancing_scheme set to INTERNAL_MANAGED; or a global backend service with the
	// load_balancing_scheme set to INTERNAL_SELF_MANAGED.
	// Structure is documented below.
	SecuritySettings []SecuritySettingsObservation `json:"securitySettings,omitempty" tf:"security_settings,omitempty"`

	// The URI of the created resource.
	SelfLink *string `json:"selfLink,omitempty" tf:"self_link,omitempty"`

	// Type of session affinity to use. The default is NONE. Session affinity is
	// not applicable if the protocol is UDP.
	// Possible values are: NONE, CLIENT_IP, CLIENT_IP_PORT_PROTO, CLIENT_IP_PROTO, GENERATED_COOKIE, HEADER_FIELD, HTTP_COOKIE.
	SessionAffinity *string `json:"sessionAffinity,omitempty" tf:"session_affinity,omitempty"`

	// How many seconds to wait for the backend before considering it a
	// failed request. Default is 30 seconds. Valid range is [1, 86400].
	TimeoutSec *float64 `json:"timeoutSec,omitempty" tf:"timeout_sec,omitempty"`
}

type BackendServiceParameters struct {

	// Lifetime of cookies in seconds if session_affinity is
	// GENERATED_COOKIE. If set to 0, the cookie is non-persistent and lasts
	// only until the end of the browser session (or equivalent). The
	// maximum allowed value for TTL is one day.
	// When the load balancing scheme is INTERNAL, this field is not used.
	// +kubebuilder:validation:Optional
	AffinityCookieTTLSec *float64 `json:"affinityCookieTtlSec,omitempty" tf:"affinity_cookie_ttl_sec,omitempty"`

	// The set of backends that serve this BackendService.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Backend []BackendParameters `json:"backend,omitempty" tf:"backend,omitempty"`

	// Cloud CDN configuration for this BackendService.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	CdnPolicy []BackendServiceCdnPolicyParameters `json:"cdnPolicy,omitempty" tf:"cdn_policy,omitempty"`

	// Settings controlling the volume of connections to a backend service. This field
	// is applicable only when the load_balancing_scheme is set to INTERNAL_SELF_MANAGED.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	CircuitBreakers []CircuitBreakersParameters `json:"circuitBreakers,omitempty" tf:"circuit_breakers,omitempty"`

	// Compress text responses using Brotli or gzip compression, based on the client's Accept-Encoding header.
	// Possible values are: AUTOMATIC, DISABLED.
	// +kubebuilder:validation:Optional
	CompressionMode *string `json:"compressionMode,omitempty" tf:"compression_mode,omitempty"`

	// Time for which instance will be drained (not accept new
	// connections, but still work to finish started).
	// +kubebuilder:validation:Optional
	ConnectionDrainingTimeoutSec *float64 `json:"connectionDrainingTimeoutSec,omitempty" tf:"connection_draining_timeout_sec,omitempty"`

	// Consistent Hash-based load balancing can be used to provide soft session
	// affinity based on HTTP headers, cookies or other properties. This load balancing
	// policy is applicable only for HTTP connections. The affinity to a particular
	// destination host will be lost when one or more hosts are added/removed from the
	// destination service. This field specifies parameters that control consistent
	// hashing. This field only applies if the load_balancing_scheme is set to
	// INTERNAL_SELF_MANAGED. This field is only applicable when locality_lb_policy is
	// set to MAGLEV or RING_HASH.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	ConsistentHash []ConsistentHashParameters `json:"consistentHash,omitempty" tf:"consistent_hash,omitempty"`

	// Headers that the HTTP/S load balancer should add to proxied
	// requests.
	// +kubebuilder:validation:Optional
	// +listType=set
	CustomRequestHeaders []*string `json:"customRequestHeaders,omitempty" tf:"custom_request_headers,omitempty"`

	// Headers that the HTTP/S load balancer should add to proxied
	// responses.
	// +kubebuilder:validation:Optional
	// +listType=set
	CustomResponseHeaders []*string `json:"customResponseHeaders,omitempty" tf:"custom_response_headers,omitempty"`

	// An optional description of this resource.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The resource URL for the edge security policy associated with this backend service.
	// +kubebuilder:validation:Optional
	EdgeSecurityPolicy *string `json:"edgeSecurityPolicy,omitempty" tf:"edge_security_policy,omitempty"`

	// If true, enable Cloud CDN for this BackendService.
	// +kubebuilder:validation:Optional
	EnableCdn *bool `json:"enableCdn,omitempty" tf:"enable_cdn,omitempty"`

	// The set of URLs to the HttpHealthCheck or HttpsHealthCheck resource
	// for health checking this BackendService. Currently at most one health
	// check can be specified.
	// A health check must be specified unless the backend service uses an internet
	// or serverless NEG as a backend.
	// For internal load balancing, a URL to a HealthCheck resource must be specified instead.
	// +crossplane:generate:reference:type=HealthCheck
	// +crossplane:generate:reference:extractor=github.com/upbound/provider-gcp/config/common.SelfLinkExtractor()
	// +kubebuilder:validation:Optional
	// +listType=set
	HealthChecks []*string `json:"healthChecks,omitempty" tf:"health_checks,omitempty"`

	// References to HealthCheck to populate healthChecks.
	// +kubebuilder:validation:Optional
	HealthChecksRefs []v1.Reference `json:"healthChecksRefs,omitempty" tf:"-"`

	// Selector for a list of HealthCheck to populate healthChecks.
	// +kubebuilder:validation:Optional
	HealthChecksSelector *v1.Selector `json:"healthChecksSelector,omitempty" tf:"-"`

	// Settings for enabling Cloud Identity Aware Proxy
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Iap []IapParameters `json:"iap,omitempty" tf:"iap,omitempty"`

	// Indicates whether the backend service will be used with internal or
	// external load balancing. A backend service created for one type of
	// load balancing cannot be used with the other. For more information, refer to
	// Choosing a load balancer.
	// Default value is EXTERNAL.
	// Possible values are: EXTERNAL, INTERNAL_SELF_MANAGED, INTERNAL_MANAGED, EXTERNAL_MANAGED.
	// +kubebuilder:validation:Optional
	LoadBalancingScheme *string `json:"loadBalancingScheme,omitempty" tf:"load_balancing_scheme,omitempty"`

	// A list of locality load balancing policies to be used in order of
	// preference. Either the policy or the customPolicy field should be set.
	// Overrides any value set in the localityLbPolicy field.
	// localityLbPolicies is only supported when the BackendService is referenced
	// by a URL Map that is referenced by a target gRPC proxy that has the
	// validateForProxyless field set to true.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	LocalityLBPolicies []LocalityLBPoliciesParameters `json:"localityLbPolicies,omitempty" tf:"locality_lb_policies,omitempty"`

	// The load balancing algorithm used within the scope of the locality.
	// The possible values are:
	// +kubebuilder:validation:Optional
	LocalityLBPolicy *string `json:"localityLbPolicy,omitempty" tf:"locality_lb_policy,omitempty"`

	// This field denotes the logging options for the load balancer traffic served by this backend service.
	// If logging is enabled, logs will be exported to Stackdriver.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	LogConfig []LogConfigParameters `json:"logConfig,omitempty" tf:"log_config,omitempty"`

	// Settings controlling eviction of unhealthy hosts from the load balancing pool.
	// Applicable backend service types can be a global backend service with the
	// loadBalancingScheme set to INTERNAL_SELF_MANAGED or EXTERNAL_MANAGED.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	OutlierDetection []OutlierDetectionParameters `json:"outlierDetection,omitempty" tf:"outlier_detection,omitempty"`

	// Name of backend port. The same name should appear in the instance
	// groups referenced by this service. Required when the load balancing
	// scheme is EXTERNAL.
	// +kubebuilder:validation:Optional
	PortName *string `json:"portName,omitempty" tf:"port_name,omitempty"`

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	// +kubebuilder:validation:Optional
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// The protocol this BackendService uses to communicate with backends.
	// The default is HTTP. NOTE: HTTP2 is only valid for beta HTTP/2 load balancer
	// types and may result in errors if used with the GA API. NOTE: With protocol “UNSPECIFIED”,
	// the backend service can be used by Layer 4 Internal Load Balancing or Network Load Balancing
	// with TCP/UDP/L3_DEFAULT Forwarding Rule protocol.
	// Possible values are: HTTP, HTTPS, HTTP2, TCP, SSL, GRPC, UNSPECIFIED.
	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// The security policy associated with this backend service.
	// +kubebuilder:validation:Optional
	SecurityPolicy *string `json:"securityPolicy,omitempty" tf:"security_policy,omitempty"`

	// The security settings that apply to this backend service. This field is applicable to either
	// a regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and
	// load_balancing_scheme set to INTERNAL_MANAGED; or a global backend service with the
	// load_balancing_scheme set to INTERNAL_SELF_MANAGED.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	SecuritySettings []SecuritySettingsParameters `json:"securitySettings,omitempty" tf:"security_settings,omitempty"`

	// Type of session affinity to use. The default is NONE. Session affinity is
	// not applicable if the protocol is UDP.
	// Possible values are: NONE, CLIENT_IP, CLIENT_IP_PORT_PROTO, CLIENT_IP_PROTO, GENERATED_COOKIE, HEADER_FIELD, HTTP_COOKIE.
	// +kubebuilder:validation:Optional
	SessionAffinity *string `json:"sessionAffinity,omitempty" tf:"session_affinity,omitempty"`

	// How many seconds to wait for the backend before considering it a
	// failed request. Default is 30 seconds. Valid range is [1, 86400].
	// +kubebuilder:validation:Optional
	TimeoutSec *float64 `json:"timeoutSec,omitempty" tf:"timeout_sec,omitempty"`
}

type BaseEjectionTimeInitParameters struct {

	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type BaseEjectionTimeObservation struct {

	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type BaseEjectionTimeParameters struct {

	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	// +kubebuilder:validation:Optional
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	// +kubebuilder:validation:Optional
	Seconds *float64 `json:"seconds" tf:"seconds,omitempty"`
}

type CdnPolicyBypassCacheOnRequestHeadersInitParameters struct {

	// The header field name to match on when bypassing cache. Values are case-insensitive.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`
}

type CdnPolicyBypassCacheOnRequestHeadersObservation struct {

	// The header field name to match on when bypassing cache. Values are case-insensitive.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`
}

type CdnPolicyBypassCacheOnRequestHeadersParameters struct {

	// The header field name to match on when bypassing cache. Values are case-insensitive.
	// +kubebuilder:validation:Optional
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`
}

type CdnPolicyCacheKeyPolicyInitParameters struct {

	// Allows HTTP request headers (by name) to be used in the
	// cache key.
	IncludeHTTPHeaders []*string `json:"includeHttpHeaders,omitempty" tf:"include_http_headers,omitempty"`

	// If true requests to different hosts will be cached separately.
	IncludeHost *bool `json:"includeHost,omitempty" tf:"include_host,omitempty"`

	// Names of cookies to include in cache keys.
	IncludeNamedCookies []*string `json:"includeNamedCookies,omitempty" tf:"include_named_cookies,omitempty"`

	// If true, http and https requests will be cached separately.
	IncludeProtocol *bool `json:"includeProtocol,omitempty" tf:"include_protocol,omitempty"`

	// If true, include query string parameters in the cache key
	// according to query_string_whitelist and
	// query_string_blacklist. If neither is set, the entire query
	// string will be included.
	// If false, the query string will be excluded from the cache
	// key entirely.
	IncludeQueryString *bool `json:"includeQueryString,omitempty" tf:"include_query_string,omitempty"`

	// Names of query string parameters to exclude in cache keys.
	// All other parameters will be included. Either specify
	// query_string_whitelist or query_string_blacklist, not both.
	// '&' and '=' will be percent encoded and not treated as
	// delimiters.
	// +listType=set
	QueryStringBlacklist []*string `json:"queryStringBlacklist,omitempty" tf:"query_string_blacklist,omitempty"`

	// Names of query string parameters to include in cache keys.
	// All other parameters will be excluded. Either specify
	// query_string_whitelist or query_string_blacklist, not both.
	// '&' and '=' will be percent encoded and not treated as
	// delimiters.
	// +listType=set
	QueryStringWhitelist []*string `json:"queryStringWhitelist,omitempty" tf:"query_string_whitelist,omitempty"`
}

type CdnPolicyCacheKeyPolicyObservation struct {

	// Allows HTTP request headers (by name) to be used in the
	// cache key.
	IncludeHTTPHeaders []*string `json:"includeHttpHeaders,omitempty" tf:"include_http_headers,omitempty"`

	// If true requests to different hosts will be cached separately.
	IncludeHost *bool `json:"includeHost,omitempty" tf:"include_host,omitempty"`

	// Names of cookies to include in cache keys.
	IncludeNamedCookies []*string `json:"includeNamedCookies,omitempty" tf:"include_named_cookies,omitempty"`

	// If true, http and https requests will be cached separately.
	IncludeProtocol *bool `json:"includeProtocol,omitempty" tf:"include_protocol,omitempty"`

	// If true, include query string parameters in the cache key
	// according to query_string_whitelist and
	// query_string_blacklist. If neither is set, the entire query
	// string will be included.
	// If false, the query string will be excluded from the cache
	// key entirely.
	IncludeQueryString *bool `json:"includeQueryString,omitempty" tf:"include_query_string,omitempty"`

	// Names of query string parameters to exclude in cache keys.
	// All other parameters will be included. Either specify
	// query_string_whitelist or query_string_blacklist, not both.
	// '&' and '=' will be percent encoded and not treated as
	// delimiters.
	// +listType=set
	QueryStringBlacklist []*string `json:"queryStringBlacklist,omitempty" tf:"query_string_blacklist,omitempty"`

	// Names of query string parameters to include in cache keys.
	// All other parameters will be excluded. Either specify
	// query_string_whitelist or query_string_blacklist, not both.
	// '&' and '=' will be percent encoded and not treated as
	// delimiters.
	// +listType=set
	QueryStringWhitelist []*string `json:"queryStringWhitelist,omitempty" tf:"query_string_whitelist,omitempty"`
}

type CdnPolicyCacheKeyPolicyParameters struct {

	// Allows HTTP request headers (by name) to be used in the
	// cache key.
	// +kubebuilder:validation:Optional
	IncludeHTTPHeaders []*string `json:"includeHttpHeaders,omitempty" tf:"include_http_headers,omitempty"`

	// If true requests to different hosts will be cached separately.
	// +kubebuilder:validation:Optional
	IncludeHost *bool `json:"includeHost,omitempty" tf:"include_host,omitempty"`

	// Names of cookies to include in cache keys.
	// +kubebuilder:validation:Optional
	IncludeNamedCookies []*string `json:"includeNamedCookies,omitempty" tf:"include_named_cookies,omitempty"`

	// If true, http and https requests will be cached separately.
	// +kubebuilder:validation:Optional
	IncludeProtocol *bool `json:"includeProtocol,omitempty" tf:"include_protocol,omitempty"`

	// If true, include query string parameters in the cache key
	// according to query_string_whitelist and
	// query_string_blacklist. If neither is set, the entire query
	// string will be included.
	// If false, the query string will be excluded from the cache
	// key entirely.
	// +kubebuilder:validation:Optional
	IncludeQueryString *bool `json:"includeQueryString,omitempty" tf:"include_query_string,omitempty"`

	// Names of query string parameters to exclude in cache keys.
	// All other parameters will be included. Either specify
	// query_string_whitelist or query_string_blacklist, not both.
	// '&' and '=' will be percent encoded and not treated as
	// delimiters.
	// +kubebuilder:validation:Optional
	// +listType=set
	QueryStringBlacklist []*string `json:"queryStringBlacklist,omitempty" tf:"query_string_blacklist,omitempty"`

	// Names of query string parameters to include in cache keys.
	// All other parameters will be excluded. Either specify
	// query_string_whitelist or query_string_blacklist, not both.
	// '&' and '=' will be percent encoded and not treated as
	// delimiters.
	// +kubebuilder:validation:Optional
	// +listType=set
	QueryStringWhitelist []*string `json:"queryStringWhitelist,omitempty" tf:"query_string_whitelist,omitempty"`
}

type CdnPolicyNegativeCachingPolicyInitParameters struct {

	// The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
	// can be specified as values, and you cannot specify a status code more than once.
	Code *float64 `json:"code,omitempty" tf:"code,omitempty"`

	// The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
	// (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
	TTL *float64 `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type CdnPolicyNegativeCachingPolicyObservation struct {

	// The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
	// can be specified as values, and you cannot specify a status code more than once.
	Code *float64 `json:"code,omitempty" tf:"code,omitempty"`

	// The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
	// (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
	TTL *float64 `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type CdnPolicyNegativeCachingPolicyParameters struct {

	// The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
	// can be specified as values, and you cannot specify a status code more than once.
	// +kubebuilder:validation:Optional
	Code *float64 `json:"code,omitempty" tf:"code,omitempty"`

	// The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
	// (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
	// +kubebuilder:validation:Optional
	TTL *float64 `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type CircuitBreakersInitParameters struct {

	// The maximum number of connections to the backend cluster.
	// Defaults to 1024.
	MaxConnections *float64 `json:"maxConnections,omitempty" tf:"max_connections,omitempty"`

	// The maximum number of pending requests to the backend cluster.
	// Defaults to 1024.
	MaxPendingRequests *float64 `json:"maxPendingRequests,omitempty" tf:"max_pending_requests,omitempty"`

	// The maximum number of parallel requests to the backend cluster.
	// Defaults to 1024.
	MaxRequests *float64 `json:"maxRequests,omitempty" tf:"max_requests,omitempty"`

	// Maximum requests for a single backend connection. This parameter
	// is respected by both the HTTP/1.1 and HTTP/2 implementations. If
	// not specified, there is no limit. Setting this parameter to 1
	// will effectively disable keep alive.
	MaxRequestsPerConnection *float64 `json:"maxRequestsPerConnection,omitempty" tf:"max_requests_per_connection,omitempty"`

	// The maximum number of parallel retries to the backend cluster.
	// Defaults to 3.
	MaxRetries *float64 `json:"maxRetries,omitempty" tf:"max_retries,omitempty"`
}

type CircuitBreakersObservation struct {

	// The maximum number of connections to the backend cluster.
	// Defaults to 1024.
	MaxConnections *float64 `json:"maxConnections,omitempty" tf:"max_connections,omitempty"`

	// The maximum number of pending requests to the backend cluster.
	// Defaults to 1024.
	MaxPendingRequests *float64 `json:"maxPendingRequests,omitempty" tf:"max_pending_requests,omitempty"`

	// The maximum number of parallel requests to the backend cluster.
	// Defaults to 1024.
	MaxRequests *float64 `json:"maxRequests,omitempty" tf:"max_requests,omitempty"`

	// Maximum requests for a single backend connection. This parameter
	// is respected by both the HTTP/1.1 and HTTP/2 implementations. If
	// not specified, there is no limit. Setting this parameter to 1
	// will effectively disable keep alive.
	MaxRequestsPerConnection *float64 `json:"maxRequestsPerConnection,omitempty" tf:"max_requests_per_connection,omitempty"`

	// The maximum number of parallel retries to the backend cluster.
	// Defaults to 3.
	MaxRetries *float64 `json:"maxRetries,omitempty" tf:"max_retries,omitempty"`
}

type CircuitBreakersParameters struct {

	// The maximum number of connections to the backend cluster.
	// Defaults to 1024.
	// +kubebuilder:validation:Optional
	MaxConnections *float64 `json:"maxConnections,omitempty" tf:"max_connections,omitempty"`

	// The maximum number of pending requests to the backend cluster.
	// Defaults to 1024.
	// +kubebuilder:validation:Optional
	MaxPendingRequests *float64 `json:"maxPendingRequests,omitempty" tf:"max_pending_requests,omitempty"`

	// The maximum number of parallel requests to the backend cluster.
	// Defaults to 1024.
	// +kubebuilder:validation:Optional
	MaxRequests *float64 `json:"maxRequests,omitempty" tf:"max_requests,omitempty"`

	// Maximum requests for a single backend connection. This parameter
	// is respected by both the HTTP/1.1 and HTTP/2 implementations. If
	// not specified, there is no limit. Setting this parameter to 1
	// will effectively disable keep alive.
	// +kubebuilder:validation:Optional
	MaxRequestsPerConnection *float64 `json:"maxRequestsPerConnection,omitempty" tf:"max_requests_per_connection,omitempty"`

	// The maximum number of parallel retries to the backend cluster.
	// Defaults to 3.
	// +kubebuilder:validation:Optional
	MaxRetries *float64 `json:"maxRetries,omitempty" tf:"max_retries,omitempty"`
}

type ConsistentHashInitParameters struct {

	// Hash is based on HTTP Cookie. This field describes a HTTP cookie
	// that will be used as the hash key for the consistent hash load
	// balancer. If the cookie is not present, it will be generated.
	// This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
	// Structure is documented below.
	HTTPCookie []HTTPCookieInitParameters `json:"httpCookie,omitempty" tf:"http_cookie,omitempty"`

	// The hash based on the value of the specified header field.
	// This field is applicable if the sessionAffinity is set to HEADER_FIELD.
	HTTPHeaderName *string `json:"httpHeaderName,omitempty" tf:"http_header_name,omitempty"`

	// The minimum number of virtual nodes to use for the hash ring.
	// Larger ring sizes result in more granular load
	// distributions. If the number of hosts in the load balancing pool
	// is larger than the ring size, each host will be assigned a single
	// virtual node.
	// Defaults to 1024.
	MinimumRingSize *float64 `json:"minimumRingSize,omitempty" tf:"minimum_ring_size,omitempty"`
}

type ConsistentHashObservation struct {

	// Hash is based on HTTP Cookie. This field describes a HTTP cookie
	// that will be used as the hash key for the consistent hash load
	// balancer. If the cookie is not present, it will be generated.
	// This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
	// Structure is documented below.
	HTTPCookie []HTTPCookieObservation `json:"httpCookie,omitempty" tf:"http_cookie,omitempty"`

	// The hash based on the value of the specified header field.
	// This field is applicable if the sessionAffinity is set to HEADER_FIELD.
	HTTPHeaderName *string `json:"httpHeaderName,omitempty" tf:"http_header_name,omitempty"`

	// The minimum number of virtual nodes to use for the hash ring.
	// Larger ring sizes result in more granular load
	// distributions. If the number of hosts in the load balancing pool
	// is larger than the ring size, each host will be assigned a single
	// virtual node.
	// Defaults to 1024.
	MinimumRingSize *float64 `json:"minimumRingSize,omitempty" tf:"minimum_ring_size,omitempty"`
}

type ConsistentHashParameters struct {

	// Hash is based on HTTP Cookie. This field describes a HTTP cookie
	// that will be used as the hash key for the consistent hash load
	// balancer. If the cookie is not present, it will be generated.
	// This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	HTTPCookie []HTTPCookieParameters `json:"httpCookie,omitempty" tf:"http_cookie,omitempty"`

	// The hash based on the value of the specified header field.
	// This field is applicable if the sessionAffinity is set to HEADER_FIELD.
	// +kubebuilder:validation:Optional
	HTTPHeaderName *string `json:"httpHeaderName,omitempty" tf:"http_header_name,omitempty"`

	// The minimum number of virtual nodes to use for the hash ring.
	// Larger ring sizes result in more granular load
	// distributions. If the number of hosts in the load balancing pool
	// is larger than the ring size, each host will be assigned a single
	// virtual node.
	// Defaults to 1024.
	// +kubebuilder:validation:Optional
	MinimumRingSize *float64 `json:"minimumRingSize,omitempty" tf:"minimum_ring_size,omitempty"`
}

type CustomPolicyInitParameters struct {

	// An optional, arbitrary JSON object with configuration data, understood
	// by a locally installed custom policy implementation.
	Data *string `json:"data,omitempty" tf:"data,omitempty"`

	// The name of a locality load balancer policy to be used. The value
	// should be one of the predefined ones as supported by localityLbPolicy,
	// although at the moment only ROUND_ROBIN is supported.
	// This field should only be populated when the customPolicy field is not
	// used.
	// Note that specifying the same policy more than once for a backend is
	// not a valid configuration and will be rejected.
	// The possible values are:
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type CustomPolicyObservation struct {

	// An optional, arbitrary JSON object with configuration data, understood
	// by a locally installed custom policy implementation.
	Data *string `json:"data,omitempty" tf:"data,omitempty"`

	// The name of a locality load balancer policy to be used. The value
	// should be one of the predefined ones as supported by localityLbPolicy,
	// although at the moment only ROUND_ROBIN is supported.
	// This field should only be populated when the customPolicy field is not
	// used.
	// Note that specifying the same policy more than once for a backend is
	// not a valid configuration and will be rejected.
	// The possible values are:
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type CustomPolicyParameters struct {

	// An optional, arbitrary JSON object with configuration data, understood
	// by a locally installed custom policy implementation.
	// +kubebuilder:validation:Optional
	Data *string `json:"data,omitempty" tf:"data,omitempty"`

	// The name of a locality load balancer policy to be used. The value
	// should be one of the predefined ones as supported by localityLbPolicy,
	// although at the moment only ROUND_ROBIN is supported.
	// This field should only be populated when the customPolicy field is not
	// used.
	// Note that specifying the same policy more than once for a backend is
	// not a valid configuration and will be rejected.
	// The possible values are:
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`
}

type HTTPCookieInitParameters struct {

	// The name of a locality load balancer policy to be used. The value
	// should be one of the predefined ones as supported by localityLbPolicy,
	// although at the moment only ROUND_ROBIN is supported.
	// This field should only be populated when the customPolicy field is not
	// used.
	// Note that specifying the same policy more than once for a backend is
	// not a valid configuration and will be rejected.
	// The possible values are:
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Path to set for the cookie.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
	// (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
	TTL []TTLInitParameters `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type HTTPCookieObservation struct {

	// The name of a locality load balancer policy to be used. The value
	// should be one of the predefined ones as supported by localityLbPolicy,
	// although at the moment only ROUND_ROBIN is supported.
	// This field should only be populated when the customPolicy field is not
	// used.
	// Note that specifying the same policy more than once for a backend is
	// not a valid configuration and will be rejected.
	// The possible values are:
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Path to set for the cookie.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
	// (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
	TTL []TTLObservation `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type HTTPCookieParameters struct {

	// The name of a locality load balancer policy to be used. The value
	// should be one of the predefined ones as supported by localityLbPolicy,
	// although at the moment only ROUND_ROBIN is supported.
	// This field should only be populated when the customPolicy field is not
	// used.
	// Note that specifying the same policy more than once for a backend is
	// not a valid configuration and will be rejected.
	// The possible values are:
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Path to set for the cookie.
	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
	// (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
	// +kubebuilder:validation:Optional
	TTL []TTLParameters `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type IapInitParameters struct {

	// OAuth2 Client ID for IAP
	Oauth2ClientID *string `json:"oauth2ClientId,omitempty" tf:"oauth2_client_id,omitempty"`
}

type IapObservation struct {

	// OAuth2 Client ID for IAP
	Oauth2ClientID *string `json:"oauth2ClientId,omitempty" tf:"oauth2_client_id,omitempty"`
}

type IapParameters struct {

	// OAuth2 Client ID for IAP
	// +kubebuilder:validation:Optional
	Oauth2ClientID *string `json:"oauth2ClientId" tf:"oauth2_client_id,omitempty"`

	// OAuth2 Client Secret for IAP
	// Note: This property is sensitive and will not be displayed in the plan.
	// +kubebuilder:validation:Required
	Oauth2ClientSecretSecretRef v1.SecretKeySelector `json:"oauth2ClientSecretSecretRef" tf:"-"`
}

type IntervalInitParameters struct {

	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type IntervalObservation struct {

	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type IntervalParameters struct {

	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	// +kubebuilder:validation:Optional
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	// +kubebuilder:validation:Optional
	Seconds *float64 `json:"seconds" tf:"seconds,omitempty"`
}

type LocalityLBPoliciesInitParameters struct {

	// The configuration for a custom policy implemented by the user and
	// deployed with the client.
	// Structure is documented below.
	CustomPolicy []CustomPolicyInitParameters `json:"customPolicy,omitempty" tf:"custom_policy,omitempty"`

	// The configuration for a built-in load balancing policy.
	// Structure is documented below.
	Policy []PolicyInitParameters `json:"policy,omitempty" tf:"policy,omitempty"`
}

type LocalityLBPoliciesObservation struct {

	// The configuration for a custom policy implemented by the user and
	// deployed with the client.
	// Structure is documented below.
	CustomPolicy []CustomPolicyObservation `json:"customPolicy,omitempty" tf:"custom_policy,omitempty"`

	// The configuration for a built-in load balancing policy.
	// Structure is documented below.
	Policy []PolicyObservation `json:"policy,omitempty" tf:"policy,omitempty"`
}

type LocalityLBPoliciesParameters struct {

	// The configuration for a custom policy implemented by the user and
	// deployed with the client.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	CustomPolicy []CustomPolicyParameters `json:"customPolicy,omitempty" tf:"custom_policy,omitempty"`

	// The configuration for a built-in load balancing policy.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Policy []PolicyParameters `json:"policy,omitempty" tf:"policy,omitempty"`
}

type LogConfigInitParameters struct {

	// Whether to enable logging for the load balancer traffic served by this backend service.
	Enable *bool `json:"enable,omitempty" tf:"enable,omitempty"`

	// This field can only be specified if logging is enabled for this backend service. The value of
	// the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
	// where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
	// The default value is 1.0.
	SampleRate *float64 `json:"sampleRate,omitempty" tf:"sample_rate,omitempty"`
}

type LogConfigObservation struct {

	// Whether to enable logging for the load balancer traffic served by this backend service.
	Enable *bool `json:"enable,omitempty" tf:"enable,omitempty"`

	// This field can only be specified if logging is enabled for this backend service. The value of
	// the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
	// where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
	// The default value is 1.0.
	SampleRate *float64 `json:"sampleRate,omitempty" tf:"sample_rate,omitempty"`
}

type LogConfigParameters struct {

	// Whether to enable logging for the load balancer traffic served by this backend service.
	// +kubebuilder:validation:Optional
	Enable *bool `json:"enable,omitempty" tf:"enable,omitempty"`

	// This field can only be specified if logging is enabled for this backend service. The value of
	// the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
	// where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
	// The default value is 1.0.
	// +kubebuilder:validation:Optional
	SampleRate *float64 `json:"sampleRate,omitempty" tf:"sample_rate,omitempty"`
}

type OutlierDetectionInitParameters struct {

	// The base time that a host is ejected for. The real time is equal to the base
	// time multiplied by the number of times the host has been ejected. Defaults to
	// 30000ms or 30s.
	// Structure is documented below.
	BaseEjectionTime []BaseEjectionTimeInitParameters `json:"baseEjectionTime,omitempty" tf:"base_ejection_time,omitempty"`

	// Number of errors before a host is ejected from the connection pool. When the
	// backend host is accessed over HTTP, a 5xx return code qualifies as an error.
	// Defaults to 5.
	ConsecutiveErrors *float64 `json:"consecutiveErrors,omitempty" tf:"consecutive_errors,omitempty"`

	// The number of consecutive gateway failures (502, 503, 504 status or connection
	// errors that are mapped to one of those status codes) before a consecutive
	// gateway failure ejection occurs. Defaults to 5.
	ConsecutiveGatewayFailure *float64 `json:"consecutiveGatewayFailure,omitempty" tf:"consecutive_gateway_failure,omitempty"`

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through consecutive 5xx. This setting can be used to disable
	// ejection or to ramp it up slowly. Defaults to 100.
	EnforcingConsecutiveErrors *float64 `json:"enforcingConsecutiveErrors,omitempty" tf:"enforcing_consecutive_errors,omitempty"`

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through consecutive gateway failures. This setting can be
	// used to disable ejection or to ramp it up slowly. Defaults to 0.
	EnforcingConsecutiveGatewayFailure *float64 `json:"enforcingConsecutiveGatewayFailure,omitempty" tf:"enforcing_consecutive_gateway_failure,omitempty"`

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through success rate statistics. This setting can be used to
	// disable ejection or to ramp it up slowly. Defaults to 100.
	EnforcingSuccessRate *float64 `json:"enforcingSuccessRate,omitempty" tf:"enforcing_success_rate,omitempty"`

	// Time interval between ejection sweep analysis. This can result in both new
	// ejections as well as hosts being returned to service. Defaults to 10 seconds.
	// Structure is documented below.
	Interval []IntervalInitParameters `json:"interval,omitempty" tf:"interval,omitempty"`

	// Maximum percentage of hosts in the load balancing pool for the backend service
	// that can be ejected. Defaults to 10%.
	MaxEjectionPercent *float64 `json:"maxEjectionPercent,omitempty" tf:"max_ejection_percent,omitempty"`

	// The number of hosts in a cluster that must have enough request volume to detect
	// success rate outliers. If the number of hosts is less than this setting, outlier
	// detection via success rate statistics is not performed for any host in the
	// cluster. Defaults to 5.
	SuccessRateMinimumHosts *float64 `json:"successRateMinimumHosts,omitempty" tf:"success_rate_minimum_hosts,omitempty"`

	// The minimum number of total requests that must be collected in one interval (as
	// defined by the interval duration above) to include this host in success rate
	// based outlier detection. If the volume is lower than this setting, outlier
	// detection via success rate statistics is not performed for that host. Defaults
	// to 100.
	SuccessRateRequestVolume *float64 `json:"successRateRequestVolume,omitempty" tf:"success_rate_request_volume,omitempty"`

	// This factor is used to determine the ejection threshold for success rate outlier
	// ejection. The ejection threshold is the difference between the mean success
	// rate, and the product of this factor and the standard deviation of the mean
	// success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
	// by a thousand to get a double. That is, if the desired factor is 1.9, the
	// runtime value should be 1900. Defaults to 1900.
	SuccessRateStdevFactor *float64 `json:"successRateStdevFactor,omitempty" tf:"success_rate_stdev_factor,omitempty"`
}

type OutlierDetectionObservation struct {

	// The base time that a host is ejected for. The real time is equal to the base
	// time multiplied by the number of times the host has been ejected. Defaults to
	// 30000ms or 30s.
	// Structure is documented below.
	BaseEjectionTime []BaseEjectionTimeObservation `json:"baseEjectionTime,omitempty" tf:"base_ejection_time,omitempty"`

	// Number of errors before a host is ejected from the connection pool. When the
	// backend host is accessed over HTTP, a 5xx return code qualifies as an error.
	// Defaults to 5.
	ConsecutiveErrors *float64 `json:"consecutiveErrors,omitempty" tf:"consecutive_errors,omitempty"`

	// The number of consecutive gateway failures (502, 503, 504 status or connection
	// errors that are mapped to one of those status codes) before a consecutive
	// gateway failure ejection occurs. Defaults to 5.
	ConsecutiveGatewayFailure *float64 `json:"consecutiveGatewayFailure,omitempty" tf:"consecutive_gateway_failure,omitempty"`

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through consecutive 5xx. This setting can be used to disable
	// ejection or to ramp it up slowly. Defaults to 100.
	EnforcingConsecutiveErrors *float64 `json:"enforcingConsecutiveErrors,omitempty" tf:"enforcing_consecutive_errors,omitempty"`

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through consecutive gateway failures. This setting can be
	// used to disable ejection or to ramp it up slowly. Defaults to 0.
	EnforcingConsecutiveGatewayFailure *float64 `json:"enforcingConsecutiveGatewayFailure,omitempty" tf:"enforcing_consecutive_gateway_failure,omitempty"`

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through success rate statistics. This setting can be used to
	// disable ejection or to ramp it up slowly. Defaults to 100.
	EnforcingSuccessRate *float64 `json:"enforcingSuccessRate,omitempty" tf:"enforcing_success_rate,omitempty"`

	// Time interval between ejection sweep analysis. This can result in both new
	// ejections as well as hosts being returned to service. Defaults to 10 seconds.
	// Structure is documented below.
	Interval []IntervalObservation `json:"interval,omitempty" tf:"interval,omitempty"`

	// Maximum percentage of hosts in the load balancing pool for the backend service
	// that can be ejected. Defaults to 10%.
	MaxEjectionPercent *float64 `json:"maxEjectionPercent,omitempty" tf:"max_ejection_percent,omitempty"`

	// The number of hosts in a cluster that must have enough request volume to detect
	// success rate outliers. If the number of hosts is less than this setting, outlier
	// detection via success rate statistics is not performed for any host in the
	// cluster. Defaults to 5.
	SuccessRateMinimumHosts *float64 `json:"successRateMinimumHosts,omitempty" tf:"success_rate_minimum_hosts,omitempty"`

	// The minimum number of total requests that must be collected in one interval (as
	// defined by the interval duration above) to include this host in success rate
	// based outlier detection. If the volume is lower than this setting, outlier
	// detection via success rate statistics is not performed for that host. Defaults
	// to 100.
	SuccessRateRequestVolume *float64 `json:"successRateRequestVolume,omitempty" tf:"success_rate_request_volume,omitempty"`

	// This factor is used to determine the ejection threshold for success rate outlier
	// ejection. The ejection threshold is the difference between the mean success
	// rate, and the product of this factor and the standard deviation of the mean
	// success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
	// by a thousand to get a double. That is, if the desired factor is 1.9, the
	// runtime value should be 1900. Defaults to 1900.
	SuccessRateStdevFactor *float64 `json:"successRateStdevFactor,omitempty" tf:"success_rate_stdev_factor,omitempty"`
}

type OutlierDetectionParameters struct {

	// The base time that a host is ejected for. The real time is equal to the base
	// time multiplied by the number of times the host has been ejected. Defaults to
	// 30000ms or 30s.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	BaseEjectionTime []BaseEjectionTimeParameters `json:"baseEjectionTime,omitempty" tf:"base_ejection_time,omitempty"`

	// Number of errors before a host is ejected from the connection pool. When the
	// backend host is accessed over HTTP, a 5xx return code qualifies as an error.
	// Defaults to 5.
	// +kubebuilder:validation:Optional
	ConsecutiveErrors *float64 `json:"consecutiveErrors,omitempty" tf:"consecutive_errors,omitempty"`

	// The number of consecutive gateway failures (502, 503, 504 status or connection
	// errors that are mapped to one of those status codes) before a consecutive
	// gateway failure ejection occurs. Defaults to 5.
	// +kubebuilder:validation:Optional
	ConsecutiveGatewayFailure *float64 `json:"consecutiveGatewayFailure,omitempty" tf:"consecutive_gateway_failure,omitempty"`

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through consecutive 5xx. This setting can be used to disable
	// ejection or to ramp it up slowly. Defaults to 100.
	// +kubebuilder:validation:Optional
	EnforcingConsecutiveErrors *float64 `json:"enforcingConsecutiveErrors,omitempty" tf:"enforcing_consecutive_errors,omitempty"`

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through consecutive gateway failures. This setting can be
	// used to disable ejection or to ramp it up slowly. Defaults to 0.
	// +kubebuilder:validation:Optional
	EnforcingConsecutiveGatewayFailure *float64 `json:"enforcingConsecutiveGatewayFailure,omitempty" tf:"enforcing_consecutive_gateway_failure,omitempty"`

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through success rate statistics. This setting can be used to
	// disable ejection or to ramp it up slowly. Defaults to 100.
	// +kubebuilder:validation:Optional
	EnforcingSuccessRate *float64 `json:"enforcingSuccessRate,omitempty" tf:"enforcing_success_rate,omitempty"`

	// Time interval between ejection sweep analysis. This can result in both new
	// ejections as well as hosts being returned to service. Defaults to 10 seconds.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Interval []IntervalParameters `json:"interval,omitempty" tf:"interval,omitempty"`

	// Maximum percentage of hosts in the load balancing pool for the backend service
	// that can be ejected. Defaults to 10%.
	// +kubebuilder:validation:Optional
	MaxEjectionPercent *float64 `json:"maxEjectionPercent,omitempty" tf:"max_ejection_percent,omitempty"`

	// The number of hosts in a cluster that must have enough request volume to detect
	// success rate outliers. If the number of hosts is less than this setting, outlier
	// detection via success rate statistics is not performed for any host in the
	// cluster. Defaults to 5.
	// +kubebuilder:validation:Optional
	SuccessRateMinimumHosts *float64 `json:"successRateMinimumHosts,omitempty" tf:"success_rate_minimum_hosts,omitempty"`

	// The minimum number of total requests that must be collected in one interval (as
	// defined by the interval duration above) to include this host in success rate
	// based outlier detection. If the volume is lower than this setting, outlier
	// detection via success rate statistics is not performed for that host. Defaults
	// to 100.
	// +kubebuilder:validation:Optional
	SuccessRateRequestVolume *float64 `json:"successRateRequestVolume,omitempty" tf:"success_rate_request_volume,omitempty"`

	// This factor is used to determine the ejection threshold for success rate outlier
	// ejection. The ejection threshold is the difference between the mean success
	// rate, and the product of this factor and the standard deviation of the mean
	// success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
	// by a thousand to get a double. That is, if the desired factor is 1.9, the
	// runtime value should be 1900. Defaults to 1900.
	// +kubebuilder:validation:Optional
	SuccessRateStdevFactor *float64 `json:"successRateStdevFactor,omitempty" tf:"success_rate_stdev_factor,omitempty"`
}

type PolicyInitParameters struct {

	// The name of a locality load balancer policy to be used. The value
	// should be one of the predefined ones as supported by localityLbPolicy,
	// although at the moment only ROUND_ROBIN is supported.
	// This field should only be populated when the customPolicy field is not
	// used.
	// Note that specifying the same policy more than once for a backend is
	// not a valid configuration and will be rejected.
	// The possible values are:
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type PolicyObservation struct {

	// The name of a locality load balancer policy to be used. The value
	// should be one of the predefined ones as supported by localityLbPolicy,
	// although at the moment only ROUND_ROBIN is supported.
	// This field should only be populated when the customPolicy field is not
	// used.
	// Note that specifying the same policy more than once for a backend is
	// not a valid configuration and will be rejected.
	// The possible values are:
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type PolicyParameters struct {

	// The name of a locality load balancer policy to be used. The value
	// should be one of the predefined ones as supported by localityLbPolicy,
	// although at the moment only ROUND_ROBIN is supported.
	// This field should only be populated when the customPolicy field is not
	// used.
	// Note that specifying the same policy more than once for a backend is
	// not a valid configuration and will be rejected.
	// The possible values are:
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`
}

type SecuritySettingsInitParameters struct {

	// ClientTlsPolicy is a resource that specifies how a client should authenticate
	// connections to backends of a service. This resource itself does not affect
	// configuration unless it is attached to a backend service resource.
	ClientTLSPolicy *string `json:"clientTlsPolicy,omitempty" tf:"client_tls_policy,omitempty"`

	// A list of alternate names to verify the subject identity in the certificate.
	// If specified, the client will verify that the server certificate's subject
	// alt name matches one of the specified values.
	SubjectAltNames []*string `json:"subjectAltNames,omitempty" tf:"subject_alt_names,omitempty"`
}

type SecuritySettingsObservation struct {

	// ClientTlsPolicy is a resource that specifies how a client should authenticate
	// connections to backends of a service. This resource itself does not affect
	// configuration unless it is attached to a backend service resource.
	ClientTLSPolicy *string `json:"clientTlsPolicy,omitempty" tf:"client_tls_policy,omitempty"`

	// A list of alternate names to verify the subject identity in the certificate.
	// If specified, the client will verify that the server certificate's subject
	// alt name matches one of the specified values.
	SubjectAltNames []*string `json:"subjectAltNames,omitempty" tf:"subject_alt_names,omitempty"`
}

type SecuritySettingsParameters struct {

	// ClientTlsPolicy is a resource that specifies how a client should authenticate
	// connections to backends of a service. This resource itself does not affect
	// configuration unless it is attached to a backend service resource.
	// +kubebuilder:validation:Optional
	ClientTLSPolicy *string `json:"clientTlsPolicy" tf:"client_tls_policy,omitempty"`

	// A list of alternate names to verify the subject identity in the certificate.
	// If specified, the client will verify that the server certificate's subject
	// alt name matches one of the specified values.
	// +kubebuilder:validation:Optional
	SubjectAltNames []*string `json:"subjectAltNames" tf:"subject_alt_names,omitempty"`
}

type TTLInitParameters struct {

	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type TTLObservation struct {

	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type TTLParameters struct {

	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	// +kubebuilder:validation:Optional
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	// +kubebuilder:validation:Optional
	Seconds *float64 `json:"seconds" tf:"seconds,omitempty"`
}

// BackendServiceSpec defines the desired state of BackendService
type BackendServiceSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     BackendServiceParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider BackendServiceInitParameters `json:"initProvider,omitempty"`
}

// BackendServiceStatus defines the observed state of BackendService.
type BackendServiceStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        BackendServiceObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// BackendService is the Schema for the BackendServices API. A Backend Service defines a group of virtual machines that will serve traffic for load balancing.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcp}
type BackendService struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              BackendServiceSpec   `json:"spec"`
	Status            BackendServiceStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// BackendServiceList contains a list of BackendServices
type BackendServiceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []BackendService `json:"items"`
}

// Repository type metadata.
var (
	BackendService_Kind             = "BackendService"
	BackendService_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: BackendService_Kind}.String()
	BackendService_KindAPIVersion   = BackendService_Kind + "." + CRDGroupVersion.String()
	BackendService_GroupVersionKind = CRDGroupVersion.WithKind(BackendService_Kind)
)

func init() {
	SchemeBuilder.Register(&BackendService{}, &BackendServiceList{})
}
