// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type DefaultRouteActionCorsPolicyInitParameters struct {

	// In response to a preflight request, setting this to true indicates that the
	// actual request can include user credentials. This translates to the Access-
	// Control-Allow-Credentials header. Defaults to false.
	AllowCredentials *bool `json:"allowCredentials,omitempty" tf:"allow_credentials,omitempty"`

	// Specifies the content for the Access-Control-Allow-Headers header.
	AllowHeaders []*string `json:"allowHeaders,omitempty" tf:"allow_headers,omitempty"`

	// Specifies the content for the Access-Control-Allow-Methods header.
	AllowMethods []*string `json:"allowMethods,omitempty" tf:"allow_methods,omitempty"`

	// Specifies the regular expression patterns that match allowed origins. For
	// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
	// An origin is allowed if it matches either allow_origins or allow_origin_regex.
	AllowOriginRegexes []*string `json:"allowOriginRegexes,omitempty" tf:"allow_origin_regexes,omitempty"`

	// Specifies the list of origins that will be allowed to do CORS requests. An
	// origin is allowed if it matches either allow_origins or allow_origin_regex.
	AllowOrigins []*string `json:"allowOrigins,omitempty" tf:"allow_origins,omitempty"`

	// If true, specifies the CORS policy is disabled.
	Disabled *bool `json:"disabled,omitempty" tf:"disabled,omitempty"`

	// Specifies the content for the Access-Control-Expose-Headers header.
	ExposeHeaders []*string `json:"exposeHeaders,omitempty" tf:"expose_headers,omitempty"`

	// Specifies how long the results of a preflight request can be cached. This
	// translates to the content for the Access-Control-Max-Age header.
	MaxAge *float64 `json:"maxAge,omitempty" tf:"max_age,omitempty"`
}

type DefaultRouteActionCorsPolicyObservation struct {

	// In response to a preflight request, setting this to true indicates that the
	// actual request can include user credentials. This translates to the Access-
	// Control-Allow-Credentials header. Defaults to false.
	AllowCredentials *bool `json:"allowCredentials,omitempty" tf:"allow_credentials,omitempty"`

	// Specifies the content for the Access-Control-Allow-Headers header.
	AllowHeaders []*string `json:"allowHeaders,omitempty" tf:"allow_headers,omitempty"`

	// Specifies the content for the Access-Control-Allow-Methods header.
	AllowMethods []*string `json:"allowMethods,omitempty" tf:"allow_methods,omitempty"`

	// Specifies the regular expression patterns that match allowed origins. For
	// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
	// An origin is allowed if it matches either allow_origins or allow_origin_regex.
	AllowOriginRegexes []*string `json:"allowOriginRegexes,omitempty" tf:"allow_origin_regexes,omitempty"`

	// Specifies the list of origins that will be allowed to do CORS requests. An
	// origin is allowed if it matches either allow_origins or allow_origin_regex.
	AllowOrigins []*string `json:"allowOrigins,omitempty" tf:"allow_origins,omitempty"`

	// If true, specifies the CORS policy is disabled.
	Disabled *bool `json:"disabled,omitempty" tf:"disabled,omitempty"`

	// Specifies the content for the Access-Control-Expose-Headers header.
	ExposeHeaders []*string `json:"exposeHeaders,omitempty" tf:"expose_headers,omitempty"`

	// Specifies how long the results of a preflight request can be cached. This
	// translates to the content for the Access-Control-Max-Age header.
	MaxAge *float64 `json:"maxAge,omitempty" tf:"max_age,omitempty"`
}

type DefaultRouteActionCorsPolicyParameters struct {

	// In response to a preflight request, setting this to true indicates that the
	// actual request can include user credentials. This translates to the Access-
	// Control-Allow-Credentials header. Defaults to false.
	// +kubebuilder:validation:Optional
	AllowCredentials *bool `json:"allowCredentials,omitempty" tf:"allow_credentials,omitempty"`

	// Specifies the content for the Access-Control-Allow-Headers header.
	// +kubebuilder:validation:Optional
	AllowHeaders []*string `json:"allowHeaders,omitempty" tf:"allow_headers,omitempty"`

	// Specifies the content for the Access-Control-Allow-Methods header.
	// +kubebuilder:validation:Optional
	AllowMethods []*string `json:"allowMethods,omitempty" tf:"allow_methods,omitempty"`

	// Specifies the regular expression patterns that match allowed origins. For
	// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
	// An origin is allowed if it matches either allow_origins or allow_origin_regex.
	// +kubebuilder:validation:Optional
	AllowOriginRegexes []*string `json:"allowOriginRegexes,omitempty" tf:"allow_origin_regexes,omitempty"`

	// Specifies the list of origins that will be allowed to do CORS requests. An
	// origin is allowed if it matches either allow_origins or allow_origin_regex.
	// +kubebuilder:validation:Optional
	AllowOrigins []*string `json:"allowOrigins,omitempty" tf:"allow_origins,omitempty"`

	// If true, specifies the CORS policy is disabled.
	// +kubebuilder:validation:Optional
	Disabled *bool `json:"disabled,omitempty" tf:"disabled,omitempty"`

	// Specifies the content for the Access-Control-Expose-Headers header.
	// +kubebuilder:validation:Optional
	ExposeHeaders []*string `json:"exposeHeaders,omitempty" tf:"expose_headers,omitempty"`

	// Specifies how long the results of a preflight request can be cached. This
	// translates to the content for the Access-Control-Max-Age header.
	// +kubebuilder:validation:Optional
	MaxAge *float64 `json:"maxAge,omitempty" tf:"max_age,omitempty"`
}

type DefaultRouteActionFaultInjectionPolicyAbortInitParameters struct {

	// The HTTP status code used to abort the request. The value must be between 200
	// and 599 inclusive.
	HTTPStatus *float64 `json:"httpStatus,omitempty" tf:"http_status,omitempty"`

	// The percentage of traffic (connections/operations/requests) on which delay will
	// be introduced as part of fault injection. The value must be between 0.0 and
	// 100.0 inclusive.
	Percentage *float64 `json:"percentage,omitempty" tf:"percentage,omitempty"`
}

type DefaultRouteActionFaultInjectionPolicyAbortObservation struct {

	// The HTTP status code used to abort the request. The value must be between 200
	// and 599 inclusive.
	HTTPStatus *float64 `json:"httpStatus,omitempty" tf:"http_status,omitempty"`

	// The percentage of traffic (connections/operations/requests) on which delay will
	// be introduced as part of fault injection. The value must be between 0.0 and
	// 100.0 inclusive.
	Percentage *float64 `json:"percentage,omitempty" tf:"percentage,omitempty"`
}

type DefaultRouteActionFaultInjectionPolicyAbortParameters struct {

	// The HTTP status code used to abort the request. The value must be between 200
	// and 599 inclusive.
	// +kubebuilder:validation:Optional
	HTTPStatus *float64 `json:"httpStatus,omitempty" tf:"http_status,omitempty"`

	// The percentage of traffic (connections/operations/requests) on which delay will
	// be introduced as part of fault injection. The value must be between 0.0 and
	// 100.0 inclusive.
	// +kubebuilder:validation:Optional
	Percentage *float64 `json:"percentage,omitempty" tf:"percentage,omitempty"`
}

type DefaultRouteActionFaultInjectionPolicyDelayFixedDelayInitParameters struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type DefaultRouteActionFaultInjectionPolicyDelayFixedDelayObservation struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type DefaultRouteActionFaultInjectionPolicyDelayFixedDelayParameters struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	// +kubebuilder:validation:Optional
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	// +kubebuilder:validation:Optional
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type DefaultRouteActionFaultInjectionPolicyDelayInitParameters struct {

	// Specifies the value of the fixed delay interval.
	// Structure is documented below.
	FixedDelay []DefaultRouteActionFaultInjectionPolicyDelayFixedDelayInitParameters `json:"fixedDelay,omitempty" tf:"fixed_delay,omitempty"`

	// The percentage of traffic (connections/operations/requests) on which delay will
	// be introduced as part of fault injection. The value must be between 0.0 and
	// 100.0 inclusive.
	Percentage *float64 `json:"percentage,omitempty" tf:"percentage,omitempty"`
}

type DefaultRouteActionFaultInjectionPolicyDelayObservation struct {

	// Specifies the value of the fixed delay interval.
	// Structure is documented below.
	FixedDelay []DefaultRouteActionFaultInjectionPolicyDelayFixedDelayObservation `json:"fixedDelay,omitempty" tf:"fixed_delay,omitempty"`

	// The percentage of traffic (connections/operations/requests) on which delay will
	// be introduced as part of fault injection. The value must be between 0.0 and
	// 100.0 inclusive.
	Percentage *float64 `json:"percentage,omitempty" tf:"percentage,omitempty"`
}

type DefaultRouteActionFaultInjectionPolicyDelayParameters struct {

	// Specifies the value of the fixed delay interval.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	FixedDelay []DefaultRouteActionFaultInjectionPolicyDelayFixedDelayParameters `json:"fixedDelay,omitempty" tf:"fixed_delay,omitempty"`

	// The percentage of traffic (connections/operations/requests) on which delay will
	// be introduced as part of fault injection. The value must be between 0.0 and
	// 100.0 inclusive.
	// +kubebuilder:validation:Optional
	Percentage *float64 `json:"percentage,omitempty" tf:"percentage,omitempty"`
}

type DefaultRouteActionFaultInjectionPolicyInitParameters struct {

	// The specification for how client requests are aborted as part of fault
	// injection.
	// Structure is documented below.
	Abort []DefaultRouteActionFaultInjectionPolicyAbortInitParameters `json:"abort,omitempty" tf:"abort,omitempty"`

	// The specification for how client requests are delayed as part of fault
	// injection, before being sent to a backend service.
	// Structure is documented below.
	Delay []DefaultRouteActionFaultInjectionPolicyDelayInitParameters `json:"delay,omitempty" tf:"delay,omitempty"`
}

type DefaultRouteActionFaultInjectionPolicyObservation struct {

	// The specification for how client requests are aborted as part of fault
	// injection.
	// Structure is documented below.
	Abort []DefaultRouteActionFaultInjectionPolicyAbortObservation `json:"abort,omitempty" tf:"abort,omitempty"`

	// The specification for how client requests are delayed as part of fault
	// injection, before being sent to a backend service.
	// Structure is documented below.
	Delay []DefaultRouteActionFaultInjectionPolicyDelayObservation `json:"delay,omitempty" tf:"delay,omitempty"`
}

type DefaultRouteActionFaultInjectionPolicyParameters struct {

	// The specification for how client requests are aborted as part of fault
	// injection.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Abort []DefaultRouteActionFaultInjectionPolicyAbortParameters `json:"abort,omitempty" tf:"abort,omitempty"`

	// The specification for how client requests are delayed as part of fault
	// injection, before being sent to a backend service.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Delay []DefaultRouteActionFaultInjectionPolicyDelayParameters `json:"delay,omitempty" tf:"delay,omitempty"`
}

type DefaultRouteActionRequestMirrorPolicyInitParameters struct {

	// The default BackendService resource. Before
	// forwarding the request to backendService, the loadbalancer applies any relevant
	// headerActions specified as part of this backendServiceWeight.
	BackendService *string `json:"backendService,omitempty" tf:"backend_service,omitempty"`
}

type DefaultRouteActionRequestMirrorPolicyObservation struct {

	// The default BackendService resource. Before
	// forwarding the request to backendService, the loadbalancer applies any relevant
	// headerActions specified as part of this backendServiceWeight.
	BackendService *string `json:"backendService,omitempty" tf:"backend_service,omitempty"`
}

type DefaultRouteActionRequestMirrorPolicyParameters struct {

	// The default BackendService resource. Before
	// forwarding the request to backendService, the loadbalancer applies any relevant
	// headerActions specified as part of this backendServiceWeight.
	// +kubebuilder:validation:Optional
	BackendService *string `json:"backendService" tf:"backend_service,omitempty"`
}

type DefaultRouteActionRetryPolicyInitParameters struct {

	// Specifies the allowed number retries. This number must be > 0.
	NumRetries *float64 `json:"numRetries,omitempty" tf:"num_retries,omitempty"`

	// Specifies a non-zero timeout per retry attempt.
	// Structure is documented below.
	PerTryTimeout []DefaultRouteActionRetryPolicyPerTryTimeoutInitParameters `json:"perTryTimeout,omitempty" tf:"per_try_timeout,omitempty"`

	// Specifies one or more conditions when this retry rule applies. Valid values are:
	RetryConditions []*string `json:"retryConditions,omitempty" tf:"retry_conditions,omitempty"`
}

type DefaultRouteActionRetryPolicyObservation struct {

	// Specifies the allowed number retries. This number must be > 0.
	NumRetries *float64 `json:"numRetries,omitempty" tf:"num_retries,omitempty"`

	// Specifies a non-zero timeout per retry attempt.
	// Structure is documented below.
	PerTryTimeout []DefaultRouteActionRetryPolicyPerTryTimeoutObservation `json:"perTryTimeout,omitempty" tf:"per_try_timeout,omitempty"`

	// Specifies one or more conditions when this retry rule applies. Valid values are:
	RetryConditions []*string `json:"retryConditions,omitempty" tf:"retry_conditions,omitempty"`
}

type DefaultRouteActionRetryPolicyParameters struct {

	// Specifies the allowed number retries. This number must be > 0.
	// +kubebuilder:validation:Optional
	NumRetries *float64 `json:"numRetries,omitempty" tf:"num_retries,omitempty"`

	// Specifies a non-zero timeout per retry attempt.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	PerTryTimeout []DefaultRouteActionRetryPolicyPerTryTimeoutParameters `json:"perTryTimeout,omitempty" tf:"per_try_timeout,omitempty"`

	// Specifies one or more conditions when this retry rule applies. Valid values are:
	// +kubebuilder:validation:Optional
	RetryConditions []*string `json:"retryConditions,omitempty" tf:"retry_conditions,omitempty"`
}

type DefaultRouteActionRetryPolicyPerTryTimeoutInitParameters struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type DefaultRouteActionRetryPolicyPerTryTimeoutObservation struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type DefaultRouteActionRetryPolicyPerTryTimeoutParameters struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	// +kubebuilder:validation:Optional
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	// +kubebuilder:validation:Optional
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type DefaultRouteActionTimeoutInitParameters struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type DefaultRouteActionTimeoutObservation struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type DefaultRouteActionTimeoutParameters struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	// +kubebuilder:validation:Optional
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	// +kubebuilder:validation:Optional
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type DefaultRouteActionURLRewriteInitParameters struct {

	// Prior to forwarding the request to the selected service, the request's host
	// header is replaced with contents of hostRewrite. The value must be between 1 and
	// 255 characters.
	HostRewrite *string `json:"hostRewrite,omitempty" tf:"host_rewrite,omitempty"`

	// Prior to forwarding the request to the selected backend service, the matching
	// portion of the request's path is replaced by pathPrefixRewrite. The value must
	// be between 1 and 1024 characters.
	PathPrefixRewrite *string `json:"pathPrefixRewrite,omitempty" tf:"path_prefix_rewrite,omitempty"`
}

type DefaultRouteActionURLRewriteObservation struct {

	// Prior to forwarding the request to the selected service, the request's host
	// header is replaced with contents of hostRewrite. The value must be between 1 and
	// 255 characters.
	HostRewrite *string `json:"hostRewrite,omitempty" tf:"host_rewrite,omitempty"`

	// Prior to forwarding the request to the selected backend service, the matching
	// portion of the request's path is replaced by pathPrefixRewrite. The value must
	// be between 1 and 1024 characters.
	PathPrefixRewrite *string `json:"pathPrefixRewrite,omitempty" tf:"path_prefix_rewrite,omitempty"`
}

type DefaultRouteActionURLRewriteParameters struct {

	// Prior to forwarding the request to the selected service, the request's host
	// header is replaced with contents of hostRewrite. The value must be between 1 and
	// 255 characters.
	// +kubebuilder:validation:Optional
	HostRewrite *string `json:"hostRewrite,omitempty" tf:"host_rewrite,omitempty"`

	// Prior to forwarding the request to the selected backend service, the matching
	// portion of the request's path is replaced by pathPrefixRewrite. The value must
	// be between 1 and 1024 characters.
	// +kubebuilder:validation:Optional
	PathPrefixRewrite *string `json:"pathPrefixRewrite,omitempty" tf:"path_prefix_rewrite,omitempty"`
}

type DefaultRouteActionWeightedBackendServicesHeaderActionInitParameters struct {

	// Headers to add to a matching request prior to forwarding the request to the
	// backendService.
	// Structure is documented below.
	RequestHeadersToAdd []DefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddInitParameters `json:"requestHeadersToAdd,omitempty" tf:"request_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the request
	// prior to forwarding the request to the backendService.
	RequestHeadersToRemove []*string `json:"requestHeadersToRemove,omitempty" tf:"request_headers_to_remove,omitempty"`

	// Headers to add the response prior to sending the response back to the client.
	// Structure is documented below.
	ResponseHeadersToAdd []DefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddInitParameters `json:"responseHeadersToAdd,omitempty" tf:"response_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the response
	// prior to sending the response back to the client.
	ResponseHeadersToRemove []*string `json:"responseHeadersToRemove,omitempty" tf:"response_headers_to_remove,omitempty"`
}

type DefaultRouteActionWeightedBackendServicesHeaderActionObservation struct {

	// Headers to add to a matching request prior to forwarding the request to the
	// backendService.
	// Structure is documented below.
	RequestHeadersToAdd []DefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddObservation `json:"requestHeadersToAdd,omitempty" tf:"request_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the request
	// prior to forwarding the request to the backendService.
	RequestHeadersToRemove []*string `json:"requestHeadersToRemove,omitempty" tf:"request_headers_to_remove,omitempty"`

	// Headers to add the response prior to sending the response back to the client.
	// Structure is documented below.
	ResponseHeadersToAdd []DefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddObservation `json:"responseHeadersToAdd,omitempty" tf:"response_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the response
	// prior to sending the response back to the client.
	ResponseHeadersToRemove []*string `json:"responseHeadersToRemove,omitempty" tf:"response_headers_to_remove,omitempty"`
}

type DefaultRouteActionWeightedBackendServicesHeaderActionParameters struct {

	// Headers to add to a matching request prior to forwarding the request to the
	// backendService.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	RequestHeadersToAdd []DefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddParameters `json:"requestHeadersToAdd,omitempty" tf:"request_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the request
	// prior to forwarding the request to the backendService.
	// +kubebuilder:validation:Optional
	RequestHeadersToRemove []*string `json:"requestHeadersToRemove,omitempty" tf:"request_headers_to_remove,omitempty"`

	// Headers to add the response prior to sending the response back to the client.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	ResponseHeadersToAdd []DefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddParameters `json:"responseHeadersToAdd,omitempty" tf:"response_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the response
	// prior to sending the response back to the client.
	// +kubebuilder:validation:Optional
	ResponseHeadersToRemove []*string `json:"responseHeadersToRemove,omitempty" tf:"response_headers_to_remove,omitempty"`
}

type DefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddInitParameters struct {

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type DefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddObservation struct {

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type DefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddParameters struct {

	// The name of the header.
	// +kubebuilder:validation:Optional
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	// +kubebuilder:validation:Optional
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	// +kubebuilder:validation:Optional
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type DefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddInitParameters struct {

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type DefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddObservation struct {

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type DefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddParameters struct {

	// The name of the header.
	// +kubebuilder:validation:Optional
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	// +kubebuilder:validation:Optional
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	// +kubebuilder:validation:Optional
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type DefaultRouteActionWeightedBackendServicesInitParameters struct {

	// The default BackendService resource. Before
	// forwarding the request to backendService, the loadbalancer applies any relevant
	// headerActions specified as part of this backendServiceWeight.
	BackendService *string `json:"backendService,omitempty" tf:"backend_service,omitempty"`

	// Specifies changes to request and response headers that need to take effect for
	// the selected backendService. headerAction specified here take effect before
	// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
	// Structure is documented below.
	HeaderAction []DefaultRouteActionWeightedBackendServicesHeaderActionInitParameters `json:"headerAction,omitempty" tf:"header_action,omitempty"`

	// Specifies the fraction of traffic sent to backendService, computed as weight /
	// (sum of all weightedBackendService weights in routeAction) . The selection of a
	// backend service is determined only for new traffic. Once a user's request has
	// been directed to a backendService, subsequent requests will be sent to the same
	// backendService as determined by the BackendService's session affinity policy.
	// The value must be between 0 and 1000
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type DefaultRouteActionWeightedBackendServicesObservation struct {

	// The default BackendService resource. Before
	// forwarding the request to backendService, the loadbalancer applies any relevant
	// headerActions specified as part of this backendServiceWeight.
	BackendService *string `json:"backendService,omitempty" tf:"backend_service,omitempty"`

	// Specifies changes to request and response headers that need to take effect for
	// the selected backendService. headerAction specified here take effect before
	// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
	// Structure is documented below.
	HeaderAction []DefaultRouteActionWeightedBackendServicesHeaderActionObservation `json:"headerAction,omitempty" tf:"header_action,omitempty"`

	// Specifies the fraction of traffic sent to backendService, computed as weight /
	// (sum of all weightedBackendService weights in routeAction) . The selection of a
	// backend service is determined only for new traffic. Once a user's request has
	// been directed to a backendService, subsequent requests will be sent to the same
	// backendService as determined by the BackendService's session affinity policy.
	// The value must be between 0 and 1000
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type DefaultRouteActionWeightedBackendServicesParameters struct {

	// The default BackendService resource. Before
	// forwarding the request to backendService, the loadbalancer applies any relevant
	// headerActions specified as part of this backendServiceWeight.
	// +kubebuilder:validation:Optional
	BackendService *string `json:"backendService,omitempty" tf:"backend_service,omitempty"`

	// Specifies changes to request and response headers that need to take effect for
	// the selected backendService. headerAction specified here take effect before
	// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	HeaderAction []DefaultRouteActionWeightedBackendServicesHeaderActionParameters `json:"headerAction,omitempty" tf:"header_action,omitempty"`

	// Specifies the fraction of traffic sent to backendService, computed as weight /
	// (sum of all weightedBackendService weights in routeAction) . The selection of a
	// backend service is determined only for new traffic. Once a user's request has
	// been directed to a backendService, subsequent requests will be sent to the same
	// backendService as determined by the BackendService's session affinity policy.
	// The value must be between 0 and 1000
	// +kubebuilder:validation:Optional
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type HeaderMatchesRangeMatchInitParameters struct {

	// The end of the range (exclusive).
	RangeEnd *float64 `json:"rangeEnd,omitempty" tf:"range_end,omitempty"`

	// The start of the range (inclusive).
	RangeStart *float64 `json:"rangeStart,omitempty" tf:"range_start,omitempty"`
}

type HeaderMatchesRangeMatchObservation struct {

	// The end of the range (exclusive).
	RangeEnd *float64 `json:"rangeEnd,omitempty" tf:"range_end,omitempty"`

	// The start of the range (inclusive).
	RangeStart *float64 `json:"rangeStart,omitempty" tf:"range_start,omitempty"`
}

type HeaderMatchesRangeMatchParameters struct {

	// The end of the range (exclusive).
	// +kubebuilder:validation:Optional
	RangeEnd *float64 `json:"rangeEnd" tf:"range_end,omitempty"`

	// The start of the range (inclusive).
	// +kubebuilder:validation:Optional
	RangeStart *float64 `json:"rangeStart" tf:"range_start,omitempty"`
}

type MatchRulesHeaderMatchesInitParameters struct {

	// The queryParameterMatch matches if the value of the parameter exactly matches
	// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
	// must be set.
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// If set to false, the headerMatch is considered a match if the match criteria
	// above are met. If set to true, the headerMatch is considered a match if the
	// match criteria above are NOT met. Defaults to false.
	InvertMatch *bool `json:"invertMatch,omitempty" tf:"invert_match,omitempty"`

	// For satisfying the matchRule condition, the request's path must begin with the
	// specified prefixMatch. prefixMatch must begin with a /. The value must be
	// between 1 and 1024 characters. Only one of prefixMatch, fullPathMatch or
	// regexMatch must be specified.
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// Specifies that the queryParameterMatch matches if the request contains the query
	// parameter, irrespective of whether the parameter has a value or not. Only one of
	// presentMatch, exactMatch and regexMatch must be set.
	PresentMatch *bool `json:"presentMatch,omitempty" tf:"present_match,omitempty"`

	// The header value must be an integer and its value must be in the range specified
	// in rangeMatch. If the header does not contain an integer, number or is empty,
	// the match fails. For example for a range [-5, 0]   - -3 will match.  - 0 will
	// not match.  - 0.25 will not match.  - -3someString will not match.   Only one of
	// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
	// must be set.
	// Structure is documented below.
	RangeMatch []HeaderMatchesRangeMatchInitParameters `json:"rangeMatch,omitempty" tf:"range_match,omitempty"`

	// The queryParameterMatch matches if the value of the parameter matches the
	// regular expression specified by regexMatch. For the regular expression grammar,
	// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
	// exactMatch and regexMatch must be set.
	RegexMatch *string `json:"regexMatch,omitempty" tf:"regex_match,omitempty"`

	// The value of the header must end with the contents of suffixMatch. Only one of
	// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
	// must be set.
	SuffixMatch *string `json:"suffixMatch,omitempty" tf:"suffix_match,omitempty"`
}

type MatchRulesHeaderMatchesObservation struct {

	// The queryParameterMatch matches if the value of the parameter exactly matches
	// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
	// must be set.
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// If set to false, the headerMatch is considered a match if the match criteria
	// above are met. If set to true, the headerMatch is considered a match if the
	// match criteria above are NOT met. Defaults to false.
	InvertMatch *bool `json:"invertMatch,omitempty" tf:"invert_match,omitempty"`

	// For satisfying the matchRule condition, the request's path must begin with the
	// specified prefixMatch. prefixMatch must begin with a /. The value must be
	// between 1 and 1024 characters. Only one of prefixMatch, fullPathMatch or
	// regexMatch must be specified.
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// Specifies that the queryParameterMatch matches if the request contains the query
	// parameter, irrespective of whether the parameter has a value or not. Only one of
	// presentMatch, exactMatch and regexMatch must be set.
	PresentMatch *bool `json:"presentMatch,omitempty" tf:"present_match,omitempty"`

	// The header value must be an integer and its value must be in the range specified
	// in rangeMatch. If the header does not contain an integer, number or is empty,
	// the match fails. For example for a range [-5, 0]   - -3 will match.  - 0 will
	// not match.  - 0.25 will not match.  - -3someString will not match.   Only one of
	// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
	// must be set.
	// Structure is documented below.
	RangeMatch []HeaderMatchesRangeMatchObservation `json:"rangeMatch,omitempty" tf:"range_match,omitempty"`

	// The queryParameterMatch matches if the value of the parameter matches the
	// regular expression specified by regexMatch. For the regular expression grammar,
	// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
	// exactMatch and regexMatch must be set.
	RegexMatch *string `json:"regexMatch,omitempty" tf:"regex_match,omitempty"`

	// The value of the header must end with the contents of suffixMatch. Only one of
	// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
	// must be set.
	SuffixMatch *string `json:"suffixMatch,omitempty" tf:"suffix_match,omitempty"`
}

type MatchRulesHeaderMatchesParameters struct {

	// The queryParameterMatch matches if the value of the parameter exactly matches
	// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
	// must be set.
	// +kubebuilder:validation:Optional
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// The name of the header.
	// +kubebuilder:validation:Optional
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`

	// If set to false, the headerMatch is considered a match if the match criteria
	// above are met. If set to true, the headerMatch is considered a match if the
	// match criteria above are NOT met. Defaults to false.
	// +kubebuilder:validation:Optional
	InvertMatch *bool `json:"invertMatch,omitempty" tf:"invert_match,omitempty"`

	// For satisfying the matchRule condition, the request's path must begin with the
	// specified prefixMatch. prefixMatch must begin with a /. The value must be
	// between 1 and 1024 characters. Only one of prefixMatch, fullPathMatch or
	// regexMatch must be specified.
	// +kubebuilder:validation:Optional
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// Specifies that the queryParameterMatch matches if the request contains the query
	// parameter, irrespective of whether the parameter has a value or not. Only one of
	// presentMatch, exactMatch and regexMatch must be set.
	// +kubebuilder:validation:Optional
	PresentMatch *bool `json:"presentMatch,omitempty" tf:"present_match,omitempty"`

	// The header value must be an integer and its value must be in the range specified
	// in rangeMatch. If the header does not contain an integer, number or is empty,
	// the match fails. For example for a range [-5, 0]   - -3 will match.  - 0 will
	// not match.  - 0.25 will not match.  - -3someString will not match.   Only one of
	// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
	// must be set.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	RangeMatch []HeaderMatchesRangeMatchParameters `json:"rangeMatch,omitempty" tf:"range_match,omitempty"`

	// The queryParameterMatch matches if the value of the parameter matches the
	// regular expression specified by regexMatch. For the regular expression grammar,
	// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
	// exactMatch and regexMatch must be set.
	// +kubebuilder:validation:Optional
	RegexMatch *string `json:"regexMatch,omitempty" tf:"regex_match,omitempty"`

	// The value of the header must end with the contents of suffixMatch. Only one of
	// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
	// must be set.
	// +kubebuilder:validation:Optional
	SuffixMatch *string `json:"suffixMatch,omitempty" tf:"suffix_match,omitempty"`
}

type MatchRulesMetadataFiltersFilterLabelsInitParameters struct {

	// The name of the query parameter to match. The query parameter must exist in the
	// request, in the absence of which the request match fails.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The value of the label must match the specified value. value can have a maximum
	// length of 1024 characters.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type MatchRulesMetadataFiltersFilterLabelsObservation struct {

	// The name of the query parameter to match. The query parameter must exist in the
	// request, in the absence of which the request match fails.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The value of the label must match the specified value. value can have a maximum
	// length of 1024 characters.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type MatchRulesMetadataFiltersFilterLabelsParameters struct {

	// The name of the query parameter to match. The query parameter must exist in the
	// request, in the absence of which the request match fails.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// The value of the label must match the specified value. value can have a maximum
	// length of 1024 characters.
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type MatchRulesQueryParameterMatchesInitParameters struct {

	// The queryParameterMatch matches if the value of the parameter exactly matches
	// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
	// must be set.
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// The name of the query parameter to match. The query parameter must exist in the
	// request, in the absence of which the request match fails.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Specifies that the queryParameterMatch matches if the request contains the query
	// parameter, irrespective of whether the parameter has a value or not. Only one of
	// presentMatch, exactMatch and regexMatch must be set.
	PresentMatch *bool `json:"presentMatch,omitempty" tf:"present_match,omitempty"`

	// The queryParameterMatch matches if the value of the parameter matches the
	// regular expression specified by regexMatch. For the regular expression grammar,
	// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
	// exactMatch and regexMatch must be set.
	RegexMatch *string `json:"regexMatch,omitempty" tf:"regex_match,omitempty"`
}

type MatchRulesQueryParameterMatchesObservation struct {

	// The queryParameterMatch matches if the value of the parameter exactly matches
	// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
	// must be set.
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// The name of the query parameter to match. The query parameter must exist in the
	// request, in the absence of which the request match fails.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Specifies that the queryParameterMatch matches if the request contains the query
	// parameter, irrespective of whether the parameter has a value or not. Only one of
	// presentMatch, exactMatch and regexMatch must be set.
	PresentMatch *bool `json:"presentMatch,omitempty" tf:"present_match,omitempty"`

	// The queryParameterMatch matches if the value of the parameter matches the
	// regular expression specified by regexMatch. For the regular expression grammar,
	// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
	// exactMatch and regexMatch must be set.
	RegexMatch *string `json:"regexMatch,omitempty" tf:"regex_match,omitempty"`
}

type MatchRulesQueryParameterMatchesParameters struct {

	// The queryParameterMatch matches if the value of the parameter exactly matches
	// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
	// must be set.
	// +kubebuilder:validation:Optional
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// The name of the query parameter to match. The query parameter must exist in the
	// request, in the absence of which the request match fails.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// Specifies that the queryParameterMatch matches if the request contains the query
	// parameter, irrespective of whether the parameter has a value or not. Only one of
	// presentMatch, exactMatch and regexMatch must be set.
	// +kubebuilder:validation:Optional
	PresentMatch *bool `json:"presentMatch,omitempty" tf:"present_match,omitempty"`

	// The queryParameterMatch matches if the value of the parameter matches the
	// regular expression specified by regexMatch. For the regular expression grammar,
	// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
	// exactMatch and regexMatch must be set.
	// +kubebuilder:validation:Optional
	RegexMatch *string `json:"regexMatch,omitempty" tf:"regex_match,omitempty"`
}

type PathMatcherDefaultRouteActionCorsPolicyInitParameters struct {

	// In response to a preflight request, setting this to true indicates that the
	// actual request can include user credentials. This translates to the Access-
	// Control-Allow-Credentials header. Defaults to false.
	AllowCredentials *bool `json:"allowCredentials,omitempty" tf:"allow_credentials,omitempty"`

	// Specifies the content for the Access-Control-Allow-Headers header.
	AllowHeaders []*string `json:"allowHeaders,omitempty" tf:"allow_headers,omitempty"`

	// Specifies the content for the Access-Control-Allow-Methods header.
	AllowMethods []*string `json:"allowMethods,omitempty" tf:"allow_methods,omitempty"`

	// Specifies the regular expression patterns that match allowed origins. For
	// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
	// An origin is allowed if it matches either allow_origins or allow_origin_regex.
	AllowOriginRegexes []*string `json:"allowOriginRegexes,omitempty" tf:"allow_origin_regexes,omitempty"`

	// Specifies the list of origins that will be allowed to do CORS requests. An
	// origin is allowed if it matches either allow_origins or allow_origin_regex.
	AllowOrigins []*string `json:"allowOrigins,omitempty" tf:"allow_origins,omitempty"`

	// If true, specifies the CORS policy is disabled.
	Disabled *bool `json:"disabled,omitempty" tf:"disabled,omitempty"`

	// Specifies the content for the Access-Control-Expose-Headers header.
	ExposeHeaders []*string `json:"exposeHeaders,omitempty" tf:"expose_headers,omitempty"`

	// Specifies how long the results of a preflight request can be cached. This
	// translates to the content for the Access-Control-Max-Age header.
	MaxAge *float64 `json:"maxAge,omitempty" tf:"max_age,omitempty"`
}

type PathMatcherDefaultRouteActionCorsPolicyObservation struct {

	// In response to a preflight request, setting this to true indicates that the
	// actual request can include user credentials. This translates to the Access-
	// Control-Allow-Credentials header. Defaults to false.
	AllowCredentials *bool `json:"allowCredentials,omitempty" tf:"allow_credentials,omitempty"`

	// Specifies the content for the Access-Control-Allow-Headers header.
	AllowHeaders []*string `json:"allowHeaders,omitempty" tf:"allow_headers,omitempty"`

	// Specifies the content for the Access-Control-Allow-Methods header.
	AllowMethods []*string `json:"allowMethods,omitempty" tf:"allow_methods,omitempty"`

	// Specifies the regular expression patterns that match allowed origins. For
	// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
	// An origin is allowed if it matches either allow_origins or allow_origin_regex.
	AllowOriginRegexes []*string `json:"allowOriginRegexes,omitempty" tf:"allow_origin_regexes,omitempty"`

	// Specifies the list of origins that will be allowed to do CORS requests. An
	// origin is allowed if it matches either allow_origins or allow_origin_regex.
	AllowOrigins []*string `json:"allowOrigins,omitempty" tf:"allow_origins,omitempty"`

	// If true, specifies the CORS policy is disabled.
	Disabled *bool `json:"disabled,omitempty" tf:"disabled,omitempty"`

	// Specifies the content for the Access-Control-Expose-Headers header.
	ExposeHeaders []*string `json:"exposeHeaders,omitempty" tf:"expose_headers,omitempty"`

	// Specifies how long the results of a preflight request can be cached. This
	// translates to the content for the Access-Control-Max-Age header.
	MaxAge *float64 `json:"maxAge,omitempty" tf:"max_age,omitempty"`
}

type PathMatcherDefaultRouteActionCorsPolicyParameters struct {

	// In response to a preflight request, setting this to true indicates that the
	// actual request can include user credentials. This translates to the Access-
	// Control-Allow-Credentials header. Defaults to false.
	// +kubebuilder:validation:Optional
	AllowCredentials *bool `json:"allowCredentials,omitempty" tf:"allow_credentials,omitempty"`

	// Specifies the content for the Access-Control-Allow-Headers header.
	// +kubebuilder:validation:Optional
	AllowHeaders []*string `json:"allowHeaders,omitempty" tf:"allow_headers,omitempty"`

	// Specifies the content for the Access-Control-Allow-Methods header.
	// +kubebuilder:validation:Optional
	AllowMethods []*string `json:"allowMethods,omitempty" tf:"allow_methods,omitempty"`

	// Specifies the regular expression patterns that match allowed origins. For
	// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
	// An origin is allowed if it matches either allow_origins or allow_origin_regex.
	// +kubebuilder:validation:Optional
	AllowOriginRegexes []*string `json:"allowOriginRegexes,omitempty" tf:"allow_origin_regexes,omitempty"`

	// Specifies the list of origins that will be allowed to do CORS requests. An
	// origin is allowed if it matches either allow_origins or allow_origin_regex.
	// +kubebuilder:validation:Optional
	AllowOrigins []*string `json:"allowOrigins,omitempty" tf:"allow_origins,omitempty"`

	// If true, specifies the CORS policy is disabled.
	// +kubebuilder:validation:Optional
	Disabled *bool `json:"disabled,omitempty" tf:"disabled,omitempty"`

	// Specifies the content for the Access-Control-Expose-Headers header.
	// +kubebuilder:validation:Optional
	ExposeHeaders []*string `json:"exposeHeaders,omitempty" tf:"expose_headers,omitempty"`

	// Specifies how long the results of a preflight request can be cached. This
	// translates to the content for the Access-Control-Max-Age header.
	// +kubebuilder:validation:Optional
	MaxAge *float64 `json:"maxAge,omitempty" tf:"max_age,omitempty"`
}

type PathMatcherDefaultRouteActionFaultInjectionPolicyAbortInitParameters struct {

	// The HTTP status code used to abort the request. The value must be between 200
	// and 599 inclusive.
	HTTPStatus *float64 `json:"httpStatus,omitempty" tf:"http_status,omitempty"`

	// The percentage of traffic (connections/operations/requests) on which delay will
	// be introduced as part of fault injection. The value must be between 0.0 and
	// 100.0 inclusive.
	Percentage *float64 `json:"percentage,omitempty" tf:"percentage,omitempty"`
}

type PathMatcherDefaultRouteActionFaultInjectionPolicyAbortObservation struct {

	// The HTTP status code used to abort the request. The value must be between 200
	// and 599 inclusive.
	HTTPStatus *float64 `json:"httpStatus,omitempty" tf:"http_status,omitempty"`

	// The percentage of traffic (connections/operations/requests) on which delay will
	// be introduced as part of fault injection. The value must be between 0.0 and
	// 100.0 inclusive.
	Percentage *float64 `json:"percentage,omitempty" tf:"percentage,omitempty"`
}

type PathMatcherDefaultRouteActionFaultInjectionPolicyAbortParameters struct {

	// The HTTP status code used to abort the request. The value must be between 200
	// and 599 inclusive.
	// +kubebuilder:validation:Optional
	HTTPStatus *float64 `json:"httpStatus,omitempty" tf:"http_status,omitempty"`

	// The percentage of traffic (connections/operations/requests) on which delay will
	// be introduced as part of fault injection. The value must be between 0.0 and
	// 100.0 inclusive.
	// +kubebuilder:validation:Optional
	Percentage *float64 `json:"percentage,omitempty" tf:"percentage,omitempty"`
}

type PathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelayInitParameters struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type PathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelayObservation struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type PathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelayParameters struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	// +kubebuilder:validation:Optional
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	// +kubebuilder:validation:Optional
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type PathMatcherDefaultRouteActionFaultInjectionPolicyDelayInitParameters struct {

	// Specifies the value of the fixed delay interval.
	// Structure is documented below.
	FixedDelay []PathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelayInitParameters `json:"fixedDelay,omitempty" tf:"fixed_delay,omitempty"`

	// The percentage of traffic (connections/operations/requests) on which delay will
	// be introduced as part of fault injection. The value must be between 0.0 and
	// 100.0 inclusive.
	Percentage *float64 `json:"percentage,omitempty" tf:"percentage,omitempty"`
}

type PathMatcherDefaultRouteActionFaultInjectionPolicyDelayObservation struct {

	// Specifies the value of the fixed delay interval.
	// Structure is documented below.
	FixedDelay []PathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelayObservation `json:"fixedDelay,omitempty" tf:"fixed_delay,omitempty"`

	// The percentage of traffic (connections/operations/requests) on which delay will
	// be introduced as part of fault injection. The value must be between 0.0 and
	// 100.0 inclusive.
	Percentage *float64 `json:"percentage,omitempty" tf:"percentage,omitempty"`
}

type PathMatcherDefaultRouteActionFaultInjectionPolicyDelayParameters struct {

	// Specifies the value of the fixed delay interval.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	FixedDelay []PathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelayParameters `json:"fixedDelay,omitempty" tf:"fixed_delay,omitempty"`

	// The percentage of traffic (connections/operations/requests) on which delay will
	// be introduced as part of fault injection. The value must be between 0.0 and
	// 100.0 inclusive.
	// +kubebuilder:validation:Optional
	Percentage *float64 `json:"percentage,omitempty" tf:"percentage,omitempty"`
}

type PathMatcherDefaultRouteActionFaultInjectionPolicyInitParameters struct {

	// The specification for how client requests are aborted as part of fault
	// injection.
	// Structure is documented below.
	Abort []PathMatcherDefaultRouteActionFaultInjectionPolicyAbortInitParameters `json:"abort,omitempty" tf:"abort,omitempty"`

	// The specification for how client requests are delayed as part of fault
	// injection, before being sent to a backend service.
	// Structure is documented below.
	Delay []PathMatcherDefaultRouteActionFaultInjectionPolicyDelayInitParameters `json:"delay,omitempty" tf:"delay,omitempty"`
}

type PathMatcherDefaultRouteActionFaultInjectionPolicyObservation struct {

	// The specification for how client requests are aborted as part of fault
	// injection.
	// Structure is documented below.
	Abort []PathMatcherDefaultRouteActionFaultInjectionPolicyAbortObservation `json:"abort,omitempty" tf:"abort,omitempty"`

	// The specification for how client requests are delayed as part of fault
	// injection, before being sent to a backend service.
	// Structure is documented below.
	Delay []PathMatcherDefaultRouteActionFaultInjectionPolicyDelayObservation `json:"delay,omitempty" tf:"delay,omitempty"`
}

type PathMatcherDefaultRouteActionFaultInjectionPolicyParameters struct {

	// The specification for how client requests are aborted as part of fault
	// injection.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Abort []PathMatcherDefaultRouteActionFaultInjectionPolicyAbortParameters `json:"abort,omitempty" tf:"abort,omitempty"`

	// The specification for how client requests are delayed as part of fault
	// injection, before being sent to a backend service.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Delay []PathMatcherDefaultRouteActionFaultInjectionPolicyDelayParameters `json:"delay,omitempty" tf:"delay,omitempty"`
}

type PathMatcherDefaultRouteActionInitParameters struct {

	// The specification for allowing client side cross-origin requests. Please see W3C
	// Recommendation for Cross Origin Resource Sharing
	// Structure is documented below.
	CorsPolicy []PathMatcherDefaultRouteActionCorsPolicyInitParameters `json:"corsPolicy,omitempty" tf:"cors_policy,omitempty"`

	// The specification for fault injection introduced into traffic to test the
	// resiliency of clients to backend service failure. As part of fault injection,
	// when clients send requests to a backend service, delays can be introduced by
	// Loadbalancer on a percentage of requests before sending those request to the
	// backend service. Similarly requests from clients can be aborted by the
	// Loadbalancer for a percentage of requests. timeout and retry_policy will be
	// ignored by clients that are configured with a fault_injection_policy.
	// Structure is documented below.
	FaultInjectionPolicy []PathMatcherDefaultRouteActionFaultInjectionPolicyInitParameters `json:"faultInjectionPolicy,omitempty" tf:"fault_injection_policy,omitempty"`

	// Specifies the policy on how requests intended for the route's backends are
	// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
	// responses from the shadow service. Prior to sending traffic to the shadow
	// service, the host / authority header is suffixed with -shadow.
	// Structure is documented below.
	RequestMirrorPolicy []PathMatcherDefaultRouteActionRequestMirrorPolicyInitParameters `json:"requestMirrorPolicy,omitempty" tf:"request_mirror_policy,omitempty"`

	// Specifies the retry policy associated with this route.
	// Structure is documented below.
	RetryPolicy []PathMatcherDefaultRouteActionRetryPolicyInitParameters `json:"retryPolicy,omitempty" tf:"retry_policy,omitempty"`

	// Specifies the timeout for the selected route. Timeout is computed from the time
	// the request is has been fully processed (i.e. end-of-stream) up until the
	// response has been completely processed. Timeout includes all retries. If not
	// specified, the default value is 15 seconds.
	// Structure is documented below.
	Timeout []PathMatcherDefaultRouteActionTimeoutInitParameters `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// The spec to modify the URL of the request, prior to forwarding the request to
	// the matched service
	// Structure is documented below.
	URLRewrite []PathMatcherDefaultRouteActionURLRewriteInitParameters `json:"urlRewrite,omitempty" tf:"url_rewrite,omitempty"`

	// A list of weighted backend services to send traffic to when a route match
	// occurs. The weights determine the fraction of traffic that flows to their
	// corresponding backend service. If all traffic needs to go to a single backend
	// service, there must be one  weightedBackendService with weight set to a non 0
	// number. Once a backendService is identified and before forwarding the request to
	// the backend service, advanced routing actions like Url rewrites and header
	// transformations are applied depending on additional settings specified in this
	// HttpRouteAction.
	// Structure is documented below.
	WeightedBackendServices []PathMatcherDefaultRouteActionWeightedBackendServicesInitParameters `json:"weightedBackendServices,omitempty" tf:"weighted_backend_services,omitempty"`
}

type PathMatcherDefaultRouteActionObservation struct {

	// The specification for allowing client side cross-origin requests. Please see W3C
	// Recommendation for Cross Origin Resource Sharing
	// Structure is documented below.
	CorsPolicy []PathMatcherDefaultRouteActionCorsPolicyObservation `json:"corsPolicy,omitempty" tf:"cors_policy,omitempty"`

	// The specification for fault injection introduced into traffic to test the
	// resiliency of clients to backend service failure. As part of fault injection,
	// when clients send requests to a backend service, delays can be introduced by
	// Loadbalancer on a percentage of requests before sending those request to the
	// backend service. Similarly requests from clients can be aborted by the
	// Loadbalancer for a percentage of requests. timeout and retry_policy will be
	// ignored by clients that are configured with a fault_injection_policy.
	// Structure is documented below.
	FaultInjectionPolicy []PathMatcherDefaultRouteActionFaultInjectionPolicyObservation `json:"faultInjectionPolicy,omitempty" tf:"fault_injection_policy,omitempty"`

	// Specifies the policy on how requests intended for the route's backends are
	// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
	// responses from the shadow service. Prior to sending traffic to the shadow
	// service, the host / authority header is suffixed with -shadow.
	// Structure is documented below.
	RequestMirrorPolicy []PathMatcherDefaultRouteActionRequestMirrorPolicyObservation `json:"requestMirrorPolicy,omitempty" tf:"request_mirror_policy,omitempty"`

	// Specifies the retry policy associated with this route.
	// Structure is documented below.
	RetryPolicy []PathMatcherDefaultRouteActionRetryPolicyObservation `json:"retryPolicy,omitempty" tf:"retry_policy,omitempty"`

	// Specifies the timeout for the selected route. Timeout is computed from the time
	// the request is has been fully processed (i.e. end-of-stream) up until the
	// response has been completely processed. Timeout includes all retries. If not
	// specified, the default value is 15 seconds.
	// Structure is documented below.
	Timeout []PathMatcherDefaultRouteActionTimeoutObservation `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// The spec to modify the URL of the request, prior to forwarding the request to
	// the matched service
	// Structure is documented below.
	URLRewrite []PathMatcherDefaultRouteActionURLRewriteObservation `json:"urlRewrite,omitempty" tf:"url_rewrite,omitempty"`

	// A list of weighted backend services to send traffic to when a route match
	// occurs. The weights determine the fraction of traffic that flows to their
	// corresponding backend service. If all traffic needs to go to a single backend
	// service, there must be one  weightedBackendService with weight set to a non 0
	// number. Once a backendService is identified and before forwarding the request to
	// the backend service, advanced routing actions like Url rewrites and header
	// transformations are applied depending on additional settings specified in this
	// HttpRouteAction.
	// Structure is documented below.
	WeightedBackendServices []PathMatcherDefaultRouteActionWeightedBackendServicesObservation `json:"weightedBackendServices,omitempty" tf:"weighted_backend_services,omitempty"`
}

type PathMatcherDefaultRouteActionParameters struct {

	// The specification for allowing client side cross-origin requests. Please see W3C
	// Recommendation for Cross Origin Resource Sharing
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	CorsPolicy []PathMatcherDefaultRouteActionCorsPolicyParameters `json:"corsPolicy,omitempty" tf:"cors_policy,omitempty"`

	// The specification for fault injection introduced into traffic to test the
	// resiliency of clients to backend service failure. As part of fault injection,
	// when clients send requests to a backend service, delays can be introduced by
	// Loadbalancer on a percentage of requests before sending those request to the
	// backend service. Similarly requests from clients can be aborted by the
	// Loadbalancer for a percentage of requests. timeout and retry_policy will be
	// ignored by clients that are configured with a fault_injection_policy.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	FaultInjectionPolicy []PathMatcherDefaultRouteActionFaultInjectionPolicyParameters `json:"faultInjectionPolicy,omitempty" tf:"fault_injection_policy,omitempty"`

	// Specifies the policy on how requests intended for the route's backends are
	// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
	// responses from the shadow service. Prior to sending traffic to the shadow
	// service, the host / authority header is suffixed with -shadow.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	RequestMirrorPolicy []PathMatcherDefaultRouteActionRequestMirrorPolicyParameters `json:"requestMirrorPolicy,omitempty" tf:"request_mirror_policy,omitempty"`

	// Specifies the retry policy associated with this route.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	RetryPolicy []PathMatcherDefaultRouteActionRetryPolicyParameters `json:"retryPolicy,omitempty" tf:"retry_policy,omitempty"`

	// Specifies the timeout for the selected route. Timeout is computed from the time
	// the request is has been fully processed (i.e. end-of-stream) up until the
	// response has been completely processed. Timeout includes all retries. If not
	// specified, the default value is 15 seconds.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Timeout []PathMatcherDefaultRouteActionTimeoutParameters `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// The spec to modify the URL of the request, prior to forwarding the request to
	// the matched service
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	URLRewrite []PathMatcherDefaultRouteActionURLRewriteParameters `json:"urlRewrite,omitempty" tf:"url_rewrite,omitempty"`

	// A list of weighted backend services to send traffic to when a route match
	// occurs. The weights determine the fraction of traffic that flows to their
	// corresponding backend service. If all traffic needs to go to a single backend
	// service, there must be one  weightedBackendService with weight set to a non 0
	// number. Once a backendService is identified and before forwarding the request to
	// the backend service, advanced routing actions like Url rewrites and header
	// transformations are applied depending on additional settings specified in this
	// HttpRouteAction.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	WeightedBackendServices []PathMatcherDefaultRouteActionWeightedBackendServicesParameters `json:"weightedBackendServices,omitempty" tf:"weighted_backend_services,omitempty"`
}

type PathMatcherDefaultRouteActionRequestMirrorPolicyInitParameters struct {

	// The default BackendService resource. Before
	// forwarding the request to backendService, the loadbalancer applies any relevant
	// headerActions specified as part of this backendServiceWeight.
	BackendService *string `json:"backendService,omitempty" tf:"backend_service,omitempty"`
}

type PathMatcherDefaultRouteActionRequestMirrorPolicyObservation struct {

	// The default BackendService resource. Before
	// forwarding the request to backendService, the loadbalancer applies any relevant
	// headerActions specified as part of this backendServiceWeight.
	BackendService *string `json:"backendService,omitempty" tf:"backend_service,omitempty"`
}

type PathMatcherDefaultRouteActionRequestMirrorPolicyParameters struct {

	// The default BackendService resource. Before
	// forwarding the request to backendService, the loadbalancer applies any relevant
	// headerActions specified as part of this backendServiceWeight.
	// +kubebuilder:validation:Optional
	BackendService *string `json:"backendService" tf:"backend_service,omitempty"`
}

type PathMatcherDefaultRouteActionRetryPolicyInitParameters struct {

	// Specifies the allowed number retries. This number must be > 0.
	NumRetries *float64 `json:"numRetries,omitempty" tf:"num_retries,omitempty"`

	// Specifies a non-zero timeout per retry attempt.
	// Structure is documented below.
	PerTryTimeout []PathMatcherDefaultRouteActionRetryPolicyPerTryTimeoutInitParameters `json:"perTryTimeout,omitempty" tf:"per_try_timeout,omitempty"`

	// Specifies one or more conditions when this retry rule applies. Valid values are:
	RetryConditions []*string `json:"retryConditions,omitempty" tf:"retry_conditions,omitempty"`
}

type PathMatcherDefaultRouteActionRetryPolicyObservation struct {

	// Specifies the allowed number retries. This number must be > 0.
	NumRetries *float64 `json:"numRetries,omitempty" tf:"num_retries,omitempty"`

	// Specifies a non-zero timeout per retry attempt.
	// Structure is documented below.
	PerTryTimeout []PathMatcherDefaultRouteActionRetryPolicyPerTryTimeoutObservation `json:"perTryTimeout,omitempty" tf:"per_try_timeout,omitempty"`

	// Specifies one or more conditions when this retry rule applies. Valid values are:
	RetryConditions []*string `json:"retryConditions,omitempty" tf:"retry_conditions,omitempty"`
}

type PathMatcherDefaultRouteActionRetryPolicyParameters struct {

	// Specifies the allowed number retries. This number must be > 0.
	// +kubebuilder:validation:Optional
	NumRetries *float64 `json:"numRetries,omitempty" tf:"num_retries,omitempty"`

	// Specifies a non-zero timeout per retry attempt.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	PerTryTimeout []PathMatcherDefaultRouteActionRetryPolicyPerTryTimeoutParameters `json:"perTryTimeout,omitempty" tf:"per_try_timeout,omitempty"`

	// Specifies one or more conditions when this retry rule applies. Valid values are:
	// +kubebuilder:validation:Optional
	RetryConditions []*string `json:"retryConditions,omitempty" tf:"retry_conditions,omitempty"`
}

type PathMatcherDefaultRouteActionRetryPolicyPerTryTimeoutInitParameters struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type PathMatcherDefaultRouteActionRetryPolicyPerTryTimeoutObservation struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type PathMatcherDefaultRouteActionRetryPolicyPerTryTimeoutParameters struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	// +kubebuilder:validation:Optional
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	// +kubebuilder:validation:Optional
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type PathMatcherDefaultRouteActionTimeoutInitParameters struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type PathMatcherDefaultRouteActionTimeoutObservation struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type PathMatcherDefaultRouteActionTimeoutParameters struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	// +kubebuilder:validation:Optional
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	// +kubebuilder:validation:Optional
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type PathMatcherDefaultRouteActionURLRewriteInitParameters struct {

	// Prior to forwarding the request to the selected service, the request's host
	// header is replaced with contents of hostRewrite. The value must be between 1 and
	// 255 characters.
	HostRewrite *string `json:"hostRewrite,omitempty" tf:"host_rewrite,omitempty"`

	// Prior to forwarding the request to the selected backend service, the matching
	// portion of the request's path is replaced by pathPrefixRewrite. The value must
	// be between 1 and 1024 characters.
	PathPrefixRewrite *string `json:"pathPrefixRewrite,omitempty" tf:"path_prefix_rewrite,omitempty"`
}

type PathMatcherDefaultRouteActionURLRewriteObservation struct {

	// Prior to forwarding the request to the selected service, the request's host
	// header is replaced with contents of hostRewrite. The value must be between 1 and
	// 255 characters.
	HostRewrite *string `json:"hostRewrite,omitempty" tf:"host_rewrite,omitempty"`

	// Prior to forwarding the request to the selected backend service, the matching
	// portion of the request's path is replaced by pathPrefixRewrite. The value must
	// be between 1 and 1024 characters.
	PathPrefixRewrite *string `json:"pathPrefixRewrite,omitempty" tf:"path_prefix_rewrite,omitempty"`
}

type PathMatcherDefaultRouteActionURLRewriteParameters struct {

	// Prior to forwarding the request to the selected service, the request's host
	// header is replaced with contents of hostRewrite. The value must be between 1 and
	// 255 characters.
	// +kubebuilder:validation:Optional
	HostRewrite *string `json:"hostRewrite,omitempty" tf:"host_rewrite,omitempty"`

	// Prior to forwarding the request to the selected backend service, the matching
	// portion of the request's path is replaced by pathPrefixRewrite. The value must
	// be between 1 and 1024 characters.
	// +kubebuilder:validation:Optional
	PathPrefixRewrite *string `json:"pathPrefixRewrite,omitempty" tf:"path_prefix_rewrite,omitempty"`
}

type PathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionInitParameters struct {

	// Headers to add to a matching request prior to forwarding the request to the
	// backendService.
	// Structure is documented below.
	RequestHeadersToAdd []PathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddInitParameters `json:"requestHeadersToAdd,omitempty" tf:"request_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the request
	// prior to forwarding the request to the backendService.
	RequestHeadersToRemove []*string `json:"requestHeadersToRemove,omitempty" tf:"request_headers_to_remove,omitempty"`

	// Headers to add the response prior to sending the response back to the client.
	// Structure is documented below.
	ResponseHeadersToAdd []PathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddInitParameters `json:"responseHeadersToAdd,omitempty" tf:"response_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the response
	// prior to sending the response back to the client.
	ResponseHeadersToRemove []*string `json:"responseHeadersToRemove,omitempty" tf:"response_headers_to_remove,omitempty"`
}

type PathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionObservation struct {

	// Headers to add to a matching request prior to forwarding the request to the
	// backendService.
	// Structure is documented below.
	RequestHeadersToAdd []PathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddObservation `json:"requestHeadersToAdd,omitempty" tf:"request_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the request
	// prior to forwarding the request to the backendService.
	RequestHeadersToRemove []*string `json:"requestHeadersToRemove,omitempty" tf:"request_headers_to_remove,omitempty"`

	// Headers to add the response prior to sending the response back to the client.
	// Structure is documented below.
	ResponseHeadersToAdd []PathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddObservation `json:"responseHeadersToAdd,omitempty" tf:"response_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the response
	// prior to sending the response back to the client.
	ResponseHeadersToRemove []*string `json:"responseHeadersToRemove,omitempty" tf:"response_headers_to_remove,omitempty"`
}

type PathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionParameters struct {

	// Headers to add to a matching request prior to forwarding the request to the
	// backendService.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	RequestHeadersToAdd []PathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddParameters `json:"requestHeadersToAdd,omitempty" tf:"request_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the request
	// prior to forwarding the request to the backendService.
	// +kubebuilder:validation:Optional
	RequestHeadersToRemove []*string `json:"requestHeadersToRemove,omitempty" tf:"request_headers_to_remove,omitempty"`

	// Headers to add the response prior to sending the response back to the client.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	ResponseHeadersToAdd []PathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddParameters `json:"responseHeadersToAdd,omitempty" tf:"response_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the response
	// prior to sending the response back to the client.
	// +kubebuilder:validation:Optional
	ResponseHeadersToRemove []*string `json:"responseHeadersToRemove,omitempty" tf:"response_headers_to_remove,omitempty"`
}

type PathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddInitParameters struct {

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type PathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddObservation struct {

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type PathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddParameters struct {

	// The name of the header.
	// +kubebuilder:validation:Optional
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	// +kubebuilder:validation:Optional
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	// +kubebuilder:validation:Optional
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type PathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddInitParameters struct {

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type PathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddObservation struct {

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type PathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddParameters struct {

	// The name of the header.
	// +kubebuilder:validation:Optional
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	// +kubebuilder:validation:Optional
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	// +kubebuilder:validation:Optional
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type PathMatcherDefaultRouteActionWeightedBackendServicesInitParameters struct {

	// The default BackendService resource. Before
	// forwarding the request to backendService, the loadbalancer applies any relevant
	// headerActions specified as part of this backendServiceWeight.
	BackendService *string `json:"backendService,omitempty" tf:"backend_service,omitempty"`

	// Specifies changes to request and response headers that need to take effect for
	// the selected backendService. headerAction specified here take effect before
	// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
	// Structure is documented below.
	HeaderAction []PathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionInitParameters `json:"headerAction,omitempty" tf:"header_action,omitempty"`

	// Specifies the fraction of traffic sent to backendService, computed as weight /
	// (sum of all weightedBackendService weights in routeAction) . The selection of a
	// backend service is determined only for new traffic. Once a user's request has
	// been directed to a backendService, subsequent requests will be sent to the same
	// backendService as determined by the BackendService's session affinity policy.
	// The value must be between 0 and 1000
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type PathMatcherDefaultRouteActionWeightedBackendServicesObservation struct {

	// The default BackendService resource. Before
	// forwarding the request to backendService, the loadbalancer applies any relevant
	// headerActions specified as part of this backendServiceWeight.
	BackendService *string `json:"backendService,omitempty" tf:"backend_service,omitempty"`

	// Specifies changes to request and response headers that need to take effect for
	// the selected backendService. headerAction specified here take effect before
	// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
	// Structure is documented below.
	HeaderAction []PathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionObservation `json:"headerAction,omitempty" tf:"header_action,omitempty"`

	// Specifies the fraction of traffic sent to backendService, computed as weight /
	// (sum of all weightedBackendService weights in routeAction) . The selection of a
	// backend service is determined only for new traffic. Once a user's request has
	// been directed to a backendService, subsequent requests will be sent to the same
	// backendService as determined by the BackendService's session affinity policy.
	// The value must be between 0 and 1000
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type PathMatcherDefaultRouteActionWeightedBackendServicesParameters struct {

	// The default BackendService resource. Before
	// forwarding the request to backendService, the loadbalancer applies any relevant
	// headerActions specified as part of this backendServiceWeight.
	// +kubebuilder:validation:Optional
	BackendService *string `json:"backendService,omitempty" tf:"backend_service,omitempty"`

	// Specifies changes to request and response headers that need to take effect for
	// the selected backendService. headerAction specified here take effect before
	// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	HeaderAction []PathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionParameters `json:"headerAction,omitempty" tf:"header_action,omitempty"`

	// Specifies the fraction of traffic sent to backendService, computed as weight /
	// (sum of all weightedBackendService weights in routeAction) . The selection of a
	// backend service is determined only for new traffic. Once a user's request has
	// been directed to a backendService, subsequent requests will be sent to the same
	// backendService as determined by the BackendService's session affinity policy.
	// The value must be between 0 and 1000
	// +kubebuilder:validation:Optional
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type PathMatcherHeaderActionInitParameters struct {

	// Headers to add to a matching request prior to forwarding the request to the
	// backendService.
	// Structure is documented below.
	RequestHeadersToAdd []PathMatcherHeaderActionRequestHeadersToAddInitParameters `json:"requestHeadersToAdd,omitempty" tf:"request_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the request
	// prior to forwarding the request to the backendService.
	RequestHeadersToRemove []*string `json:"requestHeadersToRemove,omitempty" tf:"request_headers_to_remove,omitempty"`

	// Headers to add the response prior to sending the response back to the client.
	// Structure is documented below.
	ResponseHeadersToAdd []PathMatcherHeaderActionResponseHeadersToAddInitParameters `json:"responseHeadersToAdd,omitempty" tf:"response_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the response
	// prior to sending the response back to the client.
	ResponseHeadersToRemove []*string `json:"responseHeadersToRemove,omitempty" tf:"response_headers_to_remove,omitempty"`
}

type PathMatcherHeaderActionObservation struct {

	// Headers to add to a matching request prior to forwarding the request to the
	// backendService.
	// Structure is documented below.
	RequestHeadersToAdd []PathMatcherHeaderActionRequestHeadersToAddObservation `json:"requestHeadersToAdd,omitempty" tf:"request_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the request
	// prior to forwarding the request to the backendService.
	RequestHeadersToRemove []*string `json:"requestHeadersToRemove,omitempty" tf:"request_headers_to_remove,omitempty"`

	// Headers to add the response prior to sending the response back to the client.
	// Structure is documented below.
	ResponseHeadersToAdd []PathMatcherHeaderActionResponseHeadersToAddObservation `json:"responseHeadersToAdd,omitempty" tf:"response_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the response
	// prior to sending the response back to the client.
	ResponseHeadersToRemove []*string `json:"responseHeadersToRemove,omitempty" tf:"response_headers_to_remove,omitempty"`
}

type PathMatcherHeaderActionParameters struct {

	// Headers to add to a matching request prior to forwarding the request to the
	// backendService.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	RequestHeadersToAdd []PathMatcherHeaderActionRequestHeadersToAddParameters `json:"requestHeadersToAdd,omitempty" tf:"request_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the request
	// prior to forwarding the request to the backendService.
	// +kubebuilder:validation:Optional
	RequestHeadersToRemove []*string `json:"requestHeadersToRemove,omitempty" tf:"request_headers_to_remove,omitempty"`

	// Headers to add the response prior to sending the response back to the client.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	ResponseHeadersToAdd []PathMatcherHeaderActionResponseHeadersToAddParameters `json:"responseHeadersToAdd,omitempty" tf:"response_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the response
	// prior to sending the response back to the client.
	// +kubebuilder:validation:Optional
	ResponseHeadersToRemove []*string `json:"responseHeadersToRemove,omitempty" tf:"response_headers_to_remove,omitempty"`
}

type PathMatcherHeaderActionRequestHeadersToAddInitParameters struct {

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type PathMatcherHeaderActionRequestHeadersToAddObservation struct {

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type PathMatcherHeaderActionRequestHeadersToAddParameters struct {

	// The name of the header.
	// +kubebuilder:validation:Optional
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`

	// The value of the header to add.
	// +kubebuilder:validation:Optional
	HeaderValue *string `json:"headerValue" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	// +kubebuilder:validation:Optional
	Replace *bool `json:"replace" tf:"replace,omitempty"`
}

type PathMatcherHeaderActionResponseHeadersToAddInitParameters struct {

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type PathMatcherHeaderActionResponseHeadersToAddObservation struct {

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type PathMatcherHeaderActionResponseHeadersToAddParameters struct {

	// The name of the header.
	// +kubebuilder:validation:Optional
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`

	// The value of the header to add.
	// +kubebuilder:validation:Optional
	HeaderValue *string `json:"headerValue" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	// +kubebuilder:validation:Optional
	Replace *bool `json:"replace" tf:"replace,omitempty"`
}

type PathMatcherPathRuleInitParameters struct {

	// The list of path patterns to match. Each must start with / and the only place a
	// * is allowed is at the end following a /. The string fed to the path matcher
	// does not include any text after the first ? or #, and those chars are not
	// allowed here.
	// +listType=set
	Paths []*string `json:"paths,omitempty" tf:"paths,omitempty"`

	// In response to a matching matchRule, the load balancer performs advanced routing
	// actions like URL rewrites, header transformations, etc. prior to forwarding the
	// request to the selected backend. If  routeAction specifies any
	// weightedBackendServices, service must not be set. Conversely if service is set,
	// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
	// or urlRedirect must be set.
	// Structure is documented below.
	RouteAction []PathRuleRouteActionInitParameters `json:"routeAction,omitempty" tf:"route_action,omitempty"`

	// The backend service or backend bucket link that should be matched by this test.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.BackendBucket
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// Reference to a BackendBucket in compute to populate service.
	// +kubebuilder:validation:Optional
	ServiceRef *v1.Reference `json:"serviceRef,omitempty" tf:"-"`

	// Selector for a BackendBucket in compute to populate service.
	// +kubebuilder:validation:Optional
	ServiceSelector *v1.Selector `json:"serviceSelector,omitempty" tf:"-"`

	// When this rule is matched, the request is redirected to a URL specified by
	// urlRedirect. If urlRedirect is specified, service or routeAction must not be
	// set.
	// Structure is documented below.
	URLRedirect []PathRuleURLRedirectInitParameters `json:"urlRedirect,omitempty" tf:"url_redirect,omitempty"`
}

type PathMatcherPathRuleObservation struct {

	// The list of path patterns to match. Each must start with / and the only place a
	// * is allowed is at the end following a /. The string fed to the path matcher
	// does not include any text after the first ? or #, and those chars are not
	// allowed here.
	// +listType=set
	Paths []*string `json:"paths,omitempty" tf:"paths,omitempty"`

	// In response to a matching matchRule, the load balancer performs advanced routing
	// actions like URL rewrites, header transformations, etc. prior to forwarding the
	// request to the selected backend. If  routeAction specifies any
	// weightedBackendServices, service must not be set. Conversely if service is set,
	// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
	// or urlRedirect must be set.
	// Structure is documented below.
	RouteAction []PathRuleRouteActionObservation `json:"routeAction,omitempty" tf:"route_action,omitempty"`

	// The backend service or backend bucket link that should be matched by this test.
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// When this rule is matched, the request is redirected to a URL specified by
	// urlRedirect. If urlRedirect is specified, service or routeAction must not be
	// set.
	// Structure is documented below.
	URLRedirect []PathRuleURLRedirectObservation `json:"urlRedirect,omitempty" tf:"url_redirect,omitempty"`
}

type PathMatcherPathRuleParameters struct {

	// The list of path patterns to match. Each must start with / and the only place a
	// * is allowed is at the end following a /. The string fed to the path matcher
	// does not include any text after the first ? or #, and those chars are not
	// allowed here.
	// +kubebuilder:validation:Optional
	// +listType=set
	Paths []*string `json:"paths" tf:"paths,omitempty"`

	// In response to a matching matchRule, the load balancer performs advanced routing
	// actions like URL rewrites, header transformations, etc. prior to forwarding the
	// request to the selected backend. If  routeAction specifies any
	// weightedBackendServices, service must not be set. Conversely if service is set,
	// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
	// or urlRedirect must be set.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	RouteAction []PathRuleRouteActionParameters `json:"routeAction,omitempty" tf:"route_action,omitempty"`

	// The backend service or backend bucket link that should be matched by this test.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.BackendBucket
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// Reference to a BackendBucket in compute to populate service.
	// +kubebuilder:validation:Optional
	ServiceRef *v1.Reference `json:"serviceRef,omitempty" tf:"-"`

	// Selector for a BackendBucket in compute to populate service.
	// +kubebuilder:validation:Optional
	ServiceSelector *v1.Selector `json:"serviceSelector,omitempty" tf:"-"`

	// When this rule is matched, the request is redirected to a URL specified by
	// urlRedirect. If urlRedirect is specified, service or routeAction must not be
	// set.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	URLRedirect []PathRuleURLRedirectParameters `json:"urlRedirect,omitempty" tf:"url_redirect,omitempty"`
}

type PathMatcherRouteRulesHeaderActionInitParameters struct {

	// Headers to add to a matching request prior to forwarding the request to the
	// backendService.
	// Structure is documented below.
	RequestHeadersToAdd []PathMatcherRouteRulesHeaderActionRequestHeadersToAddInitParameters `json:"requestHeadersToAdd,omitempty" tf:"request_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the request
	// prior to forwarding the request to the backendService.
	RequestHeadersToRemove []*string `json:"requestHeadersToRemove,omitempty" tf:"request_headers_to_remove,omitempty"`

	// Headers to add the response prior to sending the response back to the client.
	// Structure is documented below.
	ResponseHeadersToAdd []PathMatcherRouteRulesHeaderActionResponseHeadersToAddInitParameters `json:"responseHeadersToAdd,omitempty" tf:"response_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the response
	// prior to sending the response back to the client.
	ResponseHeadersToRemove []*string `json:"responseHeadersToRemove,omitempty" tf:"response_headers_to_remove,omitempty"`
}

type PathMatcherRouteRulesHeaderActionObservation struct {

	// Headers to add to a matching request prior to forwarding the request to the
	// backendService.
	// Structure is documented below.
	RequestHeadersToAdd []PathMatcherRouteRulesHeaderActionRequestHeadersToAddObservation `json:"requestHeadersToAdd,omitempty" tf:"request_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the request
	// prior to forwarding the request to the backendService.
	RequestHeadersToRemove []*string `json:"requestHeadersToRemove,omitempty" tf:"request_headers_to_remove,omitempty"`

	// Headers to add the response prior to sending the response back to the client.
	// Structure is documented below.
	ResponseHeadersToAdd []PathMatcherRouteRulesHeaderActionResponseHeadersToAddObservation `json:"responseHeadersToAdd,omitempty" tf:"response_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the response
	// prior to sending the response back to the client.
	ResponseHeadersToRemove []*string `json:"responseHeadersToRemove,omitempty" tf:"response_headers_to_remove,omitempty"`
}

type PathMatcherRouteRulesHeaderActionParameters struct {

	// Headers to add to a matching request prior to forwarding the request to the
	// backendService.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	RequestHeadersToAdd []PathMatcherRouteRulesHeaderActionRequestHeadersToAddParameters `json:"requestHeadersToAdd,omitempty" tf:"request_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the request
	// prior to forwarding the request to the backendService.
	// +kubebuilder:validation:Optional
	RequestHeadersToRemove []*string `json:"requestHeadersToRemove,omitempty" tf:"request_headers_to_remove,omitempty"`

	// Headers to add the response prior to sending the response back to the client.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	ResponseHeadersToAdd []PathMatcherRouteRulesHeaderActionResponseHeadersToAddParameters `json:"responseHeadersToAdd,omitempty" tf:"response_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the response
	// prior to sending the response back to the client.
	// +kubebuilder:validation:Optional
	ResponseHeadersToRemove []*string `json:"responseHeadersToRemove,omitempty" tf:"response_headers_to_remove,omitempty"`
}

type PathMatcherRouteRulesHeaderActionRequestHeadersToAddInitParameters struct {

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type PathMatcherRouteRulesHeaderActionRequestHeadersToAddObservation struct {

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type PathMatcherRouteRulesHeaderActionRequestHeadersToAddParameters struct {

	// The name of the header.
	// +kubebuilder:validation:Optional
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`

	// The value of the header to add.
	// +kubebuilder:validation:Optional
	HeaderValue *string `json:"headerValue" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	// +kubebuilder:validation:Optional
	Replace *bool `json:"replace" tf:"replace,omitempty"`
}

type PathMatcherRouteRulesHeaderActionResponseHeadersToAddInitParameters struct {

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type PathMatcherRouteRulesHeaderActionResponseHeadersToAddObservation struct {

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type PathMatcherRouteRulesHeaderActionResponseHeadersToAddParameters struct {

	// The name of the header.
	// +kubebuilder:validation:Optional
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`

	// The value of the header to add.
	// +kubebuilder:validation:Optional
	HeaderValue *string `json:"headerValue" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	// +kubebuilder:validation:Optional
	Replace *bool `json:"replace" tf:"replace,omitempty"`
}

type PathMatcherRouteRulesInitParameters struct {

	// Specifies changes to request and response headers that need to take effect for
	// the selected backendService. headerAction specified here take effect before
	// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
	// Structure is documented below.
	HeaderAction []PathMatcherRouteRulesHeaderActionInitParameters `json:"headerAction,omitempty" tf:"header_action,omitempty"`

	// The rules for determining a match.
	// Structure is documented below.
	MatchRules []RouteRulesMatchRulesInitParameters `json:"matchRules,omitempty" tf:"match_rules,omitempty"`

	// For routeRules within a given pathMatcher, priority determines the order
	// in which load balancer will interpret routeRules. RouteRules are evaluated
	// in order of priority, from the lowest to highest number. The priority of
	// a rule decreases as its number increases (1, 2, 3, N+1). The first rule
	// that matches the request is applied.
	// You cannot configure two or more routeRules with the same priority.
	// Priority for each rule must be set to a number between 0 and
	// 2147483647 inclusive.
	// Priority numbers can have gaps, which enable you to add or remove rules
	// in the future without affecting the rest of the rules. For example,
	// 1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
	// you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
	// future without any impact on existing rules.
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// In response to a matching matchRule, the load balancer performs advanced routing
	// actions like URL rewrites, header transformations, etc. prior to forwarding the
	// request to the selected backend. If  routeAction specifies any
	// weightedBackendServices, service must not be set. Conversely if service is set,
	// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
	// or urlRedirect must be set.
	// Structure is documented below.
	RouteAction []PathMatcherRouteRulesRouteActionInitParameters `json:"routeAction,omitempty" tf:"route_action,omitempty"`

	// The backend service or backend bucket link that should be matched by this test.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.BackendService
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// Reference to a BackendService in compute to populate service.
	// +kubebuilder:validation:Optional
	ServiceRef *v1.Reference `json:"serviceRef,omitempty" tf:"-"`

	// Selector for a BackendService in compute to populate service.
	// +kubebuilder:validation:Optional
	ServiceSelector *v1.Selector `json:"serviceSelector,omitempty" tf:"-"`

	// When this rule is matched, the request is redirected to a URL specified by
	// urlRedirect. If urlRedirect is specified, service or routeAction must not be
	// set.
	// Structure is documented below.
	URLRedirect []PathMatcherRouteRulesURLRedirectInitParameters `json:"urlRedirect,omitempty" tf:"url_redirect,omitempty"`
}

type PathMatcherRouteRulesObservation struct {

	// Specifies changes to request and response headers that need to take effect for
	// the selected backendService. headerAction specified here take effect before
	// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
	// Structure is documented below.
	HeaderAction []PathMatcherRouteRulesHeaderActionObservation `json:"headerAction,omitempty" tf:"header_action,omitempty"`

	// The rules for determining a match.
	// Structure is documented below.
	MatchRules []RouteRulesMatchRulesObservation `json:"matchRules,omitempty" tf:"match_rules,omitempty"`

	// For routeRules within a given pathMatcher, priority determines the order
	// in which load balancer will interpret routeRules. RouteRules are evaluated
	// in order of priority, from the lowest to highest number. The priority of
	// a rule decreases as its number increases (1, 2, 3, N+1). The first rule
	// that matches the request is applied.
	// You cannot configure two or more routeRules with the same priority.
	// Priority for each rule must be set to a number between 0 and
	// 2147483647 inclusive.
	// Priority numbers can have gaps, which enable you to add or remove rules
	// in the future without affecting the rest of the rules. For example,
	// 1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
	// you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
	// future without any impact on existing rules.
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// In response to a matching matchRule, the load balancer performs advanced routing
	// actions like URL rewrites, header transformations, etc. prior to forwarding the
	// request to the selected backend. If  routeAction specifies any
	// weightedBackendServices, service must not be set. Conversely if service is set,
	// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
	// or urlRedirect must be set.
	// Structure is documented below.
	RouteAction []PathMatcherRouteRulesRouteActionObservation `json:"routeAction,omitempty" tf:"route_action,omitempty"`

	// The backend service or backend bucket link that should be matched by this test.
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// When this rule is matched, the request is redirected to a URL specified by
	// urlRedirect. If urlRedirect is specified, service or routeAction must not be
	// set.
	// Structure is documented below.
	URLRedirect []PathMatcherRouteRulesURLRedirectObservation `json:"urlRedirect,omitempty" tf:"url_redirect,omitempty"`
}

type PathMatcherRouteRulesParameters struct {

	// Specifies changes to request and response headers that need to take effect for
	// the selected backendService. headerAction specified here take effect before
	// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	HeaderAction []PathMatcherRouteRulesHeaderActionParameters `json:"headerAction,omitempty" tf:"header_action,omitempty"`

	// The rules for determining a match.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	MatchRules []RouteRulesMatchRulesParameters `json:"matchRules,omitempty" tf:"match_rules,omitempty"`

	// For routeRules within a given pathMatcher, priority determines the order
	// in which load balancer will interpret routeRules. RouteRules are evaluated
	// in order of priority, from the lowest to highest number. The priority of
	// a rule decreases as its number increases (1, 2, 3, N+1). The first rule
	// that matches the request is applied.
	// You cannot configure two or more routeRules with the same priority.
	// Priority for each rule must be set to a number between 0 and
	// 2147483647 inclusive.
	// Priority numbers can have gaps, which enable you to add or remove rules
	// in the future without affecting the rest of the rules. For example,
	// 1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
	// you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
	// future without any impact on existing rules.
	// +kubebuilder:validation:Optional
	Priority *float64 `json:"priority" tf:"priority,omitempty"`

	// In response to a matching matchRule, the load balancer performs advanced routing
	// actions like URL rewrites, header transformations, etc. prior to forwarding the
	// request to the selected backend. If  routeAction specifies any
	// weightedBackendServices, service must not be set. Conversely if service is set,
	// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
	// or urlRedirect must be set.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	RouteAction []PathMatcherRouteRulesRouteActionParameters `json:"routeAction,omitempty" tf:"route_action,omitempty"`

	// The backend service or backend bucket link that should be matched by this test.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.BackendService
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// Reference to a BackendService in compute to populate service.
	// +kubebuilder:validation:Optional
	ServiceRef *v1.Reference `json:"serviceRef,omitempty" tf:"-"`

	// Selector for a BackendService in compute to populate service.
	// +kubebuilder:validation:Optional
	ServiceSelector *v1.Selector `json:"serviceSelector,omitempty" tf:"-"`

	// When this rule is matched, the request is redirected to a URL specified by
	// urlRedirect. If urlRedirect is specified, service or routeAction must not be
	// set.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	URLRedirect []PathMatcherRouteRulesURLRedirectParameters `json:"urlRedirect,omitempty" tf:"url_redirect,omitempty"`
}

type PathMatcherRouteRulesRouteActionCorsPolicyInitParameters struct {

	// In response to a preflight request, setting this to true indicates that the
	// actual request can include user credentials. This translates to the Access-
	// Control-Allow-Credentials header. Defaults to false.
	AllowCredentials *bool `json:"allowCredentials,omitempty" tf:"allow_credentials,omitempty"`

	// Specifies the content for the Access-Control-Allow-Headers header.
	AllowHeaders []*string `json:"allowHeaders,omitempty" tf:"allow_headers,omitempty"`

	// Specifies the content for the Access-Control-Allow-Methods header.
	AllowMethods []*string `json:"allowMethods,omitempty" tf:"allow_methods,omitempty"`

	// Specifies the regular expression patterns that match allowed origins. For
	// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
	// An origin is allowed if it matches either allow_origins or allow_origin_regex.
	AllowOriginRegexes []*string `json:"allowOriginRegexes,omitempty" tf:"allow_origin_regexes,omitempty"`

	// Specifies the list of origins that will be allowed to do CORS requests. An
	// origin is allowed if it matches either allow_origins or allow_origin_regex.
	AllowOrigins []*string `json:"allowOrigins,omitempty" tf:"allow_origins,omitempty"`

	// If true, specifies the CORS policy is disabled.
	Disabled *bool `json:"disabled,omitempty" tf:"disabled,omitempty"`

	// Specifies the content for the Access-Control-Expose-Headers header.
	ExposeHeaders []*string `json:"exposeHeaders,omitempty" tf:"expose_headers,omitempty"`

	// Specifies how long the results of a preflight request can be cached. This
	// translates to the content for the Access-Control-Max-Age header.
	MaxAge *float64 `json:"maxAge,omitempty" tf:"max_age,omitempty"`
}

type PathMatcherRouteRulesRouteActionCorsPolicyObservation struct {

	// In response to a preflight request, setting this to true indicates that the
	// actual request can include user credentials. This translates to the Access-
	// Control-Allow-Credentials header. Defaults to false.
	AllowCredentials *bool `json:"allowCredentials,omitempty" tf:"allow_credentials,omitempty"`

	// Specifies the content for the Access-Control-Allow-Headers header.
	AllowHeaders []*string `json:"allowHeaders,omitempty" tf:"allow_headers,omitempty"`

	// Specifies the content for the Access-Control-Allow-Methods header.
	AllowMethods []*string `json:"allowMethods,omitempty" tf:"allow_methods,omitempty"`

	// Specifies the regular expression patterns that match allowed origins. For
	// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
	// An origin is allowed if it matches either allow_origins or allow_origin_regex.
	AllowOriginRegexes []*string `json:"allowOriginRegexes,omitempty" tf:"allow_origin_regexes,omitempty"`

	// Specifies the list of origins that will be allowed to do CORS requests. An
	// origin is allowed if it matches either allow_origins or allow_origin_regex.
	AllowOrigins []*string `json:"allowOrigins,omitempty" tf:"allow_origins,omitempty"`

	// If true, specifies the CORS policy is disabled.
	Disabled *bool `json:"disabled,omitempty" tf:"disabled,omitempty"`

	// Specifies the content for the Access-Control-Expose-Headers header.
	ExposeHeaders []*string `json:"exposeHeaders,omitempty" tf:"expose_headers,omitempty"`

	// Specifies how long the results of a preflight request can be cached. This
	// translates to the content for the Access-Control-Max-Age header.
	MaxAge *float64 `json:"maxAge,omitempty" tf:"max_age,omitempty"`
}

type PathMatcherRouteRulesRouteActionCorsPolicyParameters struct {

	// In response to a preflight request, setting this to true indicates that the
	// actual request can include user credentials. This translates to the Access-
	// Control-Allow-Credentials header. Defaults to false.
	// +kubebuilder:validation:Optional
	AllowCredentials *bool `json:"allowCredentials,omitempty" tf:"allow_credentials,omitempty"`

	// Specifies the content for the Access-Control-Allow-Headers header.
	// +kubebuilder:validation:Optional
	AllowHeaders []*string `json:"allowHeaders,omitempty" tf:"allow_headers,omitempty"`

	// Specifies the content for the Access-Control-Allow-Methods header.
	// +kubebuilder:validation:Optional
	AllowMethods []*string `json:"allowMethods,omitempty" tf:"allow_methods,omitempty"`

	// Specifies the regular expression patterns that match allowed origins. For
	// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
	// An origin is allowed if it matches either allow_origins or allow_origin_regex.
	// +kubebuilder:validation:Optional
	AllowOriginRegexes []*string `json:"allowOriginRegexes,omitempty" tf:"allow_origin_regexes,omitempty"`

	// Specifies the list of origins that will be allowed to do CORS requests. An
	// origin is allowed if it matches either allow_origins or allow_origin_regex.
	// +kubebuilder:validation:Optional
	AllowOrigins []*string `json:"allowOrigins,omitempty" tf:"allow_origins,omitempty"`

	// If true, specifies the CORS policy is disabled.
	// +kubebuilder:validation:Optional
	Disabled *bool `json:"disabled,omitempty" tf:"disabled,omitempty"`

	// Specifies the content for the Access-Control-Expose-Headers header.
	// +kubebuilder:validation:Optional
	ExposeHeaders []*string `json:"exposeHeaders,omitempty" tf:"expose_headers,omitempty"`

	// Specifies how long the results of a preflight request can be cached. This
	// translates to the content for the Access-Control-Max-Age header.
	// +kubebuilder:validation:Optional
	MaxAge *float64 `json:"maxAge,omitempty" tf:"max_age,omitempty"`
}

type PathMatcherRouteRulesRouteActionFaultInjectionPolicyInitParameters struct {

	// The specification for how client requests are aborted as part of fault
	// injection.
	// Structure is documented below.
	Abort []RouteRulesRouteActionFaultInjectionPolicyAbortInitParameters `json:"abort,omitempty" tf:"abort,omitempty"`

	// The specification for how client requests are delayed as part of fault
	// injection, before being sent to a backend service.
	// Structure is documented below.
	Delay []RouteRulesRouteActionFaultInjectionPolicyDelayInitParameters `json:"delay,omitempty" tf:"delay,omitempty"`
}

type PathMatcherRouteRulesRouteActionFaultInjectionPolicyObservation struct {

	// The specification for how client requests are aborted as part of fault
	// injection.
	// Structure is documented below.
	Abort []RouteRulesRouteActionFaultInjectionPolicyAbortObservation `json:"abort,omitempty" tf:"abort,omitempty"`

	// The specification for how client requests are delayed as part of fault
	// injection, before being sent to a backend service.
	// Structure is documented below.
	Delay []RouteRulesRouteActionFaultInjectionPolicyDelayObservation `json:"delay,omitempty" tf:"delay,omitempty"`
}

type PathMatcherRouteRulesRouteActionFaultInjectionPolicyParameters struct {

	// The specification for how client requests are aborted as part of fault
	// injection.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Abort []RouteRulesRouteActionFaultInjectionPolicyAbortParameters `json:"abort,omitempty" tf:"abort,omitempty"`

	// The specification for how client requests are delayed as part of fault
	// injection, before being sent to a backend service.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Delay []RouteRulesRouteActionFaultInjectionPolicyDelayParameters `json:"delay,omitempty" tf:"delay,omitempty"`
}

type PathMatcherRouteRulesRouteActionInitParameters struct {

	// The specification for allowing client side cross-origin requests. Please see W3C
	// Recommendation for Cross Origin Resource Sharing
	// Structure is documented below.
	CorsPolicy []PathMatcherRouteRulesRouteActionCorsPolicyInitParameters `json:"corsPolicy,omitempty" tf:"cors_policy,omitempty"`

	// The specification for fault injection introduced into traffic to test the
	// resiliency of clients to backend service failure. As part of fault injection,
	// when clients send requests to a backend service, delays can be introduced by
	// Loadbalancer on a percentage of requests before sending those request to the
	// backend service. Similarly requests from clients can be aborted by the
	// Loadbalancer for a percentage of requests. timeout and retry_policy will be
	// ignored by clients that are configured with a fault_injection_policy.
	// Structure is documented below.
	FaultInjectionPolicy []PathMatcherRouteRulesRouteActionFaultInjectionPolicyInitParameters `json:"faultInjectionPolicy,omitempty" tf:"fault_injection_policy,omitempty"`

	// Specifies the policy on how requests intended for the route's backends are
	// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
	// responses from the shadow service. Prior to sending traffic to the shadow
	// service, the host / authority header is suffixed with -shadow.
	// Structure is documented below.
	RequestMirrorPolicy []PathMatcherRouteRulesRouteActionRequestMirrorPolicyInitParameters `json:"requestMirrorPolicy,omitempty" tf:"request_mirror_policy,omitempty"`

	// Specifies the retry policy associated with this route.
	// Structure is documented below.
	RetryPolicy []PathMatcherRouteRulesRouteActionRetryPolicyInitParameters `json:"retryPolicy,omitempty" tf:"retry_policy,omitempty"`

	// Specifies the timeout for the selected route. Timeout is computed from the time
	// the request is has been fully processed (i.e. end-of-stream) up until the
	// response has been completely processed. Timeout includes all retries. If not
	// specified, the default value is 15 seconds.
	// Structure is documented below.
	Timeout []PathMatcherRouteRulesRouteActionTimeoutInitParameters `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// The spec to modify the URL of the request, prior to forwarding the request to
	// the matched service
	// Structure is documented below.
	URLRewrite []PathMatcherRouteRulesRouteActionURLRewriteInitParameters `json:"urlRewrite,omitempty" tf:"url_rewrite,omitempty"`

	// A list of weighted backend services to send traffic to when a route match
	// occurs. The weights determine the fraction of traffic that flows to their
	// corresponding backend service. If all traffic needs to go to a single backend
	// service, there must be one  weightedBackendService with weight set to a non 0
	// number. Once a backendService is identified and before forwarding the request to
	// the backend service, advanced routing actions like Url rewrites and header
	// transformations are applied depending on additional settings specified in this
	// HttpRouteAction.
	// Structure is documented below.
	WeightedBackendServices []PathMatcherRouteRulesRouteActionWeightedBackendServicesInitParameters `json:"weightedBackendServices,omitempty" tf:"weighted_backend_services,omitempty"`
}

type PathMatcherRouteRulesRouteActionObservation struct {

	// The specification for allowing client side cross-origin requests. Please see W3C
	// Recommendation for Cross Origin Resource Sharing
	// Structure is documented below.
	CorsPolicy []PathMatcherRouteRulesRouteActionCorsPolicyObservation `json:"corsPolicy,omitempty" tf:"cors_policy,omitempty"`

	// The specification for fault injection introduced into traffic to test the
	// resiliency of clients to backend service failure. As part of fault injection,
	// when clients send requests to a backend service, delays can be introduced by
	// Loadbalancer on a percentage of requests before sending those request to the
	// backend service. Similarly requests from clients can be aborted by the
	// Loadbalancer for a percentage of requests. timeout and retry_policy will be
	// ignored by clients that are configured with a fault_injection_policy.
	// Structure is documented below.
	FaultInjectionPolicy []PathMatcherRouteRulesRouteActionFaultInjectionPolicyObservation `json:"faultInjectionPolicy,omitempty" tf:"fault_injection_policy,omitempty"`

	// Specifies the policy on how requests intended for the route's backends are
	// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
	// responses from the shadow service. Prior to sending traffic to the shadow
	// service, the host / authority header is suffixed with -shadow.
	// Structure is documented below.
	RequestMirrorPolicy []PathMatcherRouteRulesRouteActionRequestMirrorPolicyObservation `json:"requestMirrorPolicy,omitempty" tf:"request_mirror_policy,omitempty"`

	// Specifies the retry policy associated with this route.
	// Structure is documented below.
	RetryPolicy []PathMatcherRouteRulesRouteActionRetryPolicyObservation `json:"retryPolicy,omitempty" tf:"retry_policy,omitempty"`

	// Specifies the timeout for the selected route. Timeout is computed from the time
	// the request is has been fully processed (i.e. end-of-stream) up until the
	// response has been completely processed. Timeout includes all retries. If not
	// specified, the default value is 15 seconds.
	// Structure is documented below.
	Timeout []PathMatcherRouteRulesRouteActionTimeoutObservation `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// The spec to modify the URL of the request, prior to forwarding the request to
	// the matched service
	// Structure is documented below.
	URLRewrite []PathMatcherRouteRulesRouteActionURLRewriteObservation `json:"urlRewrite,omitempty" tf:"url_rewrite,omitempty"`

	// A list of weighted backend services to send traffic to when a route match
	// occurs. The weights determine the fraction of traffic that flows to their
	// corresponding backend service. If all traffic needs to go to a single backend
	// service, there must be one  weightedBackendService with weight set to a non 0
	// number. Once a backendService is identified and before forwarding the request to
	// the backend service, advanced routing actions like Url rewrites and header
	// transformations are applied depending on additional settings specified in this
	// HttpRouteAction.
	// Structure is documented below.
	WeightedBackendServices []PathMatcherRouteRulesRouteActionWeightedBackendServicesObservation `json:"weightedBackendServices,omitempty" tf:"weighted_backend_services,omitempty"`
}

type PathMatcherRouteRulesRouteActionParameters struct {

	// The specification for allowing client side cross-origin requests. Please see W3C
	// Recommendation for Cross Origin Resource Sharing
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	CorsPolicy []PathMatcherRouteRulesRouteActionCorsPolicyParameters `json:"corsPolicy,omitempty" tf:"cors_policy,omitempty"`

	// The specification for fault injection introduced into traffic to test the
	// resiliency of clients to backend service failure. As part of fault injection,
	// when clients send requests to a backend service, delays can be introduced by
	// Loadbalancer on a percentage of requests before sending those request to the
	// backend service. Similarly requests from clients can be aborted by the
	// Loadbalancer for a percentage of requests. timeout and retry_policy will be
	// ignored by clients that are configured with a fault_injection_policy.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	FaultInjectionPolicy []PathMatcherRouteRulesRouteActionFaultInjectionPolicyParameters `json:"faultInjectionPolicy,omitempty" tf:"fault_injection_policy,omitempty"`

	// Specifies the policy on how requests intended for the route's backends are
	// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
	// responses from the shadow service. Prior to sending traffic to the shadow
	// service, the host / authority header is suffixed with -shadow.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	RequestMirrorPolicy []PathMatcherRouteRulesRouteActionRequestMirrorPolicyParameters `json:"requestMirrorPolicy,omitempty" tf:"request_mirror_policy,omitempty"`

	// Specifies the retry policy associated with this route.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	RetryPolicy []PathMatcherRouteRulesRouteActionRetryPolicyParameters `json:"retryPolicy,omitempty" tf:"retry_policy,omitempty"`

	// Specifies the timeout for the selected route. Timeout is computed from the time
	// the request is has been fully processed (i.e. end-of-stream) up until the
	// response has been completely processed. Timeout includes all retries. If not
	// specified, the default value is 15 seconds.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Timeout []PathMatcherRouteRulesRouteActionTimeoutParameters `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// The spec to modify the URL of the request, prior to forwarding the request to
	// the matched service
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	URLRewrite []PathMatcherRouteRulesRouteActionURLRewriteParameters `json:"urlRewrite,omitempty" tf:"url_rewrite,omitempty"`

	// A list of weighted backend services to send traffic to when a route match
	// occurs. The weights determine the fraction of traffic that flows to their
	// corresponding backend service. If all traffic needs to go to a single backend
	// service, there must be one  weightedBackendService with weight set to a non 0
	// number. Once a backendService is identified and before forwarding the request to
	// the backend service, advanced routing actions like Url rewrites and header
	// transformations are applied depending on additional settings specified in this
	// HttpRouteAction.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	WeightedBackendServices []PathMatcherRouteRulesRouteActionWeightedBackendServicesParameters `json:"weightedBackendServices,omitempty" tf:"weighted_backend_services,omitempty"`
}

type PathMatcherRouteRulesRouteActionRequestMirrorPolicyInitParameters struct {

	// The default BackendService resource. Before
	// forwarding the request to backendService, the loadbalancer applies any relevant
	// headerActions specified as part of this backendServiceWeight.
	BackendService *string `json:"backendService,omitempty" tf:"backend_service,omitempty"`
}

type PathMatcherRouteRulesRouteActionRequestMirrorPolicyObservation struct {

	// The default BackendService resource. Before
	// forwarding the request to backendService, the loadbalancer applies any relevant
	// headerActions specified as part of this backendServiceWeight.
	BackendService *string `json:"backendService,omitempty" tf:"backend_service,omitempty"`
}

type PathMatcherRouteRulesRouteActionRequestMirrorPolicyParameters struct {

	// The default BackendService resource. Before
	// forwarding the request to backendService, the loadbalancer applies any relevant
	// headerActions specified as part of this backendServiceWeight.
	// +kubebuilder:validation:Optional
	BackendService *string `json:"backendService" tf:"backend_service,omitempty"`
}

type PathMatcherRouteRulesRouteActionRetryPolicyInitParameters struct {

	// Specifies the allowed number retries. This number must be > 0.
	NumRetries *float64 `json:"numRetries,omitempty" tf:"num_retries,omitempty"`

	// Specifies a non-zero timeout per retry attempt.
	// Structure is documented below.
	PerTryTimeout []RouteRulesRouteActionRetryPolicyPerTryTimeoutInitParameters `json:"perTryTimeout,omitempty" tf:"per_try_timeout,omitempty"`

	// Specifies one or more conditions when this retry rule applies. Valid values are:
	RetryConditions []*string `json:"retryConditions,omitempty" tf:"retry_conditions,omitempty"`
}

type PathMatcherRouteRulesRouteActionRetryPolicyObservation struct {

	// Specifies the allowed number retries. This number must be > 0.
	NumRetries *float64 `json:"numRetries,omitempty" tf:"num_retries,omitempty"`

	// Specifies a non-zero timeout per retry attempt.
	// Structure is documented below.
	PerTryTimeout []RouteRulesRouteActionRetryPolicyPerTryTimeoutObservation `json:"perTryTimeout,omitempty" tf:"per_try_timeout,omitempty"`

	// Specifies one or more conditions when this retry rule applies. Valid values are:
	RetryConditions []*string `json:"retryConditions,omitempty" tf:"retry_conditions,omitempty"`
}

type PathMatcherRouteRulesRouteActionRetryPolicyParameters struct {

	// Specifies the allowed number retries. This number must be > 0.
	// +kubebuilder:validation:Optional
	NumRetries *float64 `json:"numRetries" tf:"num_retries,omitempty"`

	// Specifies a non-zero timeout per retry attempt.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	PerTryTimeout []RouteRulesRouteActionRetryPolicyPerTryTimeoutParameters `json:"perTryTimeout,omitempty" tf:"per_try_timeout,omitempty"`

	// Specifies one or more conditions when this retry rule applies. Valid values are:
	// +kubebuilder:validation:Optional
	RetryConditions []*string `json:"retryConditions,omitempty" tf:"retry_conditions,omitempty"`
}

type PathMatcherRouteRulesRouteActionTimeoutInitParameters struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type PathMatcherRouteRulesRouteActionTimeoutObservation struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type PathMatcherRouteRulesRouteActionTimeoutParameters struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	// +kubebuilder:validation:Optional
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	// +kubebuilder:validation:Optional
	Seconds *string `json:"seconds" tf:"seconds,omitempty"`
}

type PathMatcherRouteRulesRouteActionURLRewriteInitParameters struct {

	// Prior to forwarding the request to the selected service, the request's host
	// header is replaced with contents of hostRewrite. The value must be between 1 and
	// 255 characters.
	HostRewrite *string `json:"hostRewrite,omitempty" tf:"host_rewrite,omitempty"`

	// Prior to forwarding the request to the selected backend service, the matching
	// portion of the request's path is replaced by pathPrefixRewrite. The value must
	// be between 1 and 1024 characters.
	PathPrefixRewrite *string `json:"pathPrefixRewrite,omitempty" tf:"path_prefix_rewrite,omitempty"`

	// Prior to forwarding the request to the selected origin, if the
	// request matched a pathTemplateMatch, the matching portion of the
	// request's path is replaced re-written using the pattern specified
	// by pathTemplateRewrite.
	// pathTemplateRewrite must be between 1 and 255 characters
	// (inclusive), must start with a '/', and must only use variables
	// captured by the route's pathTemplate matchers.
	// pathTemplateRewrite may only be used when all of a route's
	// MatchRules specify pathTemplate.
	// Only one of pathPrefixRewrite and pathTemplateRewrite may be
	// specified.
	PathTemplateRewrite *string `json:"pathTemplateRewrite,omitempty" tf:"path_template_rewrite,omitempty"`
}

type PathMatcherRouteRulesRouteActionURLRewriteObservation struct {

	// Prior to forwarding the request to the selected service, the request's host
	// header is replaced with contents of hostRewrite. The value must be between 1 and
	// 255 characters.
	HostRewrite *string `json:"hostRewrite,omitempty" tf:"host_rewrite,omitempty"`

	// Prior to forwarding the request to the selected backend service, the matching
	// portion of the request's path is replaced by pathPrefixRewrite. The value must
	// be between 1 and 1024 characters.
	PathPrefixRewrite *string `json:"pathPrefixRewrite,omitempty" tf:"path_prefix_rewrite,omitempty"`

	// Prior to forwarding the request to the selected origin, if the
	// request matched a pathTemplateMatch, the matching portion of the
	// request's path is replaced re-written using the pattern specified
	// by pathTemplateRewrite.
	// pathTemplateRewrite must be between 1 and 255 characters
	// (inclusive), must start with a '/', and must only use variables
	// captured by the route's pathTemplate matchers.
	// pathTemplateRewrite may only be used when all of a route's
	// MatchRules specify pathTemplate.
	// Only one of pathPrefixRewrite and pathTemplateRewrite may be
	// specified.
	PathTemplateRewrite *string `json:"pathTemplateRewrite,omitempty" tf:"path_template_rewrite,omitempty"`
}

type PathMatcherRouteRulesRouteActionURLRewriteParameters struct {

	// Prior to forwarding the request to the selected service, the request's host
	// header is replaced with contents of hostRewrite. The value must be between 1 and
	// 255 characters.
	// +kubebuilder:validation:Optional
	HostRewrite *string `json:"hostRewrite,omitempty" tf:"host_rewrite,omitempty"`

	// Prior to forwarding the request to the selected backend service, the matching
	// portion of the request's path is replaced by pathPrefixRewrite. The value must
	// be between 1 and 1024 characters.
	// +kubebuilder:validation:Optional
	PathPrefixRewrite *string `json:"pathPrefixRewrite,omitempty" tf:"path_prefix_rewrite,omitempty"`

	// Prior to forwarding the request to the selected origin, if the
	// request matched a pathTemplateMatch, the matching portion of the
	// request's path is replaced re-written using the pattern specified
	// by pathTemplateRewrite.
	// pathTemplateRewrite must be between 1 and 255 characters
	// (inclusive), must start with a '/', and must only use variables
	// captured by the route's pathTemplate matchers.
	// pathTemplateRewrite may only be used when all of a route's
	// MatchRules specify pathTemplate.
	// Only one of pathPrefixRewrite and pathTemplateRewrite may be
	// specified.
	// +kubebuilder:validation:Optional
	PathTemplateRewrite *string `json:"pathTemplateRewrite,omitempty" tf:"path_template_rewrite,omitempty"`
}

type PathMatcherRouteRulesRouteActionWeightedBackendServicesInitParameters struct {

	// The default BackendService resource. Before
	// forwarding the request to backendService, the loadbalancer applies any relevant
	// headerActions specified as part of this backendServiceWeight.
	BackendService *string `json:"backendService,omitempty" tf:"backend_service,omitempty"`

	// Specifies changes to request and response headers that need to take effect for
	// the selected backendService. headerAction specified here take effect before
	// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
	// Structure is documented below.
	HeaderAction []RouteRulesRouteActionWeightedBackendServicesHeaderActionInitParameters `json:"headerAction,omitempty" tf:"header_action,omitempty"`

	// Specifies the fraction of traffic sent to backendService, computed as weight /
	// (sum of all weightedBackendService weights in routeAction) . The selection of a
	// backend service is determined only for new traffic. Once a user's request has
	// been directed to a backendService, subsequent requests will be sent to the same
	// backendService as determined by the BackendService's session affinity policy.
	// The value must be between 0 and 1000
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type PathMatcherRouteRulesRouteActionWeightedBackendServicesObservation struct {

	// The default BackendService resource. Before
	// forwarding the request to backendService, the loadbalancer applies any relevant
	// headerActions specified as part of this backendServiceWeight.
	BackendService *string `json:"backendService,omitempty" tf:"backend_service,omitempty"`

	// Specifies changes to request and response headers that need to take effect for
	// the selected backendService. headerAction specified here take effect before
	// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
	// Structure is documented below.
	HeaderAction []RouteRulesRouteActionWeightedBackendServicesHeaderActionObservation `json:"headerAction,omitempty" tf:"header_action,omitempty"`

	// Specifies the fraction of traffic sent to backendService, computed as weight /
	// (sum of all weightedBackendService weights in routeAction) . The selection of a
	// backend service is determined only for new traffic. Once a user's request has
	// been directed to a backendService, subsequent requests will be sent to the same
	// backendService as determined by the BackendService's session affinity policy.
	// The value must be between 0 and 1000
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type PathMatcherRouteRulesRouteActionWeightedBackendServicesParameters struct {

	// The default BackendService resource. Before
	// forwarding the request to backendService, the loadbalancer applies any relevant
	// headerActions specified as part of this backendServiceWeight.
	// +kubebuilder:validation:Optional
	BackendService *string `json:"backendService" tf:"backend_service,omitempty"`

	// Specifies changes to request and response headers that need to take effect for
	// the selected backendService. headerAction specified here take effect before
	// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	HeaderAction []RouteRulesRouteActionWeightedBackendServicesHeaderActionParameters `json:"headerAction,omitempty" tf:"header_action,omitempty"`

	// Specifies the fraction of traffic sent to backendService, computed as weight /
	// (sum of all weightedBackendService weights in routeAction) . The selection of a
	// backend service is determined only for new traffic. Once a user's request has
	// been directed to a backendService, subsequent requests will be sent to the same
	// backendService as determined by the BackendService's session affinity policy.
	// The value must be between 0 and 1000
	// +kubebuilder:validation:Optional
	Weight *float64 `json:"weight" tf:"weight,omitempty"`
}

type PathMatcherRouteRulesURLRedirectInitParameters struct {

	// If set to true, the URL scheme in the redirected request is set to https.
	// If set to false, the URL scheme of the redirected request will remain the
	// same as that of the request. This must only be set for UrlMaps used in
	// TargetHttpProxys. Setting this true for TargetHttpsProxy is not
	// permitted. The default is set to false.
	HTTPSRedirect *bool `json:"httpsRedirect,omitempty" tf:"https_redirect,omitempty"`

	// The host that will be used in the redirect response instead of the one
	// that was supplied in the request. The value must be between 1 and 255
	// characters.
	HostRedirect *string `json:"hostRedirect,omitempty" tf:"host_redirect,omitempty"`

	// The path that will be used in the redirect response instead of the one
	// that was supplied in the request. pathRedirect cannot be supplied
	// together with prefixRedirect. Supply one alone or neither. If neither is
	// supplied, the path of the original request will be used for the redirect.
	// The value must be between 1 and 1024 characters.
	PathRedirect *string `json:"pathRedirect,omitempty" tf:"path_redirect,omitempty"`

	// The prefix that replaces the prefixMatch specified in the
	// HttpRouteRuleMatch, retaining the remaining portion of the URL before
	// redirecting the request. prefixRedirect cannot be supplied together with
	// pathRedirect. Supply one alone or neither. If neither is supplied, the
	// path of the original request will be used for the redirect. The value
	// must be between 1 and 1024 characters.
	PrefixRedirect *string `json:"prefixRedirect,omitempty" tf:"prefix_redirect,omitempty"`

	// The HTTP Status code to use for this RedirectAction. Supported values are:
	RedirectResponseCode *string `json:"redirectResponseCode,omitempty" tf:"redirect_response_code,omitempty"`

	// If set to true, any accompanying query portion of the original URL is
	// removed prior to redirecting the request. If set to false, the query
	// portion of the original URL is retained.
	// This field is required to ensure an empty block is not set. The normal default value is false.
	StripQuery *bool `json:"stripQuery,omitempty" tf:"strip_query,omitempty"`
}

type PathMatcherRouteRulesURLRedirectObservation struct {

	// If set to true, the URL scheme in the redirected request is set to https.
	// If set to false, the URL scheme of the redirected request will remain the
	// same as that of the request. This must only be set for UrlMaps used in
	// TargetHttpProxys. Setting this true for TargetHttpsProxy is not
	// permitted. The default is set to false.
	HTTPSRedirect *bool `json:"httpsRedirect,omitempty" tf:"https_redirect,omitempty"`

	// The host that will be used in the redirect response instead of the one
	// that was supplied in the request. The value must be between 1 and 255
	// characters.
	HostRedirect *string `json:"hostRedirect,omitempty" tf:"host_redirect,omitempty"`

	// The path that will be used in the redirect response instead of the one
	// that was supplied in the request. pathRedirect cannot be supplied
	// together with prefixRedirect. Supply one alone or neither. If neither is
	// supplied, the path of the original request will be used for the redirect.
	// The value must be between 1 and 1024 characters.
	PathRedirect *string `json:"pathRedirect,omitempty" tf:"path_redirect,omitempty"`

	// The prefix that replaces the prefixMatch specified in the
	// HttpRouteRuleMatch, retaining the remaining portion of the URL before
	// redirecting the request. prefixRedirect cannot be supplied together with
	// pathRedirect. Supply one alone or neither. If neither is supplied, the
	// path of the original request will be used for the redirect. The value
	// must be between 1 and 1024 characters.
	PrefixRedirect *string `json:"prefixRedirect,omitempty" tf:"prefix_redirect,omitempty"`

	// The HTTP Status code to use for this RedirectAction. Supported values are:
	RedirectResponseCode *string `json:"redirectResponseCode,omitempty" tf:"redirect_response_code,omitempty"`

	// If set to true, any accompanying query portion of the original URL is
	// removed prior to redirecting the request. If set to false, the query
	// portion of the original URL is retained.
	// This field is required to ensure an empty block is not set. The normal default value is false.
	StripQuery *bool `json:"stripQuery,omitempty" tf:"strip_query,omitempty"`
}

type PathMatcherRouteRulesURLRedirectParameters struct {

	// If set to true, the URL scheme in the redirected request is set to https.
	// If set to false, the URL scheme of the redirected request will remain the
	// same as that of the request. This must only be set for UrlMaps used in
	// TargetHttpProxys. Setting this true for TargetHttpsProxy is not
	// permitted. The default is set to false.
	// +kubebuilder:validation:Optional
	HTTPSRedirect *bool `json:"httpsRedirect,omitempty" tf:"https_redirect,omitempty"`

	// The host that will be used in the redirect response instead of the one
	// that was supplied in the request. The value must be between 1 and 255
	// characters.
	// +kubebuilder:validation:Optional
	HostRedirect *string `json:"hostRedirect,omitempty" tf:"host_redirect,omitempty"`

	// The path that will be used in the redirect response instead of the one
	// that was supplied in the request. pathRedirect cannot be supplied
	// together with prefixRedirect. Supply one alone or neither. If neither is
	// supplied, the path of the original request will be used for the redirect.
	// The value must be between 1 and 1024 characters.
	// +kubebuilder:validation:Optional
	PathRedirect *string `json:"pathRedirect,omitempty" tf:"path_redirect,omitempty"`

	// The prefix that replaces the prefixMatch specified in the
	// HttpRouteRuleMatch, retaining the remaining portion of the URL before
	// redirecting the request. prefixRedirect cannot be supplied together with
	// pathRedirect. Supply one alone or neither. If neither is supplied, the
	// path of the original request will be used for the redirect. The value
	// must be between 1 and 1024 characters.
	// +kubebuilder:validation:Optional
	PrefixRedirect *string `json:"prefixRedirect,omitempty" tf:"prefix_redirect,omitempty"`

	// The HTTP Status code to use for this RedirectAction. Supported values are:
	// +kubebuilder:validation:Optional
	RedirectResponseCode *string `json:"redirectResponseCode,omitempty" tf:"redirect_response_code,omitempty"`

	// If set to true, any accompanying query portion of the original URL is
	// removed prior to redirecting the request. If set to false, the query
	// portion of the original URL is retained.
	// This field is required to ensure an empty block is not set. The normal default value is false.
	// +kubebuilder:validation:Optional
	StripQuery *bool `json:"stripQuery,omitempty" tf:"strip_query,omitempty"`
}

type PathRuleRouteActionCorsPolicyInitParameters struct {

	// In response to a preflight request, setting this to true indicates that the
	// actual request can include user credentials. This translates to the Access-
	// Control-Allow-Credentials header. Defaults to false.
	AllowCredentials *bool `json:"allowCredentials,omitempty" tf:"allow_credentials,omitempty"`

	// Specifies the content for the Access-Control-Allow-Headers header.
	AllowHeaders []*string `json:"allowHeaders,omitempty" tf:"allow_headers,omitempty"`

	// Specifies the content for the Access-Control-Allow-Methods header.
	AllowMethods []*string `json:"allowMethods,omitempty" tf:"allow_methods,omitempty"`

	// Specifies the regular expression patterns that match allowed origins. For
	// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
	// An origin is allowed if it matches either allow_origins or allow_origin_regex.
	AllowOriginRegexes []*string `json:"allowOriginRegexes,omitempty" tf:"allow_origin_regexes,omitempty"`

	// Specifies the list of origins that will be allowed to do CORS requests. An
	// origin is allowed if it matches either allow_origins or allow_origin_regex.
	AllowOrigins []*string `json:"allowOrigins,omitempty" tf:"allow_origins,omitempty"`

	// If true, specifies the CORS policy is disabled.
	Disabled *bool `json:"disabled,omitempty" tf:"disabled,omitempty"`

	// Specifies the content for the Access-Control-Expose-Headers header.
	ExposeHeaders []*string `json:"exposeHeaders,omitempty" tf:"expose_headers,omitempty"`

	// Specifies how long the results of a preflight request can be cached. This
	// translates to the content for the Access-Control-Max-Age header.
	MaxAge *float64 `json:"maxAge,omitempty" tf:"max_age,omitempty"`
}

type PathRuleRouteActionCorsPolicyObservation struct {

	// In response to a preflight request, setting this to true indicates that the
	// actual request can include user credentials. This translates to the Access-
	// Control-Allow-Credentials header. Defaults to false.
	AllowCredentials *bool `json:"allowCredentials,omitempty" tf:"allow_credentials,omitempty"`

	// Specifies the content for the Access-Control-Allow-Headers header.
	AllowHeaders []*string `json:"allowHeaders,omitempty" tf:"allow_headers,omitempty"`

	// Specifies the content for the Access-Control-Allow-Methods header.
	AllowMethods []*string `json:"allowMethods,omitempty" tf:"allow_methods,omitempty"`

	// Specifies the regular expression patterns that match allowed origins. For
	// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
	// An origin is allowed if it matches either allow_origins or allow_origin_regex.
	AllowOriginRegexes []*string `json:"allowOriginRegexes,omitempty" tf:"allow_origin_regexes,omitempty"`

	// Specifies the list of origins that will be allowed to do CORS requests. An
	// origin is allowed if it matches either allow_origins or allow_origin_regex.
	AllowOrigins []*string `json:"allowOrigins,omitempty" tf:"allow_origins,omitempty"`

	// If true, specifies the CORS policy is disabled.
	Disabled *bool `json:"disabled,omitempty" tf:"disabled,omitempty"`

	// Specifies the content for the Access-Control-Expose-Headers header.
	ExposeHeaders []*string `json:"exposeHeaders,omitempty" tf:"expose_headers,omitempty"`

	// Specifies how long the results of a preflight request can be cached. This
	// translates to the content for the Access-Control-Max-Age header.
	MaxAge *float64 `json:"maxAge,omitempty" tf:"max_age,omitempty"`
}

type PathRuleRouteActionCorsPolicyParameters struct {

	// In response to a preflight request, setting this to true indicates that the
	// actual request can include user credentials. This translates to the Access-
	// Control-Allow-Credentials header. Defaults to false.
	// +kubebuilder:validation:Optional
	AllowCredentials *bool `json:"allowCredentials,omitempty" tf:"allow_credentials,omitempty"`

	// Specifies the content for the Access-Control-Allow-Headers header.
	// +kubebuilder:validation:Optional
	AllowHeaders []*string `json:"allowHeaders,omitempty" tf:"allow_headers,omitempty"`

	// Specifies the content for the Access-Control-Allow-Methods header.
	// +kubebuilder:validation:Optional
	AllowMethods []*string `json:"allowMethods,omitempty" tf:"allow_methods,omitempty"`

	// Specifies the regular expression patterns that match allowed origins. For
	// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
	// An origin is allowed if it matches either allow_origins or allow_origin_regex.
	// +kubebuilder:validation:Optional
	AllowOriginRegexes []*string `json:"allowOriginRegexes,omitempty" tf:"allow_origin_regexes,omitempty"`

	// Specifies the list of origins that will be allowed to do CORS requests. An
	// origin is allowed if it matches either allow_origins or allow_origin_regex.
	// +kubebuilder:validation:Optional
	AllowOrigins []*string `json:"allowOrigins,omitempty" tf:"allow_origins,omitempty"`

	// If true, specifies the CORS policy is disabled.
	// +kubebuilder:validation:Optional
	Disabled *bool `json:"disabled" tf:"disabled,omitempty"`

	// Specifies the content for the Access-Control-Expose-Headers header.
	// +kubebuilder:validation:Optional
	ExposeHeaders []*string `json:"exposeHeaders,omitempty" tf:"expose_headers,omitempty"`

	// Specifies how long the results of a preflight request can be cached. This
	// translates to the content for the Access-Control-Max-Age header.
	// +kubebuilder:validation:Optional
	MaxAge *float64 `json:"maxAge,omitempty" tf:"max_age,omitempty"`
}

type PathRuleRouteActionFaultInjectionPolicyAbortInitParameters struct {

	// The HTTP status code used to abort the request. The value must be between 200
	// and 599 inclusive.
	HTTPStatus *float64 `json:"httpStatus,omitempty" tf:"http_status,omitempty"`

	// The percentage of traffic (connections/operations/requests) on which delay will
	// be introduced as part of fault injection. The value must be between 0.0 and
	// 100.0 inclusive.
	Percentage *float64 `json:"percentage,omitempty" tf:"percentage,omitempty"`
}

type PathRuleRouteActionFaultInjectionPolicyAbortObservation struct {

	// The HTTP status code used to abort the request. The value must be between 200
	// and 599 inclusive.
	HTTPStatus *float64 `json:"httpStatus,omitempty" tf:"http_status,omitempty"`

	// The percentage of traffic (connections/operations/requests) on which delay will
	// be introduced as part of fault injection. The value must be between 0.0 and
	// 100.0 inclusive.
	Percentage *float64 `json:"percentage,omitempty" tf:"percentage,omitempty"`
}

type PathRuleRouteActionFaultInjectionPolicyAbortParameters struct {

	// The HTTP status code used to abort the request. The value must be between 200
	// and 599 inclusive.
	// +kubebuilder:validation:Optional
	HTTPStatus *float64 `json:"httpStatus" tf:"http_status,omitempty"`

	// The percentage of traffic (connections/operations/requests) on which delay will
	// be introduced as part of fault injection. The value must be between 0.0 and
	// 100.0 inclusive.
	// +kubebuilder:validation:Optional
	Percentage *float64 `json:"percentage" tf:"percentage,omitempty"`
}

type PathRuleRouteActionFaultInjectionPolicyDelayInitParameters struct {

	// Specifies the value of the fixed delay interval.
	// Structure is documented below.
	FixedDelay []RouteActionFaultInjectionPolicyDelayFixedDelayInitParameters `json:"fixedDelay,omitempty" tf:"fixed_delay,omitempty"`

	// The percentage of traffic (connections/operations/requests) on which delay will
	// be introduced as part of fault injection. The value must be between 0.0 and
	// 100.0 inclusive.
	Percentage *float64 `json:"percentage,omitempty" tf:"percentage,omitempty"`
}

type PathRuleRouteActionFaultInjectionPolicyDelayObservation struct {

	// Specifies the value of the fixed delay interval.
	// Structure is documented below.
	FixedDelay []RouteActionFaultInjectionPolicyDelayFixedDelayObservation `json:"fixedDelay,omitempty" tf:"fixed_delay,omitempty"`

	// The percentage of traffic (connections/operations/requests) on which delay will
	// be introduced as part of fault injection. The value must be between 0.0 and
	// 100.0 inclusive.
	Percentage *float64 `json:"percentage,omitempty" tf:"percentage,omitempty"`
}

type PathRuleRouteActionFaultInjectionPolicyDelayParameters struct {

	// Specifies the value of the fixed delay interval.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	FixedDelay []RouteActionFaultInjectionPolicyDelayFixedDelayParameters `json:"fixedDelay" tf:"fixed_delay,omitempty"`

	// The percentage of traffic (connections/operations/requests) on which delay will
	// be introduced as part of fault injection. The value must be between 0.0 and
	// 100.0 inclusive.
	// +kubebuilder:validation:Optional
	Percentage *float64 `json:"percentage" tf:"percentage,omitempty"`
}

type PathRuleRouteActionFaultInjectionPolicyInitParameters struct {

	// The specification for how client requests are aborted as part of fault
	// injection.
	// Structure is documented below.
	Abort []PathRuleRouteActionFaultInjectionPolicyAbortInitParameters `json:"abort,omitempty" tf:"abort,omitempty"`

	// The specification for how client requests are delayed as part of fault
	// injection, before being sent to a backend service.
	// Structure is documented below.
	Delay []PathRuleRouteActionFaultInjectionPolicyDelayInitParameters `json:"delay,omitempty" tf:"delay,omitempty"`
}

type PathRuleRouteActionFaultInjectionPolicyObservation struct {

	// The specification for how client requests are aborted as part of fault
	// injection.
	// Structure is documented below.
	Abort []PathRuleRouteActionFaultInjectionPolicyAbortObservation `json:"abort,omitempty" tf:"abort,omitempty"`

	// The specification for how client requests are delayed as part of fault
	// injection, before being sent to a backend service.
	// Structure is documented below.
	Delay []PathRuleRouteActionFaultInjectionPolicyDelayObservation `json:"delay,omitempty" tf:"delay,omitempty"`
}

type PathRuleRouteActionFaultInjectionPolicyParameters struct {

	// The specification for how client requests are aborted as part of fault
	// injection.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Abort []PathRuleRouteActionFaultInjectionPolicyAbortParameters `json:"abort,omitempty" tf:"abort,omitempty"`

	// The specification for how client requests are delayed as part of fault
	// injection, before being sent to a backend service.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Delay []PathRuleRouteActionFaultInjectionPolicyDelayParameters `json:"delay,omitempty" tf:"delay,omitempty"`
}

type PathRuleRouteActionInitParameters struct {

	// The specification for allowing client side cross-origin requests. Please see W3C
	// Recommendation for Cross Origin Resource Sharing
	// Structure is documented below.
	CorsPolicy []PathRuleRouteActionCorsPolicyInitParameters `json:"corsPolicy,omitempty" tf:"cors_policy,omitempty"`

	// The specification for fault injection introduced into traffic to test the
	// resiliency of clients to backend service failure. As part of fault injection,
	// when clients send requests to a backend service, delays can be introduced by
	// Loadbalancer on a percentage of requests before sending those request to the
	// backend service. Similarly requests from clients can be aborted by the
	// Loadbalancer for a percentage of requests. timeout and retry_policy will be
	// ignored by clients that are configured with a fault_injection_policy.
	// Structure is documented below.
	FaultInjectionPolicy []PathRuleRouteActionFaultInjectionPolicyInitParameters `json:"faultInjectionPolicy,omitempty" tf:"fault_injection_policy,omitempty"`

	// Specifies the policy on how requests intended for the route's backends are
	// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
	// responses from the shadow service. Prior to sending traffic to the shadow
	// service, the host / authority header is suffixed with -shadow.
	// Structure is documented below.
	RequestMirrorPolicy []PathRuleRouteActionRequestMirrorPolicyInitParameters `json:"requestMirrorPolicy,omitempty" tf:"request_mirror_policy,omitempty"`

	// Specifies the retry policy associated with this route.
	// Structure is documented below.
	RetryPolicy []PathRuleRouteActionRetryPolicyInitParameters `json:"retryPolicy,omitempty" tf:"retry_policy,omitempty"`

	// Specifies the timeout for the selected route. Timeout is computed from the time
	// the request is has been fully processed (i.e. end-of-stream) up until the
	// response has been completely processed. Timeout includes all retries. If not
	// specified, the default value is 15 seconds.
	// Structure is documented below.
	Timeout []PathRuleRouteActionTimeoutInitParameters `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// The spec to modify the URL of the request, prior to forwarding the request to
	// the matched service
	// Structure is documented below.
	URLRewrite []PathRuleRouteActionURLRewriteInitParameters `json:"urlRewrite,omitempty" tf:"url_rewrite,omitempty"`

	// A list of weighted backend services to send traffic to when a route match
	// occurs. The weights determine the fraction of traffic that flows to their
	// corresponding backend service. If all traffic needs to go to a single backend
	// service, there must be one  weightedBackendService with weight set to a non 0
	// number. Once a backendService is identified and before forwarding the request to
	// the backend service, advanced routing actions like Url rewrites and header
	// transformations are applied depending on additional settings specified in this
	// HttpRouteAction.
	// Structure is documented below.
	WeightedBackendServices []PathRuleRouteActionWeightedBackendServicesInitParameters `json:"weightedBackendServices,omitempty" tf:"weighted_backend_services,omitempty"`
}

type PathRuleRouteActionObservation struct {

	// The specification for allowing client side cross-origin requests. Please see W3C
	// Recommendation for Cross Origin Resource Sharing
	// Structure is documented below.
	CorsPolicy []PathRuleRouteActionCorsPolicyObservation `json:"corsPolicy,omitempty" tf:"cors_policy,omitempty"`

	// The specification for fault injection introduced into traffic to test the
	// resiliency of clients to backend service failure. As part of fault injection,
	// when clients send requests to a backend service, delays can be introduced by
	// Loadbalancer on a percentage of requests before sending those request to the
	// backend service. Similarly requests from clients can be aborted by the
	// Loadbalancer for a percentage of requests. timeout and retry_policy will be
	// ignored by clients that are configured with a fault_injection_policy.
	// Structure is documented below.
	FaultInjectionPolicy []PathRuleRouteActionFaultInjectionPolicyObservation `json:"faultInjectionPolicy,omitempty" tf:"fault_injection_policy,omitempty"`

	// Specifies the policy on how requests intended for the route's backends are
	// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
	// responses from the shadow service. Prior to sending traffic to the shadow
	// service, the host / authority header is suffixed with -shadow.
	// Structure is documented below.
	RequestMirrorPolicy []PathRuleRouteActionRequestMirrorPolicyObservation `json:"requestMirrorPolicy,omitempty" tf:"request_mirror_policy,omitempty"`

	// Specifies the retry policy associated with this route.
	// Structure is documented below.
	RetryPolicy []PathRuleRouteActionRetryPolicyObservation `json:"retryPolicy,omitempty" tf:"retry_policy,omitempty"`

	// Specifies the timeout for the selected route. Timeout is computed from the time
	// the request is has been fully processed (i.e. end-of-stream) up until the
	// response has been completely processed. Timeout includes all retries. If not
	// specified, the default value is 15 seconds.
	// Structure is documented below.
	Timeout []PathRuleRouteActionTimeoutObservation `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// The spec to modify the URL of the request, prior to forwarding the request to
	// the matched service
	// Structure is documented below.
	URLRewrite []PathRuleRouteActionURLRewriteObservation `json:"urlRewrite,omitempty" tf:"url_rewrite,omitempty"`

	// A list of weighted backend services to send traffic to when a route match
	// occurs. The weights determine the fraction of traffic that flows to their
	// corresponding backend service. If all traffic needs to go to a single backend
	// service, there must be one  weightedBackendService with weight set to a non 0
	// number. Once a backendService is identified and before forwarding the request to
	// the backend service, advanced routing actions like Url rewrites and header
	// transformations are applied depending on additional settings specified in this
	// HttpRouteAction.
	// Structure is documented below.
	WeightedBackendServices []PathRuleRouteActionWeightedBackendServicesObservation `json:"weightedBackendServices,omitempty" tf:"weighted_backend_services,omitempty"`
}

type PathRuleRouteActionParameters struct {

	// The specification for allowing client side cross-origin requests. Please see W3C
	// Recommendation for Cross Origin Resource Sharing
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	CorsPolicy []PathRuleRouteActionCorsPolicyParameters `json:"corsPolicy,omitempty" tf:"cors_policy,omitempty"`

	// The specification for fault injection introduced into traffic to test the
	// resiliency of clients to backend service failure. As part of fault injection,
	// when clients send requests to a backend service, delays can be introduced by
	// Loadbalancer on a percentage of requests before sending those request to the
	// backend service. Similarly requests from clients can be aborted by the
	// Loadbalancer for a percentage of requests. timeout and retry_policy will be
	// ignored by clients that are configured with a fault_injection_policy.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	FaultInjectionPolicy []PathRuleRouteActionFaultInjectionPolicyParameters `json:"faultInjectionPolicy,omitempty" tf:"fault_injection_policy,omitempty"`

	// Specifies the policy on how requests intended for the route's backends are
	// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
	// responses from the shadow service. Prior to sending traffic to the shadow
	// service, the host / authority header is suffixed with -shadow.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	RequestMirrorPolicy []PathRuleRouteActionRequestMirrorPolicyParameters `json:"requestMirrorPolicy,omitempty" tf:"request_mirror_policy,omitempty"`

	// Specifies the retry policy associated with this route.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	RetryPolicy []PathRuleRouteActionRetryPolicyParameters `json:"retryPolicy,omitempty" tf:"retry_policy,omitempty"`

	// Specifies the timeout for the selected route. Timeout is computed from the time
	// the request is has been fully processed (i.e. end-of-stream) up until the
	// response has been completely processed. Timeout includes all retries. If not
	// specified, the default value is 15 seconds.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Timeout []PathRuleRouteActionTimeoutParameters `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// The spec to modify the URL of the request, prior to forwarding the request to
	// the matched service
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	URLRewrite []PathRuleRouteActionURLRewriteParameters `json:"urlRewrite,omitempty" tf:"url_rewrite,omitempty"`

	// A list of weighted backend services to send traffic to when a route match
	// occurs. The weights determine the fraction of traffic that flows to their
	// corresponding backend service. If all traffic needs to go to a single backend
	// service, there must be one  weightedBackendService with weight set to a non 0
	// number. Once a backendService is identified and before forwarding the request to
	// the backend service, advanced routing actions like Url rewrites and header
	// transformations are applied depending on additional settings specified in this
	// HttpRouteAction.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	WeightedBackendServices []PathRuleRouteActionWeightedBackendServicesParameters `json:"weightedBackendServices,omitempty" tf:"weighted_backend_services,omitempty"`
}

type PathRuleRouteActionRequestMirrorPolicyInitParameters struct {

	// The default BackendService resource. Before
	// forwarding the request to backendService, the loadbalancer applies any relevant
	// headerActions specified as part of this backendServiceWeight.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.BackendService
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	BackendService *string `json:"backendService,omitempty" tf:"backend_service,omitempty"`

	// Reference to a BackendService in compute to populate backendService.
	// +kubebuilder:validation:Optional
	BackendServiceRef *v1.Reference `json:"backendServiceRef,omitempty" tf:"-"`

	// Selector for a BackendService in compute to populate backendService.
	// +kubebuilder:validation:Optional
	BackendServiceSelector *v1.Selector `json:"backendServiceSelector,omitempty" tf:"-"`
}

type PathRuleRouteActionRequestMirrorPolicyObservation struct {

	// The default BackendService resource. Before
	// forwarding the request to backendService, the loadbalancer applies any relevant
	// headerActions specified as part of this backendServiceWeight.
	BackendService *string `json:"backendService,omitempty" tf:"backend_service,omitempty"`
}

type PathRuleRouteActionRequestMirrorPolicyParameters struct {

	// The default BackendService resource. Before
	// forwarding the request to backendService, the loadbalancer applies any relevant
	// headerActions specified as part of this backendServiceWeight.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.BackendService
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	BackendService *string `json:"backendService,omitempty" tf:"backend_service,omitempty"`

	// Reference to a BackendService in compute to populate backendService.
	// +kubebuilder:validation:Optional
	BackendServiceRef *v1.Reference `json:"backendServiceRef,omitempty" tf:"-"`

	// Selector for a BackendService in compute to populate backendService.
	// +kubebuilder:validation:Optional
	BackendServiceSelector *v1.Selector `json:"backendServiceSelector,omitempty" tf:"-"`
}

type PathRuleRouteActionRetryPolicyInitParameters struct {

	// Specifies the allowed number retries. This number must be > 0.
	NumRetries *float64 `json:"numRetries,omitempty" tf:"num_retries,omitempty"`

	// Specifies a non-zero timeout per retry attempt.
	// Structure is documented below.
	PerTryTimeout []PathRuleRouteActionRetryPolicyPerTryTimeoutInitParameters `json:"perTryTimeout,omitempty" tf:"per_try_timeout,omitempty"`

	// Specifies one or more conditions when this retry rule applies. Valid values are:
	RetryConditions []*string `json:"retryConditions,omitempty" tf:"retry_conditions,omitempty"`
}

type PathRuleRouteActionRetryPolicyObservation struct {

	// Specifies the allowed number retries. This number must be > 0.
	NumRetries *float64 `json:"numRetries,omitempty" tf:"num_retries,omitempty"`

	// Specifies a non-zero timeout per retry attempt.
	// Structure is documented below.
	PerTryTimeout []PathRuleRouteActionRetryPolicyPerTryTimeoutObservation `json:"perTryTimeout,omitempty" tf:"per_try_timeout,omitempty"`

	// Specifies one or more conditions when this retry rule applies. Valid values are:
	RetryConditions []*string `json:"retryConditions,omitempty" tf:"retry_conditions,omitempty"`
}

type PathRuleRouteActionRetryPolicyParameters struct {

	// Specifies the allowed number retries. This number must be > 0.
	// +kubebuilder:validation:Optional
	NumRetries *float64 `json:"numRetries,omitempty" tf:"num_retries,omitempty"`

	// Specifies a non-zero timeout per retry attempt.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	PerTryTimeout []PathRuleRouteActionRetryPolicyPerTryTimeoutParameters `json:"perTryTimeout,omitempty" tf:"per_try_timeout,omitempty"`

	// Specifies one or more conditions when this retry rule applies. Valid values are:
	// +kubebuilder:validation:Optional
	RetryConditions []*string `json:"retryConditions,omitempty" tf:"retry_conditions,omitempty"`
}

type PathRuleRouteActionRetryPolicyPerTryTimeoutInitParameters struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type PathRuleRouteActionRetryPolicyPerTryTimeoutObservation struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type PathRuleRouteActionRetryPolicyPerTryTimeoutParameters struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	// +kubebuilder:validation:Optional
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	// +kubebuilder:validation:Optional
	Seconds *string `json:"seconds" tf:"seconds,omitempty"`
}

type PathRuleRouteActionTimeoutInitParameters struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type PathRuleRouteActionTimeoutObservation struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type PathRuleRouteActionTimeoutParameters struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	// +kubebuilder:validation:Optional
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	// +kubebuilder:validation:Optional
	Seconds *string `json:"seconds" tf:"seconds,omitempty"`
}

type PathRuleRouteActionURLRewriteInitParameters struct {

	// Prior to forwarding the request to the selected service, the request's host
	// header is replaced with contents of hostRewrite. The value must be between 1 and
	// 255 characters.
	HostRewrite *string `json:"hostRewrite,omitempty" tf:"host_rewrite,omitempty"`

	// Prior to forwarding the request to the selected backend service, the matching
	// portion of the request's path is replaced by pathPrefixRewrite. The value must
	// be between 1 and 1024 characters.
	PathPrefixRewrite *string `json:"pathPrefixRewrite,omitempty" tf:"path_prefix_rewrite,omitempty"`
}

type PathRuleRouteActionURLRewriteObservation struct {

	// Prior to forwarding the request to the selected service, the request's host
	// header is replaced with contents of hostRewrite. The value must be between 1 and
	// 255 characters.
	HostRewrite *string `json:"hostRewrite,omitempty" tf:"host_rewrite,omitempty"`

	// Prior to forwarding the request to the selected backend service, the matching
	// portion of the request's path is replaced by pathPrefixRewrite. The value must
	// be between 1 and 1024 characters.
	PathPrefixRewrite *string `json:"pathPrefixRewrite,omitempty" tf:"path_prefix_rewrite,omitempty"`
}

type PathRuleRouteActionURLRewriteParameters struct {

	// Prior to forwarding the request to the selected service, the request's host
	// header is replaced with contents of hostRewrite. The value must be between 1 and
	// 255 characters.
	// +kubebuilder:validation:Optional
	HostRewrite *string `json:"hostRewrite,omitempty" tf:"host_rewrite,omitempty"`

	// Prior to forwarding the request to the selected backend service, the matching
	// portion of the request's path is replaced by pathPrefixRewrite. The value must
	// be between 1 and 1024 characters.
	// +kubebuilder:validation:Optional
	PathPrefixRewrite *string `json:"pathPrefixRewrite,omitempty" tf:"path_prefix_rewrite,omitempty"`
}

type PathRuleRouteActionWeightedBackendServicesHeaderActionInitParameters struct {

	// Headers to add to a matching request prior to forwarding the request to the
	// backendService.
	// Structure is documented below.
	RequestHeadersToAdd []RouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddInitParameters `json:"requestHeadersToAdd,omitempty" tf:"request_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the request
	// prior to forwarding the request to the backendService.
	RequestHeadersToRemove []*string `json:"requestHeadersToRemove,omitempty" tf:"request_headers_to_remove,omitempty"`

	// Headers to add the response prior to sending the response back to the client.
	// Structure is documented below.
	ResponseHeadersToAdd []RouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddInitParameters `json:"responseHeadersToAdd,omitempty" tf:"response_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the response
	// prior to sending the response back to the client.
	ResponseHeadersToRemove []*string `json:"responseHeadersToRemove,omitempty" tf:"response_headers_to_remove,omitempty"`
}

type PathRuleRouteActionWeightedBackendServicesHeaderActionObservation struct {

	// Headers to add to a matching request prior to forwarding the request to the
	// backendService.
	// Structure is documented below.
	RequestHeadersToAdd []RouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddObservation `json:"requestHeadersToAdd,omitempty" tf:"request_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the request
	// prior to forwarding the request to the backendService.
	RequestHeadersToRemove []*string `json:"requestHeadersToRemove,omitempty" tf:"request_headers_to_remove,omitempty"`

	// Headers to add the response prior to sending the response back to the client.
	// Structure is documented below.
	ResponseHeadersToAdd []RouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddObservation `json:"responseHeadersToAdd,omitempty" tf:"response_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the response
	// prior to sending the response back to the client.
	ResponseHeadersToRemove []*string `json:"responseHeadersToRemove,omitempty" tf:"response_headers_to_remove,omitempty"`
}

type PathRuleRouteActionWeightedBackendServicesHeaderActionParameters struct {

	// Headers to add to a matching request prior to forwarding the request to the
	// backendService.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	RequestHeadersToAdd []RouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddParameters `json:"requestHeadersToAdd,omitempty" tf:"request_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the request
	// prior to forwarding the request to the backendService.
	// +kubebuilder:validation:Optional
	RequestHeadersToRemove []*string `json:"requestHeadersToRemove,omitempty" tf:"request_headers_to_remove,omitempty"`

	// Headers to add the response prior to sending the response back to the client.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	ResponseHeadersToAdd []RouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddParameters `json:"responseHeadersToAdd,omitempty" tf:"response_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the response
	// prior to sending the response back to the client.
	// +kubebuilder:validation:Optional
	ResponseHeadersToRemove []*string `json:"responseHeadersToRemove,omitempty" tf:"response_headers_to_remove,omitempty"`
}

type PathRuleRouteActionWeightedBackendServicesInitParameters struct {

	// The default BackendService resource. Before
	// forwarding the request to backendService, the loadbalancer applies any relevant
	// headerActions specified as part of this backendServiceWeight.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.BackendService
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	BackendService *string `json:"backendService,omitempty" tf:"backend_service,omitempty"`

	// Reference to a BackendService in compute to populate backendService.
	// +kubebuilder:validation:Optional
	BackendServiceRef *v1.Reference `json:"backendServiceRef,omitempty" tf:"-"`

	// Selector for a BackendService in compute to populate backendService.
	// +kubebuilder:validation:Optional
	BackendServiceSelector *v1.Selector `json:"backendServiceSelector,omitempty" tf:"-"`

	// Specifies changes to request and response headers that need to take effect for
	// the selected backendService. headerAction specified here take effect before
	// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
	// Structure is documented below.
	HeaderAction []PathRuleRouteActionWeightedBackendServicesHeaderActionInitParameters `json:"headerAction,omitempty" tf:"header_action,omitempty"`

	// Specifies the fraction of traffic sent to backendService, computed as weight /
	// (sum of all weightedBackendService weights in routeAction) . The selection of a
	// backend service is determined only for new traffic. Once a user's request has
	// been directed to a backendService, subsequent requests will be sent to the same
	// backendService as determined by the BackendService's session affinity policy.
	// The value must be between 0 and 1000
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type PathRuleRouteActionWeightedBackendServicesObservation struct {

	// The default BackendService resource. Before
	// forwarding the request to backendService, the loadbalancer applies any relevant
	// headerActions specified as part of this backendServiceWeight.
	BackendService *string `json:"backendService,omitempty" tf:"backend_service,omitempty"`

	// Specifies changes to request and response headers that need to take effect for
	// the selected backendService. headerAction specified here take effect before
	// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
	// Structure is documented below.
	HeaderAction []PathRuleRouteActionWeightedBackendServicesHeaderActionObservation `json:"headerAction,omitempty" tf:"header_action,omitempty"`

	// Specifies the fraction of traffic sent to backendService, computed as weight /
	// (sum of all weightedBackendService weights in routeAction) . The selection of a
	// backend service is determined only for new traffic. Once a user's request has
	// been directed to a backendService, subsequent requests will be sent to the same
	// backendService as determined by the BackendService's session affinity policy.
	// The value must be between 0 and 1000
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type PathRuleRouteActionWeightedBackendServicesParameters struct {

	// The default BackendService resource. Before
	// forwarding the request to backendService, the loadbalancer applies any relevant
	// headerActions specified as part of this backendServiceWeight.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.BackendService
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	BackendService *string `json:"backendService,omitempty" tf:"backend_service,omitempty"`

	// Reference to a BackendService in compute to populate backendService.
	// +kubebuilder:validation:Optional
	BackendServiceRef *v1.Reference `json:"backendServiceRef,omitempty" tf:"-"`

	// Selector for a BackendService in compute to populate backendService.
	// +kubebuilder:validation:Optional
	BackendServiceSelector *v1.Selector `json:"backendServiceSelector,omitempty" tf:"-"`

	// Specifies changes to request and response headers that need to take effect for
	// the selected backendService. headerAction specified here take effect before
	// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	HeaderAction []PathRuleRouteActionWeightedBackendServicesHeaderActionParameters `json:"headerAction,omitempty" tf:"header_action,omitempty"`

	// Specifies the fraction of traffic sent to backendService, computed as weight /
	// (sum of all weightedBackendService weights in routeAction) . The selection of a
	// backend service is determined only for new traffic. Once a user's request has
	// been directed to a backendService, subsequent requests will be sent to the same
	// backendService as determined by the BackendService's session affinity policy.
	// The value must be between 0 and 1000
	// +kubebuilder:validation:Optional
	Weight *float64 `json:"weight" tf:"weight,omitempty"`
}

type PathRuleURLRedirectInitParameters struct {

	// If set to true, the URL scheme in the redirected request is set to https.
	// If set to false, the URL scheme of the redirected request will remain the
	// same as that of the request. This must only be set for UrlMaps used in
	// TargetHttpProxys. Setting this true for TargetHttpsProxy is not
	// permitted. The default is set to false.
	HTTPSRedirect *bool `json:"httpsRedirect,omitempty" tf:"https_redirect,omitempty"`

	// The host that will be used in the redirect response instead of the one
	// that was supplied in the request. The value must be between 1 and 255
	// characters.
	HostRedirect *string `json:"hostRedirect,omitempty" tf:"host_redirect,omitempty"`

	// The path that will be used in the redirect response instead of the one
	// that was supplied in the request. pathRedirect cannot be supplied
	// together with prefixRedirect. Supply one alone or neither. If neither is
	// supplied, the path of the original request will be used for the redirect.
	// The value must be between 1 and 1024 characters.
	PathRedirect *string `json:"pathRedirect,omitempty" tf:"path_redirect,omitempty"`

	// The prefix that replaces the prefixMatch specified in the
	// HttpRouteRuleMatch, retaining the remaining portion of the URL before
	// redirecting the request. prefixRedirect cannot be supplied together with
	// pathRedirect. Supply one alone or neither. If neither is supplied, the
	// path of the original request will be used for the redirect. The value
	// must be between 1 and 1024 characters.
	PrefixRedirect *string `json:"prefixRedirect,omitempty" tf:"prefix_redirect,omitempty"`

	// The HTTP Status code to use for this RedirectAction. Supported values are:
	RedirectResponseCode *string `json:"redirectResponseCode,omitempty" tf:"redirect_response_code,omitempty"`

	// If set to true, any accompanying query portion of the original URL is
	// removed prior to redirecting the request. If set to false, the query
	// portion of the original URL is retained.
	// This field is required to ensure an empty block is not set. The normal default value is false.
	StripQuery *bool `json:"stripQuery,omitempty" tf:"strip_query,omitempty"`
}

type PathRuleURLRedirectObservation struct {

	// If set to true, the URL scheme in the redirected request is set to https.
	// If set to false, the URL scheme of the redirected request will remain the
	// same as that of the request. This must only be set for UrlMaps used in
	// TargetHttpProxys. Setting this true for TargetHttpsProxy is not
	// permitted. The default is set to false.
	HTTPSRedirect *bool `json:"httpsRedirect,omitempty" tf:"https_redirect,omitempty"`

	// The host that will be used in the redirect response instead of the one
	// that was supplied in the request. The value must be between 1 and 255
	// characters.
	HostRedirect *string `json:"hostRedirect,omitempty" tf:"host_redirect,omitempty"`

	// The path that will be used in the redirect response instead of the one
	// that was supplied in the request. pathRedirect cannot be supplied
	// together with prefixRedirect. Supply one alone or neither. If neither is
	// supplied, the path of the original request will be used for the redirect.
	// The value must be between 1 and 1024 characters.
	PathRedirect *string `json:"pathRedirect,omitempty" tf:"path_redirect,omitempty"`

	// The prefix that replaces the prefixMatch specified in the
	// HttpRouteRuleMatch, retaining the remaining portion of the URL before
	// redirecting the request. prefixRedirect cannot be supplied together with
	// pathRedirect. Supply one alone or neither. If neither is supplied, the
	// path of the original request will be used for the redirect. The value
	// must be between 1 and 1024 characters.
	PrefixRedirect *string `json:"prefixRedirect,omitempty" tf:"prefix_redirect,omitempty"`

	// The HTTP Status code to use for this RedirectAction. Supported values are:
	RedirectResponseCode *string `json:"redirectResponseCode,omitempty" tf:"redirect_response_code,omitempty"`

	// If set to true, any accompanying query portion of the original URL is
	// removed prior to redirecting the request. If set to false, the query
	// portion of the original URL is retained.
	// This field is required to ensure an empty block is not set. The normal default value is false.
	StripQuery *bool `json:"stripQuery,omitempty" tf:"strip_query,omitempty"`
}

type PathRuleURLRedirectParameters struct {

	// If set to true, the URL scheme in the redirected request is set to https.
	// If set to false, the URL scheme of the redirected request will remain the
	// same as that of the request. This must only be set for UrlMaps used in
	// TargetHttpProxys. Setting this true for TargetHttpsProxy is not
	// permitted. The default is set to false.
	// +kubebuilder:validation:Optional
	HTTPSRedirect *bool `json:"httpsRedirect,omitempty" tf:"https_redirect,omitempty"`

	// The host that will be used in the redirect response instead of the one
	// that was supplied in the request. The value must be between 1 and 255
	// characters.
	// +kubebuilder:validation:Optional
	HostRedirect *string `json:"hostRedirect,omitempty" tf:"host_redirect,omitempty"`

	// The path that will be used in the redirect response instead of the one
	// that was supplied in the request. pathRedirect cannot be supplied
	// together with prefixRedirect. Supply one alone or neither. If neither is
	// supplied, the path of the original request will be used for the redirect.
	// The value must be between 1 and 1024 characters.
	// +kubebuilder:validation:Optional
	PathRedirect *string `json:"pathRedirect,omitempty" tf:"path_redirect,omitempty"`

	// The prefix that replaces the prefixMatch specified in the
	// HttpRouteRuleMatch, retaining the remaining portion of the URL before
	// redirecting the request. prefixRedirect cannot be supplied together with
	// pathRedirect. Supply one alone or neither. If neither is supplied, the
	// path of the original request will be used for the redirect. The value
	// must be between 1 and 1024 characters.
	// +kubebuilder:validation:Optional
	PrefixRedirect *string `json:"prefixRedirect,omitempty" tf:"prefix_redirect,omitempty"`

	// The HTTP Status code to use for this RedirectAction. Supported values are:
	// +kubebuilder:validation:Optional
	RedirectResponseCode *string `json:"redirectResponseCode,omitempty" tf:"redirect_response_code,omitempty"`

	// If set to true, any accompanying query portion of the original URL is
	// removed prior to redirecting the request. If set to false, the query
	// portion of the original URL is retained.
	// This field is required to ensure an empty block is not set. The normal default value is false.
	// +kubebuilder:validation:Optional
	StripQuery *bool `json:"stripQuery" tf:"strip_query,omitempty"`
}

type RouteActionFaultInjectionPolicyDelayFixedDelayInitParameters struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type RouteActionFaultInjectionPolicyDelayFixedDelayObservation struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type RouteActionFaultInjectionPolicyDelayFixedDelayParameters struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	// +kubebuilder:validation:Optional
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	// +kubebuilder:validation:Optional
	Seconds *string `json:"seconds" tf:"seconds,omitempty"`
}

type RouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddInitParameters struct {

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type RouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddObservation struct {

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type RouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddParameters struct {

	// The name of the header.
	// +kubebuilder:validation:Optional
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`

	// The value of the header to add.
	// +kubebuilder:validation:Optional
	HeaderValue *string `json:"headerValue" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	// +kubebuilder:validation:Optional
	Replace *bool `json:"replace" tf:"replace,omitempty"`
}

type RouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddInitParameters struct {

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type RouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddObservation struct {

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type RouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddParameters struct {

	// The name of the header.
	// +kubebuilder:validation:Optional
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`

	// The value of the header to add.
	// +kubebuilder:validation:Optional
	HeaderValue *string `json:"headerValue" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	// +kubebuilder:validation:Optional
	Replace *bool `json:"replace" tf:"replace,omitempty"`
}

type RouteRulesMatchRulesInitParameters struct {

	// For satisfying the matchRule condition, the path of the request must exactly
	// match the value specified in fullPathMatch after removing any query parameters
	// and anchor that may be part of the original URL. FullPathMatch must be between 1
	// and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
	// be specified.
	FullPathMatch *string `json:"fullPathMatch,omitempty" tf:"full_path_match,omitempty"`

	// Specifies a list of header match criteria, all of which must match corresponding
	// headers in the request.
	// Structure is documented below.
	HeaderMatches []MatchRulesHeaderMatchesInitParameters `json:"headerMatches,omitempty" tf:"header_matches,omitempty"`

	// Specifies that prefixMatch and fullPathMatch matches are case sensitive.
	// Defaults to false.
	IgnoreCase *bool `json:"ignoreCase,omitempty" tf:"ignore_case,omitempty"`

	// Opaque filter criteria used by Loadbalancer to restrict routing configuration to
	// a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
	// clients present node metadata. If a match takes place, the relevant routing
	// configuration is made available to those proxies. For each metadataFilter in
	// this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
	// filterLabels must match the corresponding label provided in the metadata. If its
	// filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
	// with corresponding labels in the provided metadata. metadataFilters specified
	// here can be overrides those specified in ForwardingRule that refers to this
	// UrlMap. metadataFilters only applies to Loadbalancers that have their
	// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
	// Structure is documented below.
	MetadataFilters []RouteRulesMatchRulesMetadataFiltersInitParameters `json:"metadataFilters,omitempty" tf:"metadata_filters,omitempty"`

	// For satisfying the matchRule condition, the path of the request
	// must match the wildcard pattern specified in pathTemplateMatch
	// after removing any query parameters and anchor that may be part
	// of the original URL.
	// pathTemplateMatch must be between 1 and 255 characters
	// (inclusive).  The pattern specified by pathTemplateMatch may
	// have at most 5 wildcard operators and at most 5 variable
	// captures in total.
	PathTemplateMatch *string `json:"pathTemplateMatch,omitempty" tf:"path_template_match,omitempty"`

	// For satisfying the matchRule condition, the request's path must begin with the
	// specified prefixMatch. prefixMatch must begin with a /. The value must be
	// between 1 and 1024 characters. Only one of prefixMatch, fullPathMatch or
	// regexMatch must be specified.
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// Specifies a list of query parameter match criteria, all of which must match
	// corresponding query parameters in the request.
	// Structure is documented below.
	QueryParameterMatches []MatchRulesQueryParameterMatchesInitParameters `json:"queryParameterMatches,omitempty" tf:"query_parameter_matches,omitempty"`

	// The queryParameterMatch matches if the value of the parameter matches the
	// regular expression specified by regexMatch. For the regular expression grammar,
	// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
	// exactMatch and regexMatch must be set.
	RegexMatch *string `json:"regexMatch,omitempty" tf:"regex_match,omitempty"`
}

type RouteRulesMatchRulesMetadataFiltersInitParameters struct {

	// The list of label value pairs that must match labels in the provided metadata
	// based on filterMatchCriteria  This list must not be empty and can have at the
	// most 64 entries.
	// Structure is documented below.
	FilterLabels []MatchRulesMetadataFiltersFilterLabelsInitParameters `json:"filterLabels,omitempty" tf:"filter_labels,omitempty"`

	// Specifies how individual filterLabel matches within the list of filterLabels
	// contribute towards the overall metadataFilter match. Supported values are:
	FilterMatchCriteria *string `json:"filterMatchCriteria,omitempty" tf:"filter_match_criteria,omitempty"`
}

type RouteRulesMatchRulesMetadataFiltersObservation struct {

	// The list of label value pairs that must match labels in the provided metadata
	// based on filterMatchCriteria  This list must not be empty and can have at the
	// most 64 entries.
	// Structure is documented below.
	FilterLabels []MatchRulesMetadataFiltersFilterLabelsObservation `json:"filterLabels,omitempty" tf:"filter_labels,omitempty"`

	// Specifies how individual filterLabel matches within the list of filterLabels
	// contribute towards the overall metadataFilter match. Supported values are:
	FilterMatchCriteria *string `json:"filterMatchCriteria,omitempty" tf:"filter_match_criteria,omitempty"`
}

type RouteRulesMatchRulesMetadataFiltersParameters struct {

	// The list of label value pairs that must match labels in the provided metadata
	// based on filterMatchCriteria  This list must not be empty and can have at the
	// most 64 entries.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	FilterLabels []MatchRulesMetadataFiltersFilterLabelsParameters `json:"filterLabels" tf:"filter_labels,omitempty"`

	// Specifies how individual filterLabel matches within the list of filterLabels
	// contribute towards the overall metadataFilter match. Supported values are:
	// +kubebuilder:validation:Optional
	FilterMatchCriteria *string `json:"filterMatchCriteria" tf:"filter_match_criteria,omitempty"`
}

type RouteRulesMatchRulesObservation struct {

	// For satisfying the matchRule condition, the path of the request must exactly
	// match the value specified in fullPathMatch after removing any query parameters
	// and anchor that may be part of the original URL. FullPathMatch must be between 1
	// and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
	// be specified.
	FullPathMatch *string `json:"fullPathMatch,omitempty" tf:"full_path_match,omitempty"`

	// Specifies a list of header match criteria, all of which must match corresponding
	// headers in the request.
	// Structure is documented below.
	HeaderMatches []MatchRulesHeaderMatchesObservation `json:"headerMatches,omitempty" tf:"header_matches,omitempty"`

	// Specifies that prefixMatch and fullPathMatch matches are case sensitive.
	// Defaults to false.
	IgnoreCase *bool `json:"ignoreCase,omitempty" tf:"ignore_case,omitempty"`

	// Opaque filter criteria used by Loadbalancer to restrict routing configuration to
	// a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
	// clients present node metadata. If a match takes place, the relevant routing
	// configuration is made available to those proxies. For each metadataFilter in
	// this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
	// filterLabels must match the corresponding label provided in the metadata. If its
	// filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
	// with corresponding labels in the provided metadata. metadataFilters specified
	// here can be overrides those specified in ForwardingRule that refers to this
	// UrlMap. metadataFilters only applies to Loadbalancers that have their
	// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
	// Structure is documented below.
	MetadataFilters []RouteRulesMatchRulesMetadataFiltersObservation `json:"metadataFilters,omitempty" tf:"metadata_filters,omitempty"`

	// For satisfying the matchRule condition, the path of the request
	// must match the wildcard pattern specified in pathTemplateMatch
	// after removing any query parameters and anchor that may be part
	// of the original URL.
	// pathTemplateMatch must be between 1 and 255 characters
	// (inclusive).  The pattern specified by pathTemplateMatch may
	// have at most 5 wildcard operators and at most 5 variable
	// captures in total.
	PathTemplateMatch *string `json:"pathTemplateMatch,omitempty" tf:"path_template_match,omitempty"`

	// For satisfying the matchRule condition, the request's path must begin with the
	// specified prefixMatch. prefixMatch must begin with a /. The value must be
	// between 1 and 1024 characters. Only one of prefixMatch, fullPathMatch or
	// regexMatch must be specified.
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// Specifies a list of query parameter match criteria, all of which must match
	// corresponding query parameters in the request.
	// Structure is documented below.
	QueryParameterMatches []MatchRulesQueryParameterMatchesObservation `json:"queryParameterMatches,omitempty" tf:"query_parameter_matches,omitempty"`

	// The queryParameterMatch matches if the value of the parameter matches the
	// regular expression specified by regexMatch. For the regular expression grammar,
	// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
	// exactMatch and regexMatch must be set.
	RegexMatch *string `json:"regexMatch,omitempty" tf:"regex_match,omitempty"`
}

type RouteRulesMatchRulesParameters struct {

	// For satisfying the matchRule condition, the path of the request must exactly
	// match the value specified in fullPathMatch after removing any query parameters
	// and anchor that may be part of the original URL. FullPathMatch must be between 1
	// and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
	// be specified.
	// +kubebuilder:validation:Optional
	FullPathMatch *string `json:"fullPathMatch,omitempty" tf:"full_path_match,omitempty"`

	// Specifies a list of header match criteria, all of which must match corresponding
	// headers in the request.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	HeaderMatches []MatchRulesHeaderMatchesParameters `json:"headerMatches,omitempty" tf:"header_matches,omitempty"`

	// Specifies that prefixMatch and fullPathMatch matches are case sensitive.
	// Defaults to false.
	// +kubebuilder:validation:Optional
	IgnoreCase *bool `json:"ignoreCase,omitempty" tf:"ignore_case,omitempty"`

	// Opaque filter criteria used by Loadbalancer to restrict routing configuration to
	// a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
	// clients present node metadata. If a match takes place, the relevant routing
	// configuration is made available to those proxies. For each metadataFilter in
	// this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
	// filterLabels must match the corresponding label provided in the metadata. If its
	// filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
	// with corresponding labels in the provided metadata. metadataFilters specified
	// here can be overrides those specified in ForwardingRule that refers to this
	// UrlMap. metadataFilters only applies to Loadbalancers that have their
	// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	MetadataFilters []RouteRulesMatchRulesMetadataFiltersParameters `json:"metadataFilters,omitempty" tf:"metadata_filters,omitempty"`

	// For satisfying the matchRule condition, the path of the request
	// must match the wildcard pattern specified in pathTemplateMatch
	// after removing any query parameters and anchor that may be part
	// of the original URL.
	// pathTemplateMatch must be between 1 and 255 characters
	// (inclusive).  The pattern specified by pathTemplateMatch may
	// have at most 5 wildcard operators and at most 5 variable
	// captures in total.
	// +kubebuilder:validation:Optional
	PathTemplateMatch *string `json:"pathTemplateMatch,omitempty" tf:"path_template_match,omitempty"`

	// For satisfying the matchRule condition, the request's path must begin with the
	// specified prefixMatch. prefixMatch must begin with a /. The value must be
	// between 1 and 1024 characters. Only one of prefixMatch, fullPathMatch or
	// regexMatch must be specified.
	// +kubebuilder:validation:Optional
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// Specifies a list of query parameter match criteria, all of which must match
	// corresponding query parameters in the request.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	QueryParameterMatches []MatchRulesQueryParameterMatchesParameters `json:"queryParameterMatches,omitempty" tf:"query_parameter_matches,omitempty"`

	// The queryParameterMatch matches if the value of the parameter matches the
	// regular expression specified by regexMatch. For the regular expression grammar,
	// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
	// exactMatch and regexMatch must be set.
	// +kubebuilder:validation:Optional
	RegexMatch *string `json:"regexMatch,omitempty" tf:"regex_match,omitempty"`
}

type RouteRulesRouteActionFaultInjectionPolicyAbortInitParameters struct {

	// The HTTP status code used to abort the request. The value must be between 200
	// and 599 inclusive.
	HTTPStatus *float64 `json:"httpStatus,omitempty" tf:"http_status,omitempty"`

	// The percentage of traffic (connections/operations/requests) on which delay will
	// be introduced as part of fault injection. The value must be between 0.0 and
	// 100.0 inclusive.
	Percentage *float64 `json:"percentage,omitempty" tf:"percentage,omitempty"`
}

type RouteRulesRouteActionFaultInjectionPolicyAbortObservation struct {

	// The HTTP status code used to abort the request. The value must be between 200
	// and 599 inclusive.
	HTTPStatus *float64 `json:"httpStatus,omitempty" tf:"http_status,omitempty"`

	// The percentage of traffic (connections/operations/requests) on which delay will
	// be introduced as part of fault injection. The value must be between 0.0 and
	// 100.0 inclusive.
	Percentage *float64 `json:"percentage,omitempty" tf:"percentage,omitempty"`
}

type RouteRulesRouteActionFaultInjectionPolicyAbortParameters struct {

	// The HTTP status code used to abort the request. The value must be between 200
	// and 599 inclusive.
	// +kubebuilder:validation:Optional
	HTTPStatus *float64 `json:"httpStatus,omitempty" tf:"http_status,omitempty"`

	// The percentage of traffic (connections/operations/requests) on which delay will
	// be introduced as part of fault injection. The value must be between 0.0 and
	// 100.0 inclusive.
	// +kubebuilder:validation:Optional
	Percentage *float64 `json:"percentage,omitempty" tf:"percentage,omitempty"`
}

type RouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayInitParameters struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type RouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayObservation struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type RouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayParameters struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	// +kubebuilder:validation:Optional
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	// +kubebuilder:validation:Optional
	Seconds *string `json:"seconds" tf:"seconds,omitempty"`
}

type RouteRulesRouteActionFaultInjectionPolicyDelayInitParameters struct {

	// Specifies the value of the fixed delay interval.
	// Structure is documented below.
	FixedDelay []RouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayInitParameters `json:"fixedDelay,omitempty" tf:"fixed_delay,omitempty"`

	// The percentage of traffic (connections/operations/requests) on which delay will
	// be introduced as part of fault injection. The value must be between 0.0 and
	// 100.0 inclusive.
	Percentage *float64 `json:"percentage,omitempty" tf:"percentage,omitempty"`
}

type RouteRulesRouteActionFaultInjectionPolicyDelayObservation struct {

	// Specifies the value of the fixed delay interval.
	// Structure is documented below.
	FixedDelay []RouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayObservation `json:"fixedDelay,omitempty" tf:"fixed_delay,omitempty"`

	// The percentage of traffic (connections/operations/requests) on which delay will
	// be introduced as part of fault injection. The value must be between 0.0 and
	// 100.0 inclusive.
	Percentage *float64 `json:"percentage,omitempty" tf:"percentage,omitempty"`
}

type RouteRulesRouteActionFaultInjectionPolicyDelayParameters struct {

	// Specifies the value of the fixed delay interval.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	FixedDelay []RouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayParameters `json:"fixedDelay,omitempty" tf:"fixed_delay,omitempty"`

	// The percentage of traffic (connections/operations/requests) on which delay will
	// be introduced as part of fault injection. The value must be between 0.0 and
	// 100.0 inclusive.
	// +kubebuilder:validation:Optional
	Percentage *float64 `json:"percentage,omitempty" tf:"percentage,omitempty"`
}

type RouteRulesRouteActionRetryPolicyPerTryTimeoutInitParameters struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type RouteRulesRouteActionRetryPolicyPerTryTimeoutObservation struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	Seconds *string `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type RouteRulesRouteActionRetryPolicyPerTryTimeoutParameters struct {

	// Span of time that's a fraction of a second at nanosecond resolution. Durations
	// less than one second are represented with a 0 seconds field and a positive
	// nanos field. Must be from 0 to 999,999,999 inclusive.
	// +kubebuilder:validation:Optional
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
	// inclusive.
	// +kubebuilder:validation:Optional
	Seconds *string `json:"seconds" tf:"seconds,omitempty"`
}

type RouteRulesRouteActionWeightedBackendServicesHeaderActionInitParameters struct {

	// Headers to add to a matching request prior to forwarding the request to the
	// backendService.
	// Structure is documented below.
	RequestHeadersToAdd []RouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddInitParameters `json:"requestHeadersToAdd,omitempty" tf:"request_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the request
	// prior to forwarding the request to the backendService.
	RequestHeadersToRemove []*string `json:"requestHeadersToRemove,omitempty" tf:"request_headers_to_remove,omitempty"`

	// Headers to add the response prior to sending the response back to the client.
	// Structure is documented below.
	ResponseHeadersToAdd []RouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddInitParameters `json:"responseHeadersToAdd,omitempty" tf:"response_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the response
	// prior to sending the response back to the client.
	ResponseHeadersToRemove []*string `json:"responseHeadersToRemove,omitempty" tf:"response_headers_to_remove,omitempty"`
}

type RouteRulesRouteActionWeightedBackendServicesHeaderActionObservation struct {

	// Headers to add to a matching request prior to forwarding the request to the
	// backendService.
	// Structure is documented below.
	RequestHeadersToAdd []RouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddObservation `json:"requestHeadersToAdd,omitempty" tf:"request_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the request
	// prior to forwarding the request to the backendService.
	RequestHeadersToRemove []*string `json:"requestHeadersToRemove,omitempty" tf:"request_headers_to_remove,omitempty"`

	// Headers to add the response prior to sending the response back to the client.
	// Structure is documented below.
	ResponseHeadersToAdd []RouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddObservation `json:"responseHeadersToAdd,omitempty" tf:"response_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the response
	// prior to sending the response back to the client.
	ResponseHeadersToRemove []*string `json:"responseHeadersToRemove,omitempty" tf:"response_headers_to_remove,omitempty"`
}

type RouteRulesRouteActionWeightedBackendServicesHeaderActionParameters struct {

	// Headers to add to a matching request prior to forwarding the request to the
	// backendService.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	RequestHeadersToAdd []RouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddParameters `json:"requestHeadersToAdd,omitempty" tf:"request_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the request
	// prior to forwarding the request to the backendService.
	// +kubebuilder:validation:Optional
	RequestHeadersToRemove []*string `json:"requestHeadersToRemove,omitempty" tf:"request_headers_to_remove,omitempty"`

	// Headers to add the response prior to sending the response back to the client.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	ResponseHeadersToAdd []RouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddParameters `json:"responseHeadersToAdd,omitempty" tf:"response_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the response
	// prior to sending the response back to the client.
	// +kubebuilder:validation:Optional
	ResponseHeadersToRemove []*string `json:"responseHeadersToRemove,omitempty" tf:"response_headers_to_remove,omitempty"`
}

type RouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddInitParameters struct {

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type RouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddObservation struct {

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type RouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddParameters struct {

	// The name of the header.
	// +kubebuilder:validation:Optional
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`

	// The value of the header to add.
	// +kubebuilder:validation:Optional
	HeaderValue *string `json:"headerValue" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	// +kubebuilder:validation:Optional
	Replace *bool `json:"replace" tf:"replace,omitempty"`
}

type RouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddInitParameters struct {

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type RouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddObservation struct {

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type RouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddParameters struct {

	// The name of the header.
	// +kubebuilder:validation:Optional
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`

	// The value of the header to add.
	// +kubebuilder:validation:Optional
	HeaderValue *string `json:"headerValue" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	// +kubebuilder:validation:Optional
	Replace *bool `json:"replace" tf:"replace,omitempty"`
}

type URLMapDefaultRouteActionInitParameters struct {

	// The specification for allowing client side cross-origin requests. Please see
	// W3C Recommendation for Cross Origin Resource Sharing
	// Structure is documented below.
	CorsPolicy []DefaultRouteActionCorsPolicyInitParameters `json:"corsPolicy,omitempty" tf:"cors_policy,omitempty"`

	// The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
	// As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
	// percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
	// by the Loadbalancer for a percentage of requests.
	// timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.
	// Structure is documented below.
	FaultInjectionPolicy []DefaultRouteActionFaultInjectionPolicyInitParameters `json:"faultInjectionPolicy,omitempty" tf:"fault_injection_policy,omitempty"`

	// Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
	// Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
	// the host / authority header is suffixed with -shadow.
	// Structure is documented below.
	RequestMirrorPolicy []DefaultRouteActionRequestMirrorPolicyInitParameters `json:"requestMirrorPolicy,omitempty" tf:"request_mirror_policy,omitempty"`

	// Specifies the retry policy associated with this route.
	// Structure is documented below.
	RetryPolicy []DefaultRouteActionRetryPolicyInitParameters `json:"retryPolicy,omitempty" tf:"retry_policy,omitempty"`

	// Specifies the timeout for the selected route. Timeout is computed from the time the request has been
	// fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
	// If not specified, will use the largest timeout among all backend services associated with the route.
	// Structure is documented below.
	Timeout []DefaultRouteActionTimeoutInitParameters `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// The spec to modify the URL of the request, prior to forwarding the request to the matched service.
	// Structure is documented below.
	URLRewrite []DefaultRouteActionURLRewriteInitParameters `json:"urlRewrite,omitempty" tf:"url_rewrite,omitempty"`

	// A list of weighted backend services to send traffic to when a route match occurs.
	// The weights determine the fraction of traffic that flows to their corresponding backend service.
	// If all traffic needs to go to a single backend service, there must be one weightedBackendService
	// with weight set to a non 0 number.
	// Once a backendService is identified and before forwarding the request to the backend service,
	// advanced routing actions like Url rewrites and header transformations are applied depending on
	// additional settings specified in this HttpRouteAction.
	// Structure is documented below.
	WeightedBackendServices []DefaultRouteActionWeightedBackendServicesInitParameters `json:"weightedBackendServices,omitempty" tf:"weighted_backend_services,omitempty"`
}

type URLMapDefaultRouteActionObservation struct {

	// The specification for allowing client side cross-origin requests. Please see
	// W3C Recommendation for Cross Origin Resource Sharing
	// Structure is documented below.
	CorsPolicy []DefaultRouteActionCorsPolicyObservation `json:"corsPolicy,omitempty" tf:"cors_policy,omitempty"`

	// The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
	// As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
	// percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
	// by the Loadbalancer for a percentage of requests.
	// timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.
	// Structure is documented below.
	FaultInjectionPolicy []DefaultRouteActionFaultInjectionPolicyObservation `json:"faultInjectionPolicy,omitempty" tf:"fault_injection_policy,omitempty"`

	// Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
	// Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
	// the host / authority header is suffixed with -shadow.
	// Structure is documented below.
	RequestMirrorPolicy []DefaultRouteActionRequestMirrorPolicyObservation `json:"requestMirrorPolicy,omitempty" tf:"request_mirror_policy,omitempty"`

	// Specifies the retry policy associated with this route.
	// Structure is documented below.
	RetryPolicy []DefaultRouteActionRetryPolicyObservation `json:"retryPolicy,omitempty" tf:"retry_policy,omitempty"`

	// Specifies the timeout for the selected route. Timeout is computed from the time the request has been
	// fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
	// If not specified, will use the largest timeout among all backend services associated with the route.
	// Structure is documented below.
	Timeout []DefaultRouteActionTimeoutObservation `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// The spec to modify the URL of the request, prior to forwarding the request to the matched service.
	// Structure is documented below.
	URLRewrite []DefaultRouteActionURLRewriteObservation `json:"urlRewrite,omitempty" tf:"url_rewrite,omitempty"`

	// A list of weighted backend services to send traffic to when a route match occurs.
	// The weights determine the fraction of traffic that flows to their corresponding backend service.
	// If all traffic needs to go to a single backend service, there must be one weightedBackendService
	// with weight set to a non 0 number.
	// Once a backendService is identified and before forwarding the request to the backend service,
	// advanced routing actions like Url rewrites and header transformations are applied depending on
	// additional settings specified in this HttpRouteAction.
	// Structure is documented below.
	WeightedBackendServices []DefaultRouteActionWeightedBackendServicesObservation `json:"weightedBackendServices,omitempty" tf:"weighted_backend_services,omitempty"`
}

type URLMapDefaultRouteActionParameters struct {

	// The specification for allowing client side cross-origin requests. Please see
	// W3C Recommendation for Cross Origin Resource Sharing
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	CorsPolicy []DefaultRouteActionCorsPolicyParameters `json:"corsPolicy,omitempty" tf:"cors_policy,omitempty"`

	// The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
	// As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
	// percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
	// by the Loadbalancer for a percentage of requests.
	// timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	FaultInjectionPolicy []DefaultRouteActionFaultInjectionPolicyParameters `json:"faultInjectionPolicy,omitempty" tf:"fault_injection_policy,omitempty"`

	// Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
	// Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
	// the host / authority header is suffixed with -shadow.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	RequestMirrorPolicy []DefaultRouteActionRequestMirrorPolicyParameters `json:"requestMirrorPolicy,omitempty" tf:"request_mirror_policy,omitempty"`

	// Specifies the retry policy associated with this route.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	RetryPolicy []DefaultRouteActionRetryPolicyParameters `json:"retryPolicy,omitempty" tf:"retry_policy,omitempty"`

	// Specifies the timeout for the selected route. Timeout is computed from the time the request has been
	// fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
	// If not specified, will use the largest timeout among all backend services associated with the route.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Timeout []DefaultRouteActionTimeoutParameters `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// The spec to modify the URL of the request, prior to forwarding the request to the matched service.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	URLRewrite []DefaultRouteActionURLRewriteParameters `json:"urlRewrite,omitempty" tf:"url_rewrite,omitempty"`

	// A list of weighted backend services to send traffic to when a route match occurs.
	// The weights determine the fraction of traffic that flows to their corresponding backend service.
	// If all traffic needs to go to a single backend service, there must be one weightedBackendService
	// with weight set to a non 0 number.
	// Once a backendService is identified and before forwarding the request to the backend service,
	// advanced routing actions like Url rewrites and header transformations are applied depending on
	// additional settings specified in this HttpRouteAction.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	WeightedBackendServices []DefaultRouteActionWeightedBackendServicesParameters `json:"weightedBackendServices,omitempty" tf:"weighted_backend_services,omitempty"`
}

type URLMapDefaultURLRedirectInitParameters struct {

	// If set to true, the URL scheme in the redirected request is set to https. If set to
	// false, the URL scheme of the redirected request will remain the same as that of the
	// request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
	// true for TargetHttpsProxy is not permitted. The default is set to false.
	HTTPSRedirect *bool `json:"httpsRedirect,omitempty" tf:"https_redirect,omitempty"`

	// The host that will be used in the redirect response instead of the one that was
	// supplied in the request. The value must be between 1 and 255 characters.
	HostRedirect *string `json:"hostRedirect,omitempty" tf:"host_redirect,omitempty"`

	// The path that will be used in the redirect response instead of the one that was
	// supplied in the request. pathRedirect cannot be supplied together with
	// prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
	// original request will be used for the redirect. The value must be between 1 and 1024
	// characters.
	PathRedirect *string `json:"pathRedirect,omitempty" tf:"path_redirect,omitempty"`

	// The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
	// retaining the remaining portion of the URL before redirecting the request.
	// prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
	// neither. If neither is supplied, the path of the original request will be used for
	// the redirect. The value must be between 1 and 1024 characters.
	PrefixRedirect *string `json:"prefixRedirect,omitempty" tf:"prefix_redirect,omitempty"`

	// The HTTP Status code to use for this RedirectAction. Supported values are:
	RedirectResponseCode *string `json:"redirectResponseCode,omitempty" tf:"redirect_response_code,omitempty"`

	// If set to true, any accompanying query portion of the original URL is removed prior
	// to redirecting the request. If set to false, the query portion of the original URL is
	// retained.
	// This field is required to ensure an empty block is not set. The normal default value is false.
	StripQuery *bool `json:"stripQuery,omitempty" tf:"strip_query,omitempty"`
}

type URLMapDefaultURLRedirectObservation struct {

	// If set to true, the URL scheme in the redirected request is set to https. If set to
	// false, the URL scheme of the redirected request will remain the same as that of the
	// request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
	// true for TargetHttpsProxy is not permitted. The default is set to false.
	HTTPSRedirect *bool `json:"httpsRedirect,omitempty" tf:"https_redirect,omitempty"`

	// The host that will be used in the redirect response instead of the one that was
	// supplied in the request. The value must be between 1 and 255 characters.
	HostRedirect *string `json:"hostRedirect,omitempty" tf:"host_redirect,omitempty"`

	// The path that will be used in the redirect response instead of the one that was
	// supplied in the request. pathRedirect cannot be supplied together with
	// prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
	// original request will be used for the redirect. The value must be between 1 and 1024
	// characters.
	PathRedirect *string `json:"pathRedirect,omitempty" tf:"path_redirect,omitempty"`

	// The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
	// retaining the remaining portion of the URL before redirecting the request.
	// prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
	// neither. If neither is supplied, the path of the original request will be used for
	// the redirect. The value must be between 1 and 1024 characters.
	PrefixRedirect *string `json:"prefixRedirect,omitempty" tf:"prefix_redirect,omitempty"`

	// The HTTP Status code to use for this RedirectAction. Supported values are:
	RedirectResponseCode *string `json:"redirectResponseCode,omitempty" tf:"redirect_response_code,omitempty"`

	// If set to true, any accompanying query portion of the original URL is removed prior
	// to redirecting the request. If set to false, the query portion of the original URL is
	// retained.
	// This field is required to ensure an empty block is not set. The normal default value is false.
	StripQuery *bool `json:"stripQuery,omitempty" tf:"strip_query,omitempty"`
}

type URLMapDefaultURLRedirectParameters struct {

	// If set to true, the URL scheme in the redirected request is set to https. If set to
	// false, the URL scheme of the redirected request will remain the same as that of the
	// request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
	// true for TargetHttpsProxy is not permitted. The default is set to false.
	// +kubebuilder:validation:Optional
	HTTPSRedirect *bool `json:"httpsRedirect,omitempty" tf:"https_redirect,omitempty"`

	// The host that will be used in the redirect response instead of the one that was
	// supplied in the request. The value must be between 1 and 255 characters.
	// +kubebuilder:validation:Optional
	HostRedirect *string `json:"hostRedirect,omitempty" tf:"host_redirect,omitempty"`

	// The path that will be used in the redirect response instead of the one that was
	// supplied in the request. pathRedirect cannot be supplied together with
	// prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
	// original request will be used for the redirect. The value must be between 1 and 1024
	// characters.
	// +kubebuilder:validation:Optional
	PathRedirect *string `json:"pathRedirect,omitempty" tf:"path_redirect,omitempty"`

	// The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
	// retaining the remaining portion of the URL before redirecting the request.
	// prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
	// neither. If neither is supplied, the path of the original request will be used for
	// the redirect. The value must be between 1 and 1024 characters.
	// +kubebuilder:validation:Optional
	PrefixRedirect *string `json:"prefixRedirect,omitempty" tf:"prefix_redirect,omitempty"`

	// The HTTP Status code to use for this RedirectAction. Supported values are:
	// +kubebuilder:validation:Optional
	RedirectResponseCode *string `json:"redirectResponseCode,omitempty" tf:"redirect_response_code,omitempty"`

	// If set to true, any accompanying query portion of the original URL is removed prior
	// to redirecting the request. If set to false, the query portion of the original URL is
	// retained.
	// This field is required to ensure an empty block is not set. The normal default value is false.
	// +kubebuilder:validation:Optional
	StripQuery *bool `json:"stripQuery" tf:"strip_query,omitempty"`
}

type URLMapHeaderActionInitParameters struct {

	// Headers to add to a matching request prior to forwarding the request to the
	// backendService.
	// Structure is documented below.
	RequestHeadersToAdd []URLMapHeaderActionRequestHeadersToAddInitParameters `json:"requestHeadersToAdd,omitempty" tf:"request_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the request
	// prior to forwarding the request to the backendService.
	RequestHeadersToRemove []*string `json:"requestHeadersToRemove,omitempty" tf:"request_headers_to_remove,omitempty"`

	// Headers to add the response prior to sending the response back to the client.
	// Structure is documented below.
	ResponseHeadersToAdd []URLMapHeaderActionResponseHeadersToAddInitParameters `json:"responseHeadersToAdd,omitempty" tf:"response_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the response
	// prior to sending the response back to the client.
	ResponseHeadersToRemove []*string `json:"responseHeadersToRemove,omitempty" tf:"response_headers_to_remove,omitempty"`
}

type URLMapHeaderActionObservation struct {

	// Headers to add to a matching request prior to forwarding the request to the
	// backendService.
	// Structure is documented below.
	RequestHeadersToAdd []URLMapHeaderActionRequestHeadersToAddObservation `json:"requestHeadersToAdd,omitempty" tf:"request_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the request
	// prior to forwarding the request to the backendService.
	RequestHeadersToRemove []*string `json:"requestHeadersToRemove,omitempty" tf:"request_headers_to_remove,omitempty"`

	// Headers to add the response prior to sending the response back to the client.
	// Structure is documented below.
	ResponseHeadersToAdd []URLMapHeaderActionResponseHeadersToAddObservation `json:"responseHeadersToAdd,omitempty" tf:"response_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the response
	// prior to sending the response back to the client.
	ResponseHeadersToRemove []*string `json:"responseHeadersToRemove,omitempty" tf:"response_headers_to_remove,omitempty"`
}

type URLMapHeaderActionParameters struct {

	// Headers to add to a matching request prior to forwarding the request to the
	// backendService.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	RequestHeadersToAdd []URLMapHeaderActionRequestHeadersToAddParameters `json:"requestHeadersToAdd,omitempty" tf:"request_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the request
	// prior to forwarding the request to the backendService.
	// +kubebuilder:validation:Optional
	RequestHeadersToRemove []*string `json:"requestHeadersToRemove,omitempty" tf:"request_headers_to_remove,omitempty"`

	// Headers to add the response prior to sending the response back to the client.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	ResponseHeadersToAdd []URLMapHeaderActionResponseHeadersToAddParameters `json:"responseHeadersToAdd,omitempty" tf:"response_headers_to_add,omitempty"`

	// A list of header names for headers that need to be removed from the response
	// prior to sending the response back to the client.
	// +kubebuilder:validation:Optional
	ResponseHeadersToRemove []*string `json:"responseHeadersToRemove,omitempty" tf:"response_headers_to_remove,omitempty"`
}

type URLMapHeaderActionRequestHeadersToAddInitParameters struct {

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type URLMapHeaderActionRequestHeadersToAddObservation struct {

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type URLMapHeaderActionRequestHeadersToAddParameters struct {

	// The name of the header.
	// +kubebuilder:validation:Optional
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`

	// The value of the header to add.
	// +kubebuilder:validation:Optional
	HeaderValue *string `json:"headerValue" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	// +kubebuilder:validation:Optional
	Replace *bool `json:"replace" tf:"replace,omitempty"`
}

type URLMapHeaderActionResponseHeadersToAddInitParameters struct {

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type URLMapHeaderActionResponseHeadersToAddObservation struct {

	// The name of the header.
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	// The value of the header to add.
	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	Replace *bool `json:"replace,omitempty" tf:"replace,omitempty"`
}

type URLMapHeaderActionResponseHeadersToAddParameters struct {

	// The name of the header.
	// +kubebuilder:validation:Optional
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`

	// The value of the header to add.
	// +kubebuilder:validation:Optional
	HeaderValue *string `json:"headerValue" tf:"header_value,omitempty"`

	// If false, headerValue is appended to any values that already exist for the
	// header. If true, headerValue is set for the header, discarding any values that
	// were set for that header.
	// +kubebuilder:validation:Optional
	Replace *bool `json:"replace" tf:"replace,omitempty"`
}

type URLMapHostRuleInitParameters struct {

	// An optional description of this resource. Provide this property when you create
	// the resource.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The list of host patterns to match. They must be valid hostnames, except * will
	// match any string of ([a-z0-9-.]*). In that case, * must be the first character
	// and must be followed in the pattern by either - or ..
	// +listType=set
	Hosts []*string `json:"hosts,omitempty" tf:"hosts,omitempty"`

	// The name of the PathMatcher to use to match the path portion of the URL if the
	// hostRule matches the URL's host portion.
	PathMatcher *string `json:"pathMatcher,omitempty" tf:"path_matcher,omitempty"`
}

type URLMapHostRuleObservation struct {

	// An optional description of this resource. Provide this property when you create
	// the resource.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The list of host patterns to match. They must be valid hostnames, except * will
	// match any string of ([a-z0-9-.]*). In that case, * must be the first character
	// and must be followed in the pattern by either - or ..
	// +listType=set
	Hosts []*string `json:"hosts,omitempty" tf:"hosts,omitempty"`

	// The name of the PathMatcher to use to match the path portion of the URL if the
	// hostRule matches the URL's host portion.
	PathMatcher *string `json:"pathMatcher,omitempty" tf:"path_matcher,omitempty"`
}

type URLMapHostRuleParameters struct {

	// An optional description of this resource. Provide this property when you create
	// the resource.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The list of host patterns to match. They must be valid hostnames, except * will
	// match any string of ([a-z0-9-.]*). In that case, * must be the first character
	// and must be followed in the pattern by either - or ..
	// +kubebuilder:validation:Optional
	// +listType=set
	Hosts []*string `json:"hosts" tf:"hosts,omitempty"`

	// The name of the PathMatcher to use to match the path portion of the URL if the
	// hostRule matches the URL's host portion.
	// +kubebuilder:validation:Optional
	PathMatcher *string `json:"pathMatcher" tf:"path_matcher,omitempty"`
}

type URLMapInitParameters struct {

	// defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions
	// like URL rewrites, header transformations, etc. prior to forwarding the request to the selected backend.
	// If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService
	// is set, defaultRouteAction cannot contain any weightedBackendServices.
	// Only one of defaultRouteAction or defaultUrlRedirect must be set.
	// Structure is documented below.
	DefaultRouteAction []URLMapDefaultRouteActionInitParameters `json:"defaultRouteAction,omitempty" tf:"default_route_action,omitempty"`

	// The backend service or backend bucket to use when none of the given rules match.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.BackendBucket
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	DefaultService *string `json:"defaultService,omitempty" tf:"default_service,omitempty"`

	// Reference to a BackendBucket in compute to populate defaultService.
	// +kubebuilder:validation:Optional
	DefaultServiceRef *v1.Reference `json:"defaultServiceRef,omitempty" tf:"-"`

	// Selector for a BackendBucket in compute to populate defaultService.
	// +kubebuilder:validation:Optional
	DefaultServiceSelector *v1.Selector `json:"defaultServiceSelector,omitempty" tf:"-"`

	// When none of the specified hostRules match, the request is redirected to a URL specified
	// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
	// defaultRouteAction must not be set.
	// Structure is documented below.
	DefaultURLRedirect []URLMapDefaultURLRedirectInitParameters `json:"defaultUrlRedirect,omitempty" tf:"default_url_redirect,omitempty"`

	// An optional description of this resource. Provide this property when you create
	// the resource.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Specifies changes to request and response headers that need to take effect for
	// the selected backendService. The headerAction specified here take effect after
	// headerAction specified under pathMatcher.
	// Structure is documented below.
	HeaderAction []URLMapHeaderActionInitParameters `json:"headerAction,omitempty" tf:"header_action,omitempty"`

	// The list of HostRules to use against the URL.
	// Structure is documented below.
	HostRule []URLMapHostRuleInitParameters `json:"hostRule,omitempty" tf:"host_rule,omitempty"`

	// The list of named PathMatchers to use against the URL.
	// Structure is documented below.
	PathMatcher []URLMapPathMatcherInitParameters `json:"pathMatcher,omitempty" tf:"path_matcher,omitempty"`

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// The list of expected URL mapping tests. Request to update this UrlMap will
	// succeed only if all of the test cases pass. You can specify a maximum of 100
	// tests per UrlMap.
	// Structure is documented below.
	Test []URLMapTestInitParameters `json:"test,omitempty" tf:"test,omitempty"`
}

type URLMapObservation struct {

	// Creation timestamp in RFC3339 text format.
	CreationTimestamp *string `json:"creationTimestamp,omitempty" tf:"creation_timestamp,omitempty"`

	// defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions
	// like URL rewrites, header transformations, etc. prior to forwarding the request to the selected backend.
	// If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService
	// is set, defaultRouteAction cannot contain any weightedBackendServices.
	// Only one of defaultRouteAction or defaultUrlRedirect must be set.
	// Structure is documented below.
	DefaultRouteAction []URLMapDefaultRouteActionObservation `json:"defaultRouteAction,omitempty" tf:"default_route_action,omitempty"`

	// The backend service or backend bucket to use when none of the given rules match.
	DefaultService *string `json:"defaultService,omitempty" tf:"default_service,omitempty"`

	// When none of the specified hostRules match, the request is redirected to a URL specified
	// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
	// defaultRouteAction must not be set.
	// Structure is documented below.
	DefaultURLRedirect []URLMapDefaultURLRedirectObservation `json:"defaultUrlRedirect,omitempty" tf:"default_url_redirect,omitempty"`

	// An optional description of this resource. Provide this property when you create
	// the resource.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Fingerprint of this resource. A hash of the contents stored in this object. This
	// field is used in optimistic locking.
	Fingerprint *string `json:"fingerprint,omitempty" tf:"fingerprint,omitempty"`

	// Specifies changes to request and response headers that need to take effect for
	// the selected backendService. The headerAction specified here take effect after
	// headerAction specified under pathMatcher.
	// Structure is documented below.
	HeaderAction []URLMapHeaderActionObservation `json:"headerAction,omitempty" tf:"header_action,omitempty"`

	// The list of HostRules to use against the URL.
	// Structure is documented below.
	HostRule []URLMapHostRuleObservation `json:"hostRule,omitempty" tf:"host_rule,omitempty"`

	// an identifier for the resource with format projects/{{project}}/global/urlMaps/{{name}}
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The unique identifier for the resource.
	MapID *float64 `json:"mapId,omitempty" tf:"map_id,omitempty"`

	// The list of named PathMatchers to use against the URL.
	// Structure is documented below.
	PathMatcher []URLMapPathMatcherObservation `json:"pathMatcher,omitempty" tf:"path_matcher,omitempty"`

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// The URI of the created resource.
	SelfLink *string `json:"selfLink,omitempty" tf:"self_link,omitempty"`

	// The list of expected URL mapping tests. Request to update this UrlMap will
	// succeed only if all of the test cases pass. You can specify a maximum of 100
	// tests per UrlMap.
	// Structure is documented below.
	Test []URLMapTestObservation `json:"test,omitempty" tf:"test,omitempty"`
}

type URLMapParameters struct {

	// defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions
	// like URL rewrites, header transformations, etc. prior to forwarding the request to the selected backend.
	// If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService
	// is set, defaultRouteAction cannot contain any weightedBackendServices.
	// Only one of defaultRouteAction or defaultUrlRedirect must be set.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	DefaultRouteAction []URLMapDefaultRouteActionParameters `json:"defaultRouteAction,omitempty" tf:"default_route_action,omitempty"`

	// The backend service or backend bucket to use when none of the given rules match.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.BackendBucket
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	DefaultService *string `json:"defaultService,omitempty" tf:"default_service,omitempty"`

	// Reference to a BackendBucket in compute to populate defaultService.
	// +kubebuilder:validation:Optional
	DefaultServiceRef *v1.Reference `json:"defaultServiceRef,omitempty" tf:"-"`

	// Selector for a BackendBucket in compute to populate defaultService.
	// +kubebuilder:validation:Optional
	DefaultServiceSelector *v1.Selector `json:"defaultServiceSelector,omitempty" tf:"-"`

	// When none of the specified hostRules match, the request is redirected to a URL specified
	// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
	// defaultRouteAction must not be set.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	DefaultURLRedirect []URLMapDefaultURLRedirectParameters `json:"defaultUrlRedirect,omitempty" tf:"default_url_redirect,omitempty"`

	// An optional description of this resource. Provide this property when you create
	// the resource.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Specifies changes to request and response headers that need to take effect for
	// the selected backendService. The headerAction specified here take effect after
	// headerAction specified under pathMatcher.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	HeaderAction []URLMapHeaderActionParameters `json:"headerAction,omitempty" tf:"header_action,omitempty"`

	// The list of HostRules to use against the URL.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	HostRule []URLMapHostRuleParameters `json:"hostRule,omitempty" tf:"host_rule,omitempty"`

	// The list of named PathMatchers to use against the URL.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	PathMatcher []URLMapPathMatcherParameters `json:"pathMatcher,omitempty" tf:"path_matcher,omitempty"`

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	// +kubebuilder:validation:Optional
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// The list of expected URL mapping tests. Request to update this UrlMap will
	// succeed only if all of the test cases pass. You can specify a maximum of 100
	// tests per UrlMap.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Test []URLMapTestParameters `json:"test,omitempty" tf:"test,omitempty"`
}

type URLMapPathMatcherDefaultURLRedirectInitParameters struct {

	// If set to true, the URL scheme in the redirected request is set to https.
	// If set to false, the URL scheme of the redirected request will remain the
	// same as that of the request. This must only be set for UrlMaps used in
	// TargetHttpProxys. Setting this true for TargetHttpsProxy is not
	// permitted. The default is set to false.
	HTTPSRedirect *bool `json:"httpsRedirect,omitempty" tf:"https_redirect,omitempty"`

	// The host that will be used in the redirect response instead of the one
	// that was supplied in the request. The value must be between 1 and 255
	// characters.
	HostRedirect *string `json:"hostRedirect,omitempty" tf:"host_redirect,omitempty"`

	// The path that will be used in the redirect response instead of the one
	// that was supplied in the request. pathRedirect cannot be supplied
	// together with prefixRedirect. Supply one alone or neither. If neither is
	// supplied, the path of the original request will be used for the redirect.
	// The value must be between 1 and 1024 characters.
	PathRedirect *string `json:"pathRedirect,omitempty" tf:"path_redirect,omitempty"`

	// The prefix that replaces the prefixMatch specified in the
	// HttpRouteRuleMatch, retaining the remaining portion of the URL before
	// redirecting the request. prefixRedirect cannot be supplied together with
	// pathRedirect. Supply one alone or neither. If neither is supplied, the
	// path of the original request will be used for the redirect. The value
	// must be between 1 and 1024 characters.
	PrefixRedirect *string `json:"prefixRedirect,omitempty" tf:"prefix_redirect,omitempty"`

	// The HTTP Status code to use for this RedirectAction. Supported values are:
	RedirectResponseCode *string `json:"redirectResponseCode,omitempty" tf:"redirect_response_code,omitempty"`

	// If set to true, any accompanying query portion of the original URL is
	// removed prior to redirecting the request. If set to false, the query
	// portion of the original URL is retained.
	// This field is required to ensure an empty block is not set. The normal default value is false.
	StripQuery *bool `json:"stripQuery,omitempty" tf:"strip_query,omitempty"`
}

type URLMapPathMatcherDefaultURLRedirectObservation struct {

	// If set to true, the URL scheme in the redirected request is set to https.
	// If set to false, the URL scheme of the redirected request will remain the
	// same as that of the request. This must only be set for UrlMaps used in
	// TargetHttpProxys. Setting this true for TargetHttpsProxy is not
	// permitted. The default is set to false.
	HTTPSRedirect *bool `json:"httpsRedirect,omitempty" tf:"https_redirect,omitempty"`

	// The host that will be used in the redirect response instead of the one
	// that was supplied in the request. The value must be between 1 and 255
	// characters.
	HostRedirect *string `json:"hostRedirect,omitempty" tf:"host_redirect,omitempty"`

	// The path that will be used in the redirect response instead of the one
	// that was supplied in the request. pathRedirect cannot be supplied
	// together with prefixRedirect. Supply one alone or neither. If neither is
	// supplied, the path of the original request will be used for the redirect.
	// The value must be between 1 and 1024 characters.
	PathRedirect *string `json:"pathRedirect,omitempty" tf:"path_redirect,omitempty"`

	// The prefix that replaces the prefixMatch specified in the
	// HttpRouteRuleMatch, retaining the remaining portion of the URL before
	// redirecting the request. prefixRedirect cannot be supplied together with
	// pathRedirect. Supply one alone or neither. If neither is supplied, the
	// path of the original request will be used for the redirect. The value
	// must be between 1 and 1024 characters.
	PrefixRedirect *string `json:"prefixRedirect,omitempty" tf:"prefix_redirect,omitempty"`

	// The HTTP Status code to use for this RedirectAction. Supported values are:
	RedirectResponseCode *string `json:"redirectResponseCode,omitempty" tf:"redirect_response_code,omitempty"`

	// If set to true, any accompanying query portion of the original URL is
	// removed prior to redirecting the request. If set to false, the query
	// portion of the original URL is retained.
	// This field is required to ensure an empty block is not set. The normal default value is false.
	StripQuery *bool `json:"stripQuery,omitempty" tf:"strip_query,omitempty"`
}

type URLMapPathMatcherDefaultURLRedirectParameters struct {

	// If set to true, the URL scheme in the redirected request is set to https.
	// If set to false, the URL scheme of the redirected request will remain the
	// same as that of the request. This must only be set for UrlMaps used in
	// TargetHttpProxys. Setting this true for TargetHttpsProxy is not
	// permitted. The default is set to false.
	// +kubebuilder:validation:Optional
	HTTPSRedirect *bool `json:"httpsRedirect,omitempty" tf:"https_redirect,omitempty"`

	// The host that will be used in the redirect response instead of the one
	// that was supplied in the request. The value must be between 1 and 255
	// characters.
	// +kubebuilder:validation:Optional
	HostRedirect *string `json:"hostRedirect,omitempty" tf:"host_redirect,omitempty"`

	// The path that will be used in the redirect response instead of the one
	// that was supplied in the request. pathRedirect cannot be supplied
	// together with prefixRedirect. Supply one alone or neither. If neither is
	// supplied, the path of the original request will be used for the redirect.
	// The value must be between 1 and 1024 characters.
	// +kubebuilder:validation:Optional
	PathRedirect *string `json:"pathRedirect,omitempty" tf:"path_redirect,omitempty"`

	// The prefix that replaces the prefixMatch specified in the
	// HttpRouteRuleMatch, retaining the remaining portion of the URL before
	// redirecting the request. prefixRedirect cannot be supplied together with
	// pathRedirect. Supply one alone or neither. If neither is supplied, the
	// path of the original request will be used for the redirect. The value
	// must be between 1 and 1024 characters.
	// +kubebuilder:validation:Optional
	PrefixRedirect *string `json:"prefixRedirect,omitempty" tf:"prefix_redirect,omitempty"`

	// The HTTP Status code to use for this RedirectAction. Supported values are:
	// +kubebuilder:validation:Optional
	RedirectResponseCode *string `json:"redirectResponseCode,omitempty" tf:"redirect_response_code,omitempty"`

	// If set to true, any accompanying query portion of the original URL is
	// removed prior to redirecting the request. If set to false, the query
	// portion of the original URL is retained.
	// This field is required to ensure an empty block is not set. The normal default value is false.
	// +kubebuilder:validation:Optional
	StripQuery *bool `json:"stripQuery" tf:"strip_query,omitempty"`
}

type URLMapPathMatcherInitParameters struct {

	// defaultRouteAction takes effect when none of the pathRules or routeRules match. The load balancer performs
	// advanced routing actions like URL rewrites, header transformations, etc. prior to forwarding the request
	// to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set.
	// Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
	// Only one of defaultRouteAction or defaultUrlRedirect must be set.
	// Structure is documented below.
	DefaultRouteAction []PathMatcherDefaultRouteActionInitParameters `json:"defaultRouteAction,omitempty" tf:"default_route_action,omitempty"`

	// The backend service or backend bucket to use when none of the given paths match.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.BackendBucket
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	DefaultService *string `json:"defaultService,omitempty" tf:"default_service,omitempty"`

	// Reference to a BackendBucket in compute to populate defaultService.
	// +kubebuilder:validation:Optional
	DefaultServiceRef *v1.Reference `json:"defaultServiceRef,omitempty" tf:"-"`

	// Selector for a BackendBucket in compute to populate defaultService.
	// +kubebuilder:validation:Optional
	DefaultServiceSelector *v1.Selector `json:"defaultServiceSelector,omitempty" tf:"-"`

	// When none of the specified hostRules match, the request is redirected to a URL specified
	// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
	// defaultRouteAction must not be set.
	// Structure is documented below.
	DefaultURLRedirect []URLMapPathMatcherDefaultURLRedirectInitParameters `json:"defaultUrlRedirect,omitempty" tf:"default_url_redirect,omitempty"`

	// An optional description of this resource. Provide this property when you create
	// the resource.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Specifies changes to request and response headers that need to take effect for
	// the selected backendService. HeaderAction specified here are applied after the
	// matching HttpRouteRule HeaderAction and before the HeaderAction in the UrlMap
	// Structure is documented below.
	HeaderAction []PathMatcherHeaderActionInitParameters `json:"headerAction,omitempty" tf:"header_action,omitempty"`

	// The name to which this PathMatcher is referred by the HostRule.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The list of path rules. Use this list instead of routeRules when routing based
	// on simple path matching is all that's required. The order by which path rules
	// are specified does not matter. Matches are always done on the longest-path-first
	// basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
	// irrespective of the order in which those paths appear in this list. Within a
	// given pathMatcher, only one of pathRules or routeRules must be set.
	// Structure is documented below.
	PathRule []PathMatcherPathRuleInitParameters `json:"pathRule,omitempty" tf:"path_rule,omitempty"`

	// The list of ordered HTTP route rules. Use this list instead of pathRules when
	// advanced route matching and routing actions are desired. The order of specifying
	// routeRules matters: the first rule that matches will cause its specified routing
	// action to take effect. Within a given pathMatcher, only one of pathRules or
	// routeRules must be set. routeRules are not supported in UrlMaps intended for
	// External load balancers.
	// Structure is documented below.
	RouteRules []PathMatcherRouteRulesInitParameters `json:"routeRules,omitempty" tf:"route_rules,omitempty"`
}

type URLMapPathMatcherObservation struct {

	// defaultRouteAction takes effect when none of the pathRules or routeRules match. The load balancer performs
	// advanced routing actions like URL rewrites, header transformations, etc. prior to forwarding the request
	// to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set.
	// Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
	// Only one of defaultRouteAction or defaultUrlRedirect must be set.
	// Structure is documented below.
	DefaultRouteAction []PathMatcherDefaultRouteActionObservation `json:"defaultRouteAction,omitempty" tf:"default_route_action,omitempty"`

	// The backend service or backend bucket to use when none of the given paths match.
	DefaultService *string `json:"defaultService,omitempty" tf:"default_service,omitempty"`

	// When none of the specified hostRules match, the request is redirected to a URL specified
	// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
	// defaultRouteAction must not be set.
	// Structure is documented below.
	DefaultURLRedirect []URLMapPathMatcherDefaultURLRedirectObservation `json:"defaultUrlRedirect,omitempty" tf:"default_url_redirect,omitempty"`

	// An optional description of this resource. Provide this property when you create
	// the resource.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Specifies changes to request and response headers that need to take effect for
	// the selected backendService. HeaderAction specified here are applied after the
	// matching HttpRouteRule HeaderAction and before the HeaderAction in the UrlMap
	// Structure is documented below.
	HeaderAction []PathMatcherHeaderActionObservation `json:"headerAction,omitempty" tf:"header_action,omitempty"`

	// The name to which this PathMatcher is referred by the HostRule.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The list of path rules. Use this list instead of routeRules when routing based
	// on simple path matching is all that's required. The order by which path rules
	// are specified does not matter. Matches are always done on the longest-path-first
	// basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
	// irrespective of the order in which those paths appear in this list. Within a
	// given pathMatcher, only one of pathRules or routeRules must be set.
	// Structure is documented below.
	PathRule []PathMatcherPathRuleObservation `json:"pathRule,omitempty" tf:"path_rule,omitempty"`

	// The list of ordered HTTP route rules. Use this list instead of pathRules when
	// advanced route matching and routing actions are desired. The order of specifying
	// routeRules matters: the first rule that matches will cause its specified routing
	// action to take effect. Within a given pathMatcher, only one of pathRules or
	// routeRules must be set. routeRules are not supported in UrlMaps intended for
	// External load balancers.
	// Structure is documented below.
	RouteRules []PathMatcherRouteRulesObservation `json:"routeRules,omitempty" tf:"route_rules,omitempty"`
}

type URLMapPathMatcherParameters struct {

	// defaultRouteAction takes effect when none of the pathRules or routeRules match. The load balancer performs
	// advanced routing actions like URL rewrites, header transformations, etc. prior to forwarding the request
	// to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set.
	// Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
	// Only one of defaultRouteAction or defaultUrlRedirect must be set.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	DefaultRouteAction []PathMatcherDefaultRouteActionParameters `json:"defaultRouteAction,omitempty" tf:"default_route_action,omitempty"`

	// The backend service or backend bucket to use when none of the given paths match.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.BackendBucket
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	DefaultService *string `json:"defaultService,omitempty" tf:"default_service,omitempty"`

	// Reference to a BackendBucket in compute to populate defaultService.
	// +kubebuilder:validation:Optional
	DefaultServiceRef *v1.Reference `json:"defaultServiceRef,omitempty" tf:"-"`

	// Selector for a BackendBucket in compute to populate defaultService.
	// +kubebuilder:validation:Optional
	DefaultServiceSelector *v1.Selector `json:"defaultServiceSelector,omitempty" tf:"-"`

	// When none of the specified hostRules match, the request is redirected to a URL specified
	// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
	// defaultRouteAction must not be set.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	DefaultURLRedirect []URLMapPathMatcherDefaultURLRedirectParameters `json:"defaultUrlRedirect,omitempty" tf:"default_url_redirect,omitempty"`

	// An optional description of this resource. Provide this property when you create
	// the resource.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Specifies changes to request and response headers that need to take effect for
	// the selected backendService. HeaderAction specified here are applied after the
	// matching HttpRouteRule HeaderAction and before the HeaderAction in the UrlMap
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	HeaderAction []PathMatcherHeaderActionParameters `json:"headerAction,omitempty" tf:"header_action,omitempty"`

	// The name to which this PathMatcher is referred by the HostRule.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// The list of path rules. Use this list instead of routeRules when routing based
	// on simple path matching is all that's required. The order by which path rules
	// are specified does not matter. Matches are always done on the longest-path-first
	// basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
	// irrespective of the order in which those paths appear in this list. Within a
	// given pathMatcher, only one of pathRules or routeRules must be set.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	PathRule []PathMatcherPathRuleParameters `json:"pathRule,omitempty" tf:"path_rule,omitempty"`

	// The list of ordered HTTP route rules. Use this list instead of pathRules when
	// advanced route matching and routing actions are desired. The order of specifying
	// routeRules matters: the first rule that matches will cause its specified routing
	// action to take effect. Within a given pathMatcher, only one of pathRules or
	// routeRules must be set. routeRules are not supported in UrlMaps intended for
	// External load balancers.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	RouteRules []PathMatcherRouteRulesParameters `json:"routeRules,omitempty" tf:"route_rules,omitempty"`
}

type URLMapTestInitParameters struct {

	// Description of this test case.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Host portion of the URL.
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// Path portion of the URL.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// The backend service or backend bucket link that should be matched by this test.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.BackendBucket
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// Reference to a BackendBucket in compute to populate service.
	// +kubebuilder:validation:Optional
	ServiceRef *v1.Reference `json:"serviceRef,omitempty" tf:"-"`

	// Selector for a BackendBucket in compute to populate service.
	// +kubebuilder:validation:Optional
	ServiceSelector *v1.Selector `json:"serviceSelector,omitempty" tf:"-"`
}

type URLMapTestObservation struct {

	// Description of this test case.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Host portion of the URL.
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// Path portion of the URL.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// The backend service or backend bucket link that should be matched by this test.
	Service *string `json:"service,omitempty" tf:"service,omitempty"`
}

type URLMapTestParameters struct {

	// Description of this test case.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Host portion of the URL.
	// +kubebuilder:validation:Optional
	Host *string `json:"host" tf:"host,omitempty"`

	// Path portion of the URL.
	// +kubebuilder:validation:Optional
	Path *string `json:"path" tf:"path,omitempty"`

	// The backend service or backend bucket link that should be matched by this test.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.BackendBucket
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// Reference to a BackendBucket in compute to populate service.
	// +kubebuilder:validation:Optional
	ServiceRef *v1.Reference `json:"serviceRef,omitempty" tf:"-"`

	// Selector for a BackendBucket in compute to populate service.
	// +kubebuilder:validation:Optional
	ServiceSelector *v1.Selector `json:"serviceSelector,omitempty" tf:"-"`
}

// URLMapSpec defines the desired state of URLMap
type URLMapSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     URLMapParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider URLMapInitParameters `json:"initProvider,omitempty"`
}

// URLMapStatus defines the observed state of URLMap.
type URLMapStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        URLMapObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// URLMap is the Schema for the URLMaps API. UrlMaps are used to route requests to a backend service based on rules that you define for the host and path of an incoming URL.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcp}
type URLMap struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              URLMapSpec   `json:"spec"`
	Status            URLMapStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// URLMapList contains a list of URLMaps
type URLMapList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []URLMap `json:"items"`
}

// Repository type metadata.
var (
	URLMap_Kind             = "URLMap"
	URLMap_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: URLMap_Kind}.String()
	URLMap_KindAPIVersion   = URLMap_Kind + "." + CRDGroupVersion.String()
	URLMap_GroupVersionKind = CRDGroupVersion.WithKind(URLMap_Kind)
)

func init() {
	SchemeBuilder.Register(&URLMap{}, &URLMapList{})
}
