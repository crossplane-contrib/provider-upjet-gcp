// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
	v2 "github.com/crossplane/crossplane-runtime/v2/apis/common/v2"
)

type CommonNameInitParameters struct {

	// The TLS Common Name string of the certificate.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`

	// Indicates whether the cert should be matched against as a wildcard cert.
	WildcardMatch *bool `json:"wildcardMatch,omitempty" tf:"wildcard_match,omitempty"`
}

type CommonNameObservation struct {

	// The TLS Common Name string of the certificate.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`

	// Indicates whether the cert should be matched against as a wildcard cert.
	WildcardMatch *bool `json:"wildcardMatch,omitempty" tf:"wildcard_match,omitempty"`
}

type CommonNameParameters struct {

	// The TLS Common Name string of the certificate.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`

	// Indicates whether the cert should be matched against as a wildcard cert.
	// +kubebuilder:validation:Optional
	WildcardMatch *bool `json:"wildcardMatch,omitempty" tf:"wildcard_match,omitempty"`
}

type SSlInfoInitParameters struct {

	// The SSL/TLS cipher suites to be used. For programmable proxies, it must be one of the cipher suite names listed in: http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#ciphersuites. For configurable proxies, it must follow the configuration specified in: https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration. This setting has no effect for configurable proxies when negotiating TLS 1.3.
	Ciphers []*string `json:"ciphers,omitempty" tf:"ciphers,omitempty"`

	// Enables two-way TLS.
	ClientAuthEnabled *bool `json:"clientAuthEnabled,omitempty" tf:"client_auth_enabled,omitempty"`

	// The TLS Common Name of the certificate.
	// Structure is documented below.
	CommonName *CommonNameInitParameters `json:"commonName,omitempty" tf:"common_name,omitempty"`

	// Enables TLS. If false, neither one-way nor two-way TLS will be enabled.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// If true, TLS is strictly enforced.
	Enforce *bool `json:"enforce,omitempty" tf:"enforce,omitempty"`

	// If true, Edge ignores TLS certificate errors. Valid when configuring TLS for target servers and target endpoints, and when configuring virtual hosts that use 2-way TLS. When used with a target endpoint/target server, if the backend system uses SNI and returns a cert with a subject Distinguished Name (DN) that does not match the hostname, there is no way to ignore the error and the connection fails.
	IgnoreValidationErrors *bool `json:"ignoreValidationErrors,omitempty" tf:"ignore_validation_errors,omitempty"`

	// Required if clientAuthEnabled is true. The resource ID for the alias containing the private key and cert.
	KeyAlias *string `json:"keyAlias,omitempty" tf:"key_alias,omitempty"`

	// Required if clientAuthEnabled is true. The resource ID of the keystore.
	KeyStore *string `json:"keyStore,omitempty" tf:"key_store,omitempty"`

	// The TLS versioins to be used.
	Protocols []*string `json:"protocols,omitempty" tf:"protocols,omitempty"`

	// The resource ID of the truststore.
	TrustStore *string `json:"trustStore,omitempty" tf:"trust_store,omitempty"`
}

type SSlInfoObservation struct {

	// The SSL/TLS cipher suites to be used. For programmable proxies, it must be one of the cipher suite names listed in: http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#ciphersuites. For configurable proxies, it must follow the configuration specified in: https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration. This setting has no effect for configurable proxies when negotiating TLS 1.3.
	Ciphers []*string `json:"ciphers,omitempty" tf:"ciphers,omitempty"`

	// Enables two-way TLS.
	ClientAuthEnabled *bool `json:"clientAuthEnabled,omitempty" tf:"client_auth_enabled,omitempty"`

	// The TLS Common Name of the certificate.
	// Structure is documented below.
	CommonName *CommonNameObservation `json:"commonName,omitempty" tf:"common_name,omitempty"`

	// Enables TLS. If false, neither one-way nor two-way TLS will be enabled.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// If true, TLS is strictly enforced.
	Enforce *bool `json:"enforce,omitempty" tf:"enforce,omitempty"`

	// If true, Edge ignores TLS certificate errors. Valid when configuring TLS for target servers and target endpoints, and when configuring virtual hosts that use 2-way TLS. When used with a target endpoint/target server, if the backend system uses SNI and returns a cert with a subject Distinguished Name (DN) that does not match the hostname, there is no way to ignore the error and the connection fails.
	IgnoreValidationErrors *bool `json:"ignoreValidationErrors,omitempty" tf:"ignore_validation_errors,omitempty"`

	// Required if clientAuthEnabled is true. The resource ID for the alias containing the private key and cert.
	KeyAlias *string `json:"keyAlias,omitempty" tf:"key_alias,omitempty"`

	// Required if clientAuthEnabled is true. The resource ID of the keystore.
	KeyStore *string `json:"keyStore,omitempty" tf:"key_store,omitempty"`

	// The TLS versioins to be used.
	Protocols []*string `json:"protocols,omitempty" tf:"protocols,omitempty"`

	// The resource ID of the truststore.
	TrustStore *string `json:"trustStore,omitempty" tf:"trust_store,omitempty"`
}

type SSlInfoParameters struct {

	// The SSL/TLS cipher suites to be used. For programmable proxies, it must be one of the cipher suite names listed in: http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#ciphersuites. For configurable proxies, it must follow the configuration specified in: https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration. This setting has no effect for configurable proxies when negotiating TLS 1.3.
	// +kubebuilder:validation:Optional
	Ciphers []*string `json:"ciphers,omitempty" tf:"ciphers,omitempty"`

	// Enables two-way TLS.
	// +kubebuilder:validation:Optional
	ClientAuthEnabled *bool `json:"clientAuthEnabled,omitempty" tf:"client_auth_enabled,omitempty"`

	// The TLS Common Name of the certificate.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	CommonName *CommonNameParameters `json:"commonName,omitempty" tf:"common_name,omitempty"`

	// Enables TLS. If false, neither one-way nor two-way TLS will be enabled.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled" tf:"enabled,omitempty"`

	// If true, TLS is strictly enforced.
	// +kubebuilder:validation:Optional
	Enforce *bool `json:"enforce,omitempty" tf:"enforce,omitempty"`

	// If true, Edge ignores TLS certificate errors. Valid when configuring TLS for target servers and target endpoints, and when configuring virtual hosts that use 2-way TLS. When used with a target endpoint/target server, if the backend system uses SNI and returns a cert with a subject Distinguished Name (DN) that does not match the hostname, there is no way to ignore the error and the connection fails.
	// +kubebuilder:validation:Optional
	IgnoreValidationErrors *bool `json:"ignoreValidationErrors,omitempty" tf:"ignore_validation_errors,omitempty"`

	// Required if clientAuthEnabled is true. The resource ID for the alias containing the private key and cert.
	// +kubebuilder:validation:Optional
	KeyAlias *string `json:"keyAlias,omitempty" tf:"key_alias,omitempty"`

	// Required if clientAuthEnabled is true. The resource ID of the keystore.
	// +kubebuilder:validation:Optional
	KeyStore *string `json:"keyStore,omitempty" tf:"key_store,omitempty"`

	// The TLS versioins to be used.
	// +kubebuilder:validation:Optional
	Protocols []*string `json:"protocols,omitempty" tf:"protocols,omitempty"`

	// The resource ID of the truststore.
	// +kubebuilder:validation:Optional
	TrustStore *string `json:"trustStore,omitempty" tf:"trust_store,omitempty"`
}

type TargetServerInitParameters struct {

	// A human-readable description of this TargetServer.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The host name this target connects to. Value must be a valid hostname as described by RFC-1123.
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// Enabling/disabling a TargetServer is useful when TargetServers are used in load balancing configurations, and one or more TargetServers need to taken out of rotation periodically. Defaults to true.
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// The port number this target connects to on the given host. Value must be between 1 and 65535, inclusive.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// Immutable. The protocol used by this TargetServer.
	// Possible values are: HTTP, HTTP2, GRPC_TARGET, GRPC, EXTERNAL_CALLOUT.
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// Specifies TLS configuration info for this TargetServer. The JSON name is sSLInfo for legacy/backwards compatibility reasons -- Edge originally supported SSL, and the name is still used for TLS configuration.
	// Structure is documented below.
	SSlInfo *SSlInfoInitParameters `json:"sSlInfo,omitempty" tf:"s_sl_info,omitempty"`
}

type TargetServerObservation struct {

	// A human-readable description of this TargetServer.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The Apigee environment group associated with the Apigee environment,
	// in the format organizations/{{org_name}}/environments/{{env_name}}.
	EnvID *string `json:"envId,omitempty" tf:"env_id,omitempty"`

	// The host name this target connects to. Value must be a valid hostname as described by RFC-1123.
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// an identifier for the resource with format {{env_id}}/targetservers/{{name}}
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Enabling/disabling a TargetServer is useful when TargetServers are used in load balancing configurations, and one or more TargetServers need to taken out of rotation periodically. Defaults to true.
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// The port number this target connects to on the given host. Value must be between 1 and 65535, inclusive.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// Immutable. The protocol used by this TargetServer.
	// Possible values are: HTTP, HTTP2, GRPC_TARGET, GRPC, EXTERNAL_CALLOUT.
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// Specifies TLS configuration info for this TargetServer. The JSON name is sSLInfo for legacy/backwards compatibility reasons -- Edge originally supported SSL, and the name is still used for TLS configuration.
	// Structure is documented below.
	SSlInfo *SSlInfoObservation `json:"sSlInfo,omitempty" tf:"s_sl_info,omitempty"`
}

type TargetServerParameters struct {

	// A human-readable description of this TargetServer.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The Apigee environment group associated with the Apigee environment,
	// in the format organizations/{{org_name}}/environments/{{env_name}}.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/namespaced/apigee/v1beta1.Environment
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	EnvID *string `json:"envId,omitempty" tf:"env_id,omitempty"`

	// Reference to a Environment in apigee to populate envId.
	// +kubebuilder:validation:Optional
	EnvIDRef *v1.NamespacedReference `json:"envIdRef,omitempty" tf:"-"`

	// Selector for a Environment in apigee to populate envId.
	// +kubebuilder:validation:Optional
	EnvIDSelector *v1.NamespacedSelector `json:"envIdSelector,omitempty" tf:"-"`

	// The host name this target connects to. Value must be a valid hostname as described by RFC-1123.
	// +kubebuilder:validation:Optional
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// Enabling/disabling a TargetServer is useful when TargetServers are used in load balancing configurations, and one or more TargetServers need to taken out of rotation periodically. Defaults to true.
	// +kubebuilder:validation:Optional
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// The port number this target connects to on the given host. Value must be between 1 and 65535, inclusive.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// Immutable. The protocol used by this TargetServer.
	// Possible values are: HTTP, HTTP2, GRPC_TARGET, GRPC, EXTERNAL_CALLOUT.
	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// Specifies TLS configuration info for this TargetServer. The JSON name is sSLInfo for legacy/backwards compatibility reasons -- Edge originally supported SSL, and the name is still used for TLS configuration.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	SSlInfo *SSlInfoParameters `json:"sSlInfo,omitempty" tf:"s_sl_info,omitempty"`
}

// TargetServerSpec defines the desired state of TargetServer
type TargetServerSpec struct {
	v2.ManagedResourceSpec `json:",inline"`
	ForProvider            TargetServerParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider TargetServerInitParameters `json:"initProvider,omitempty"`
}

// TargetServerStatus defines the observed state of TargetServer.
type TargetServerStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        TargetServerObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// TargetServer is the Schema for the TargetServers API. TargetServer configuration.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Namespaced,categories={crossplane,managed,gcp}
type TargetServer struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.host) || (has(self.initProvider) && has(self.initProvider.host))",message="spec.forProvider.host is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.port) || (has(self.initProvider) && has(self.initProvider.port))",message="spec.forProvider.port is a required parameter"
	Spec   TargetServerSpec   `json:"spec"`
	Status TargetServerStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// TargetServerList contains a list of TargetServers
type TargetServerList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []TargetServer `json:"items"`
}

// Repository type metadata.
var (
	TargetServer_Kind             = "TargetServer"
	TargetServer_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: TargetServer_Kind}.String()
	TargetServer_KindAPIVersion   = TargetServer_Kind + "." + CRDGroupVersion.String()
	TargetServer_GroupVersionKind = CRDGroupVersion.WithKind(TargetServer_Kind)
)

func init() {
	SchemeBuilder.Register(&TargetServer{}, &TargetServerList{})
}
