// SPDX-FileCopyrightText: 2023 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by upjet. DO NOT EDIT.

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AvailabilityInitParameters struct {

	// Whether an availability SLI is enabled or not. Must be set to true. Defaults to true.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type AvailabilityObservation struct {

	// Whether an availability SLI is enabled or not. Must be set to true. Defaults to true.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type AvailabilityParameters struct {

	// Whether an availability SLI is enabled or not. Must be set to true. Defaults to true.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type BasicSliInitParameters struct {

	// Availability based SLI, dervied from count of requests made to this service that return successfully.
	// Structure is documented below.
	Availability []AvailabilityInitParameters `json:"availability,omitempty" tf:"availability,omitempty"`

	// Parameters for a latency threshold SLI.
	// Structure is documented below.
	Latency []LatencyInitParameters `json:"latency,omitempty" tf:"latency,omitempty"`

	// An optional set of locations to which this SLI is relevant.
	// Telemetry from other locations will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// locations in which the Service has activity. For service types
	// that don't support breaking down by location, setting this
	// field will result in an error.
	// +listType=set
	Location []*string `json:"location,omitempty" tf:"location,omitempty"`

	// An optional set of RPCs to which this SLI is relevant.
	// Telemetry from other methods will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// the Service's methods. For service types that don't support
	// breaking down by method, setting this field will result in an
	// error.
	// +listType=set
	Method []*string `json:"method,omitempty" tf:"method,omitempty"`

	// The set of API versions to which this SLI is relevant.
	// Telemetry from other API versions will not be used to
	// calculate performance for this SLI. If omitted,
	// this SLI applies to all API versions. For service types
	// that don't support breaking down by version, setting this
	// field will result in an error.
	// +listType=set
	Version []*string `json:"version,omitempty" tf:"version,omitempty"`
}

type BasicSliObservation struct {

	// Availability based SLI, dervied from count of requests made to this service that return successfully.
	// Structure is documented below.
	Availability []AvailabilityObservation `json:"availability,omitempty" tf:"availability,omitempty"`

	// Parameters for a latency threshold SLI.
	// Structure is documented below.
	Latency []LatencyObservation `json:"latency,omitempty" tf:"latency,omitempty"`

	// An optional set of locations to which this SLI is relevant.
	// Telemetry from other locations will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// locations in which the Service has activity. For service types
	// that don't support breaking down by location, setting this
	// field will result in an error.
	// +listType=set
	Location []*string `json:"location,omitempty" tf:"location,omitempty"`

	// An optional set of RPCs to which this SLI is relevant.
	// Telemetry from other methods will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// the Service's methods. For service types that don't support
	// breaking down by method, setting this field will result in an
	// error.
	// +listType=set
	Method []*string `json:"method,omitempty" tf:"method,omitempty"`

	// The set of API versions to which this SLI is relevant.
	// Telemetry from other API versions will not be used to
	// calculate performance for this SLI. If omitted,
	// this SLI applies to all API versions. For service types
	// that don't support breaking down by version, setting this
	// field will result in an error.
	// +listType=set
	Version []*string `json:"version,omitempty" tf:"version,omitempty"`
}

type BasicSliParameters struct {

	// Availability based SLI, dervied from count of requests made to this service that return successfully.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Availability []AvailabilityParameters `json:"availability,omitempty" tf:"availability,omitempty"`

	// Parameters for a latency threshold SLI.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Latency []LatencyParameters `json:"latency,omitempty" tf:"latency,omitempty"`

	// An optional set of locations to which this SLI is relevant.
	// Telemetry from other locations will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// locations in which the Service has activity. For service types
	// that don't support breaking down by location, setting this
	// field will result in an error.
	// +kubebuilder:validation:Optional
	// +listType=set
	Location []*string `json:"location,omitempty" tf:"location,omitempty"`

	// An optional set of RPCs to which this SLI is relevant.
	// Telemetry from other methods will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// the Service's methods. For service types that don't support
	// breaking down by method, setting this field will result in an
	// error.
	// +kubebuilder:validation:Optional
	// +listType=set
	Method []*string `json:"method,omitempty" tf:"method,omitempty"`

	// The set of API versions to which this SLI is relevant.
	// Telemetry from other API versions will not be used to
	// calculate performance for this SLI. If omitted,
	// this SLI applies to all API versions. For service types
	// that don't support breaking down by version, setting this
	// field will result in an error.
	// +kubebuilder:validation:Optional
	// +listType=set
	Version []*string `json:"version,omitempty" tf:"version,omitempty"`
}

type BasicSliPerformanceAvailabilityInitParameters struct {

	// Whether an availability SLI is enabled or not. Must be set to true. Defaults to true.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type BasicSliPerformanceAvailabilityObservation struct {

	// Whether an availability SLI is enabled or not. Must be set to true. Defaults to true.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type BasicSliPerformanceAvailabilityParameters struct {

	// Whether an availability SLI is enabled or not. Must be set to true. Defaults to true.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type BasicSliPerformanceInitParameters struct {

	// Availability based SLI, dervied from count of requests made to this service that return successfully.
	// Structure is documented below.
	Availability []BasicSliPerformanceAvailabilityInitParameters `json:"availability,omitempty" tf:"availability,omitempty"`

	// Parameters for a latency threshold SLI.
	// Structure is documented below.
	Latency []BasicSliPerformanceLatencyInitParameters `json:"latency,omitempty" tf:"latency,omitempty"`

	// An optional set of locations to which this SLI is relevant.
	// Telemetry from other locations will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// locations in which the Service has activity. For service types
	// that don't support breaking down by location, setting this
	// field will result in an error.
	// +listType=set
	Location []*string `json:"location,omitempty" tf:"location,omitempty"`

	// An optional set of RPCs to which this SLI is relevant.
	// Telemetry from other methods will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// the Service's methods. For service types that don't support
	// breaking down by method, setting this field will result in an
	// error.
	// +listType=set
	Method []*string `json:"method,omitempty" tf:"method,omitempty"`

	// The set of API versions to which this SLI is relevant.
	// Telemetry from other API versions will not be used to
	// calculate performance for this SLI. If omitted,
	// this SLI applies to all API versions. For service types
	// that don't support breaking down by version, setting this
	// field will result in an error.
	// +listType=set
	Version []*string `json:"version,omitempty" tf:"version,omitempty"`
}

type BasicSliPerformanceLatencyInitParameters struct {

	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	Threshold *string `json:"threshold,omitempty" tf:"threshold,omitempty"`
}

type BasicSliPerformanceLatencyObservation struct {

	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	Threshold *string `json:"threshold,omitempty" tf:"threshold,omitempty"`
}

type BasicSliPerformanceLatencyParameters struct {

	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	// +kubebuilder:validation:Optional
	Threshold *string `json:"threshold" tf:"threshold,omitempty"`
}

type BasicSliPerformanceObservation struct {

	// Availability based SLI, dervied from count of requests made to this service that return successfully.
	// Structure is documented below.
	Availability []BasicSliPerformanceAvailabilityObservation `json:"availability,omitempty" tf:"availability,omitempty"`

	// Parameters for a latency threshold SLI.
	// Structure is documented below.
	Latency []BasicSliPerformanceLatencyObservation `json:"latency,omitempty" tf:"latency,omitempty"`

	// An optional set of locations to which this SLI is relevant.
	// Telemetry from other locations will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// locations in which the Service has activity. For service types
	// that don't support breaking down by location, setting this
	// field will result in an error.
	// +listType=set
	Location []*string `json:"location,omitempty" tf:"location,omitempty"`

	// An optional set of RPCs to which this SLI is relevant.
	// Telemetry from other methods will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// the Service's methods. For service types that don't support
	// breaking down by method, setting this field will result in an
	// error.
	// +listType=set
	Method []*string `json:"method,omitempty" tf:"method,omitempty"`

	// The set of API versions to which this SLI is relevant.
	// Telemetry from other API versions will not be used to
	// calculate performance for this SLI. If omitted,
	// this SLI applies to all API versions. For service types
	// that don't support breaking down by version, setting this
	// field will result in an error.
	// +listType=set
	Version []*string `json:"version,omitempty" tf:"version,omitempty"`
}

type BasicSliPerformanceParameters struct {

	// Availability based SLI, dervied from count of requests made to this service that return successfully.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Availability []BasicSliPerformanceAvailabilityParameters `json:"availability,omitempty" tf:"availability,omitempty"`

	// Parameters for a latency threshold SLI.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Latency []BasicSliPerformanceLatencyParameters `json:"latency,omitempty" tf:"latency,omitempty"`

	// An optional set of locations to which this SLI is relevant.
	// Telemetry from other locations will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// locations in which the Service has activity. For service types
	// that don't support breaking down by location, setting this
	// field will result in an error.
	// +kubebuilder:validation:Optional
	// +listType=set
	Location []*string `json:"location,omitempty" tf:"location,omitempty"`

	// An optional set of RPCs to which this SLI is relevant.
	// Telemetry from other methods will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// the Service's methods. For service types that don't support
	// breaking down by method, setting this field will result in an
	// error.
	// +kubebuilder:validation:Optional
	// +listType=set
	Method []*string `json:"method,omitempty" tf:"method,omitempty"`

	// The set of API versions to which this SLI is relevant.
	// Telemetry from other API versions will not be used to
	// calculate performance for this SLI. If omitted,
	// this SLI applies to all API versions. For service types
	// that don't support breaking down by version, setting this
	// field will result in an error.
	// +kubebuilder:validation:Optional
	// +listType=set
	Version []*string `json:"version,omitempty" tf:"version,omitempty"`
}

type DistributionCutInitParameters struct {

	// A TimeSeries monitoring filter
	// aggregating values to quantify the good service provided.
	// Must have ValueType = DISTRIBUTION and
	// MetricKind = DELTA or MetricKind = CUMULATIVE.
	DistributionFilter *string `json:"distributionFilter,omitempty" tf:"distribution_filter,omitempty"`

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	Range []RangeInitParameters `json:"range,omitempty" tf:"range,omitempty"`
}

type DistributionCutObservation struct {

	// A TimeSeries monitoring filter
	// aggregating values to quantify the good service provided.
	// Must have ValueType = DISTRIBUTION and
	// MetricKind = DELTA or MetricKind = CUMULATIVE.
	DistributionFilter *string `json:"distributionFilter,omitempty" tf:"distribution_filter,omitempty"`

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	Range []RangeObservation `json:"range,omitempty" tf:"range,omitempty"`
}

type DistributionCutParameters struct {

	// A TimeSeries monitoring filter
	// aggregating values to quantify the good service provided.
	// Must have ValueType = DISTRIBUTION and
	// MetricKind = DELTA or MetricKind = CUMULATIVE.
	// +kubebuilder:validation:Optional
	DistributionFilter *string `json:"distributionFilter" tf:"distribution_filter,omitempty"`

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Range []RangeParameters `json:"range" tf:"range,omitempty"`
}

type DistributionCutRangeInitParameters struct {

	// max value for the range (inclusive). If not given,
	// will be set to 0
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type DistributionCutRangeObservation struct {

	// max value for the range (inclusive). If not given,
	// will be set to 0
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type DistributionCutRangeParameters struct {

	// max value for the range (inclusive). If not given,
	// will be set to 0
	// +kubebuilder:validation:Optional
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	// +kubebuilder:validation:Optional
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type GoodTotalRatioInitParameters struct {

	// A TimeSeries monitoring filter
	// quantifying bad service provided, either demanded service that
	// was not provided or demanded service that was of inadequate
	// quality.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	BadServiceFilter *string `json:"badServiceFilter,omitempty" tf:"bad_service_filter,omitempty"`

	// A TimeSeries monitoring filter
	// quantifying good service provided.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	GoodServiceFilter *string `json:"goodServiceFilter,omitempty" tf:"good_service_filter,omitempty"`

	// A TimeSeries monitoring filter
	// quantifying total demanded service.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	TotalServiceFilter *string `json:"totalServiceFilter,omitempty" tf:"total_service_filter,omitempty"`
}

type GoodTotalRatioObservation struct {

	// A TimeSeries monitoring filter
	// quantifying bad service provided, either demanded service that
	// was not provided or demanded service that was of inadequate
	// quality.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	BadServiceFilter *string `json:"badServiceFilter,omitempty" tf:"bad_service_filter,omitempty"`

	// A TimeSeries monitoring filter
	// quantifying good service provided.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	GoodServiceFilter *string `json:"goodServiceFilter,omitempty" tf:"good_service_filter,omitempty"`

	// A TimeSeries monitoring filter
	// quantifying total demanded service.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	TotalServiceFilter *string `json:"totalServiceFilter,omitempty" tf:"total_service_filter,omitempty"`
}

type GoodTotalRatioParameters struct {

	// A TimeSeries monitoring filter
	// quantifying bad service provided, either demanded service that
	// was not provided or demanded service that was of inadequate
	// quality.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	// +kubebuilder:validation:Optional
	BadServiceFilter *string `json:"badServiceFilter,omitempty" tf:"bad_service_filter,omitempty"`

	// A TimeSeries monitoring filter
	// quantifying good service provided.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	// +kubebuilder:validation:Optional
	GoodServiceFilter *string `json:"goodServiceFilter,omitempty" tf:"good_service_filter,omitempty"`

	// A TimeSeries monitoring filter
	// quantifying total demanded service.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	// +kubebuilder:validation:Optional
	TotalServiceFilter *string `json:"totalServiceFilter,omitempty" tf:"total_service_filter,omitempty"`
}

type GoodTotalRatioThresholdInitParameters struct {

	// Basic SLI to evaluate to judge window quality.
	// Structure is documented below.
	BasicSliPerformance []BasicSliPerformanceInitParameters `json:"basicSliPerformance,omitempty" tf:"basic_sli_performance,omitempty"`

	// Request-based SLI to evaluate to judge window quality.
	// Structure is documented below.
	Performance []PerformanceInitParameters `json:"performance,omitempty" tf:"performance,omitempty"`

	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	Threshold *float64 `json:"threshold,omitempty" tf:"threshold,omitempty"`
}

type GoodTotalRatioThresholdObservation struct {

	// Basic SLI to evaluate to judge window quality.
	// Structure is documented below.
	BasicSliPerformance []BasicSliPerformanceObservation `json:"basicSliPerformance,omitempty" tf:"basic_sli_performance,omitempty"`

	// Request-based SLI to evaluate to judge window quality.
	// Structure is documented below.
	Performance []PerformanceObservation `json:"performance,omitempty" tf:"performance,omitempty"`

	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	Threshold *float64 `json:"threshold,omitempty" tf:"threshold,omitempty"`
}

type GoodTotalRatioThresholdParameters struct {

	// Basic SLI to evaluate to judge window quality.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	BasicSliPerformance []BasicSliPerformanceParameters `json:"basicSliPerformance,omitempty" tf:"basic_sli_performance,omitempty"`

	// Request-based SLI to evaluate to judge window quality.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Performance []PerformanceParameters `json:"performance,omitempty" tf:"performance,omitempty"`

	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	// +kubebuilder:validation:Optional
	Threshold *float64 `json:"threshold,omitempty" tf:"threshold,omitempty"`
}

type LatencyInitParameters struct {

	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	Threshold *string `json:"threshold,omitempty" tf:"threshold,omitempty"`
}

type LatencyObservation struct {

	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	Threshold *string `json:"threshold,omitempty" tf:"threshold,omitempty"`
}

type LatencyParameters struct {

	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	// +kubebuilder:validation:Optional
	Threshold *string `json:"threshold" tf:"threshold,omitempty"`
}

type MetricMeanInRangeInitParameters struct {

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	Range []MetricMeanInRangeRangeInitParameters `json:"range,omitempty" tf:"range,omitempty"`

	// A monitoring filter
	// specifying the TimeSeries to use for evaluating window
	// quality. The provided TimeSeries must have
	// ValueType = INT64 or ValueType = DOUBLE and
	// MetricKind = GAUGE.
	// Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	TimeSeries *string `json:"timeSeries,omitempty" tf:"time_series,omitempty"`
}

type MetricMeanInRangeObservation struct {

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	Range []MetricMeanInRangeRangeObservation `json:"range,omitempty" tf:"range,omitempty"`

	// A monitoring filter
	// specifying the TimeSeries to use for evaluating window
	// quality. The provided TimeSeries must have
	// ValueType = INT64 or ValueType = DOUBLE and
	// MetricKind = GAUGE.
	// Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	TimeSeries *string `json:"timeSeries,omitempty" tf:"time_series,omitempty"`
}

type MetricMeanInRangeParameters struct {

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Range []MetricMeanInRangeRangeParameters `json:"range" tf:"range,omitempty"`

	// A monitoring filter
	// specifying the TimeSeries to use for evaluating window
	// quality. The provided TimeSeries must have
	// ValueType = INT64 or ValueType = DOUBLE and
	// MetricKind = GAUGE.
	// Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// +kubebuilder:validation:Optional
	TimeSeries *string `json:"timeSeries" tf:"time_series,omitempty"`
}

type MetricMeanInRangeRangeInitParameters struct {

	// max value for the range (inclusive). If not given,
	// will be set to 0
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type MetricMeanInRangeRangeObservation struct {

	// max value for the range (inclusive). If not given,
	// will be set to 0
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type MetricMeanInRangeRangeParameters struct {

	// max value for the range (inclusive). If not given,
	// will be set to 0
	// +kubebuilder:validation:Optional
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	// +kubebuilder:validation:Optional
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type MetricSumInRangeInitParameters struct {

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	Range []MetricSumInRangeRangeInitParameters `json:"range,omitempty" tf:"range,omitempty"`

	// A monitoring filter
	// specifying the TimeSeries to use for evaluating window
	// quality. The provided TimeSeries must have
	// ValueType = INT64 or ValueType = DOUBLE and
	// MetricKind = GAUGE.
	// Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	TimeSeries *string `json:"timeSeries,omitempty" tf:"time_series,omitempty"`
}

type MetricSumInRangeObservation struct {

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	Range []MetricSumInRangeRangeObservation `json:"range,omitempty" tf:"range,omitempty"`

	// A monitoring filter
	// specifying the TimeSeries to use for evaluating window
	// quality. The provided TimeSeries must have
	// ValueType = INT64 or ValueType = DOUBLE and
	// MetricKind = GAUGE.
	// Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	TimeSeries *string `json:"timeSeries,omitempty" tf:"time_series,omitempty"`
}

type MetricSumInRangeParameters struct {

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Range []MetricSumInRangeRangeParameters `json:"range" tf:"range,omitempty"`

	// A monitoring filter
	// specifying the TimeSeries to use for evaluating window
	// quality. The provided TimeSeries must have
	// ValueType = INT64 or ValueType = DOUBLE and
	// MetricKind = GAUGE.
	// Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// +kubebuilder:validation:Optional
	TimeSeries *string `json:"timeSeries" tf:"time_series,omitempty"`
}

type MetricSumInRangeRangeInitParameters struct {

	// max value for the range (inclusive). If not given,
	// will be set to 0
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type MetricSumInRangeRangeObservation struct {

	// max value for the range (inclusive). If not given,
	// will be set to 0
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type MetricSumInRangeRangeParameters struct {

	// max value for the range (inclusive). If not given,
	// will be set to 0
	// +kubebuilder:validation:Optional
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	// +kubebuilder:validation:Optional
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type PerformanceDistributionCutInitParameters struct {

	// A TimeSeries monitoring filter
	// aggregating values to quantify the good service provided.
	// Must have ValueType = DISTRIBUTION and
	// MetricKind = DELTA or MetricKind = CUMULATIVE.
	DistributionFilter *string `json:"distributionFilter,omitempty" tf:"distribution_filter,omitempty"`

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	Range []DistributionCutRangeInitParameters `json:"range,omitempty" tf:"range,omitempty"`
}

type PerformanceDistributionCutObservation struct {

	// A TimeSeries monitoring filter
	// aggregating values to quantify the good service provided.
	// Must have ValueType = DISTRIBUTION and
	// MetricKind = DELTA or MetricKind = CUMULATIVE.
	DistributionFilter *string `json:"distributionFilter,omitempty" tf:"distribution_filter,omitempty"`

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	Range []DistributionCutRangeObservation `json:"range,omitempty" tf:"range,omitempty"`
}

type PerformanceDistributionCutParameters struct {

	// A TimeSeries monitoring filter
	// aggregating values to quantify the good service provided.
	// Must have ValueType = DISTRIBUTION and
	// MetricKind = DELTA or MetricKind = CUMULATIVE.
	// +kubebuilder:validation:Optional
	DistributionFilter *string `json:"distributionFilter" tf:"distribution_filter,omitempty"`

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Range []DistributionCutRangeParameters `json:"range" tf:"range,omitempty"`
}

type PerformanceGoodTotalRatioInitParameters struct {

	// A TimeSeries monitoring filter
	// quantifying bad service provided, either demanded service that
	// was not provided or demanded service that was of inadequate
	// quality.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	BadServiceFilter *string `json:"badServiceFilter,omitempty" tf:"bad_service_filter,omitempty"`

	// A TimeSeries monitoring filter
	// quantifying good service provided.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	GoodServiceFilter *string `json:"goodServiceFilter,omitempty" tf:"good_service_filter,omitempty"`

	// A TimeSeries monitoring filter
	// quantifying total demanded service.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	TotalServiceFilter *string `json:"totalServiceFilter,omitempty" tf:"total_service_filter,omitempty"`
}

type PerformanceGoodTotalRatioObservation struct {

	// A TimeSeries monitoring filter
	// quantifying bad service provided, either demanded service that
	// was not provided or demanded service that was of inadequate
	// quality.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	BadServiceFilter *string `json:"badServiceFilter,omitempty" tf:"bad_service_filter,omitempty"`

	// A TimeSeries monitoring filter
	// quantifying good service provided.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	GoodServiceFilter *string `json:"goodServiceFilter,omitempty" tf:"good_service_filter,omitempty"`

	// A TimeSeries monitoring filter
	// quantifying total demanded service.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	TotalServiceFilter *string `json:"totalServiceFilter,omitempty" tf:"total_service_filter,omitempty"`
}

type PerformanceGoodTotalRatioParameters struct {

	// A TimeSeries monitoring filter
	// quantifying bad service provided, either demanded service that
	// was not provided or demanded service that was of inadequate
	// quality.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	// +kubebuilder:validation:Optional
	BadServiceFilter *string `json:"badServiceFilter,omitempty" tf:"bad_service_filter,omitempty"`

	// A TimeSeries monitoring filter
	// quantifying good service provided.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	// +kubebuilder:validation:Optional
	GoodServiceFilter *string `json:"goodServiceFilter,omitempty" tf:"good_service_filter,omitempty"`

	// A TimeSeries monitoring filter
	// quantifying total demanded service.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	// +kubebuilder:validation:Optional
	TotalServiceFilter *string `json:"totalServiceFilter,omitempty" tf:"total_service_filter,omitempty"`
}

type PerformanceInitParameters struct {

	// Used when good_service is defined by a count of values aggregated in a
	// Distribution that fall into a good range. The total_service is the
	// total count of all values aggregated in the Distribution.
	// Defines a distribution TimeSeries filter and thresholds used for
	// measuring good service and total service.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	DistributionCut []PerformanceDistributionCutInitParameters `json:"distributionCut,omitempty" tf:"distribution_cut,omitempty"`

	// A means to compute a ratio of good_service to total_service.
	// Defines computing this ratio with two TimeSeries monitoring filters
	// Must specify exactly two of good, bad, and total service filters.
	// The relationship good_service + bad_service = total_service
	// will be assumed.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	GoodTotalRatio []PerformanceGoodTotalRatioInitParameters `json:"goodTotalRatio,omitempty" tf:"good_total_ratio,omitempty"`
}

type PerformanceObservation struct {

	// Used when good_service is defined by a count of values aggregated in a
	// Distribution that fall into a good range. The total_service is the
	// total count of all values aggregated in the Distribution.
	// Defines a distribution TimeSeries filter and thresholds used for
	// measuring good service and total service.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	DistributionCut []PerformanceDistributionCutObservation `json:"distributionCut,omitempty" tf:"distribution_cut,omitempty"`

	// A means to compute a ratio of good_service to total_service.
	// Defines computing this ratio with two TimeSeries monitoring filters
	// Must specify exactly two of good, bad, and total service filters.
	// The relationship good_service + bad_service = total_service
	// will be assumed.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	GoodTotalRatio []PerformanceGoodTotalRatioObservation `json:"goodTotalRatio,omitempty" tf:"good_total_ratio,omitempty"`
}

type PerformanceParameters struct {

	// Used when good_service is defined by a count of values aggregated in a
	// Distribution that fall into a good range. The total_service is the
	// total count of all values aggregated in the Distribution.
	// Defines a distribution TimeSeries filter and thresholds used for
	// measuring good service and total service.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	DistributionCut []PerformanceDistributionCutParameters `json:"distributionCut,omitempty" tf:"distribution_cut,omitempty"`

	// A means to compute a ratio of good_service to total_service.
	// Defines computing this ratio with two TimeSeries monitoring filters
	// Must specify exactly two of good, bad, and total service filters.
	// The relationship good_service + bad_service = total_service
	// will be assumed.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	GoodTotalRatio []PerformanceGoodTotalRatioParameters `json:"goodTotalRatio,omitempty" tf:"good_total_ratio,omitempty"`
}

type RangeInitParameters struct {

	// max value for the range (inclusive). If not given,
	// will be set to 0
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type RangeObservation struct {

	// max value for the range (inclusive). If not given,
	// will be set to 0
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type RangeParameters struct {

	// max value for the range (inclusive). If not given,
	// will be set to 0
	// +kubebuilder:validation:Optional
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	// +kubebuilder:validation:Optional
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type RequestBasedSliInitParameters struct {

	// Used when good_service is defined by a count of values aggregated in a
	// Distribution that fall into a good range. The total_service is the
	// total count of all values aggregated in the Distribution.
	// Defines a distribution TimeSeries filter and thresholds used for
	// measuring good service and total service.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	DistributionCut []DistributionCutInitParameters `json:"distributionCut,omitempty" tf:"distribution_cut,omitempty"`

	// A means to compute a ratio of good_service to total_service.
	// Defines computing this ratio with two TimeSeries monitoring filters
	// Must specify exactly two of good, bad, and total service filters.
	// The relationship good_service + bad_service = total_service
	// will be assumed.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	GoodTotalRatio []GoodTotalRatioInitParameters `json:"goodTotalRatio,omitempty" tf:"good_total_ratio,omitempty"`
}

type RequestBasedSliObservation struct {

	// Used when good_service is defined by a count of values aggregated in a
	// Distribution that fall into a good range. The total_service is the
	// total count of all values aggregated in the Distribution.
	// Defines a distribution TimeSeries filter and thresholds used for
	// measuring good service and total service.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	DistributionCut []DistributionCutObservation `json:"distributionCut,omitempty" tf:"distribution_cut,omitempty"`

	// A means to compute a ratio of good_service to total_service.
	// Defines computing this ratio with two TimeSeries monitoring filters
	// Must specify exactly two of good, bad, and total service filters.
	// The relationship good_service + bad_service = total_service
	// will be assumed.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	GoodTotalRatio []GoodTotalRatioObservation `json:"goodTotalRatio,omitempty" tf:"good_total_ratio,omitempty"`
}

type RequestBasedSliParameters struct {

	// Used when good_service is defined by a count of values aggregated in a
	// Distribution that fall into a good range. The total_service is the
	// total count of all values aggregated in the Distribution.
	// Defines a distribution TimeSeries filter and thresholds used for
	// measuring good service and total service.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	DistributionCut []DistributionCutParameters `json:"distributionCut,omitempty" tf:"distribution_cut,omitempty"`

	// A means to compute a ratio of good_service to total_service.
	// Defines computing this ratio with two TimeSeries monitoring filters
	// Must specify exactly two of good, bad, and total service filters.
	// The relationship good_service + bad_service = total_service
	// will be assumed.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	GoodTotalRatio []GoodTotalRatioParameters `json:"goodTotalRatio,omitempty" tf:"good_total_ratio,omitempty"`
}

type SLOInitParameters struct {

	// Basic Service-Level Indicator (SLI) on a well-known service type.
	// Performance will be computed on the basis of pre-defined metrics.
	// SLIs are used to measure and calculate the quality of the Service's
	// performance with respect to a single aspect of service quality.
	// Exactly one of the following must be set:
	// basic_sli, request_based_sli, windows_based_sli
	// Structure is documented below.
	BasicSli []BasicSliInitParameters `json:"basicSli,omitempty" tf:"basic_sli,omitempty"`

	// A calendar period, semantically "since the start of the current
	// ".
	// Possible values are: DAY, WEEK, FORTNIGHT, MONTH.
	CalendarPeriod *string `json:"calendarPeriod,omitempty" tf:"calendar_period,omitempty"`

	// Name used for UI elements listing this SLO.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// The fraction of service that must be good in order for this objective
	// to be met. 0 < goal <= 0.999
	Goal *float64 `json:"goal,omitempty" tf:"goal,omitempty"`

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// A request-based SLI defines a SLI for which atomic units of
	// service are counted directly.
	// A SLI describes a good service.
	// It is used to measure and calculate the quality of the Service's
	// performance with respect to a single aspect of service quality.
	// Exactly one of the following must be set:
	// basic_sli, request_based_sli, windows_based_sli
	// Structure is documented below.
	RequestBasedSli []RequestBasedSliInitParameters `json:"requestBasedSli,omitempty" tf:"request_based_sli,omitempty"`

	// A rolling time period, semantically "in the past X days".
	// Must be between 1 to 30 days, inclusive.
	RollingPeriodDays *float64 `json:"rollingPeriodDays,omitempty" tf:"rolling_period_days,omitempty"`

	// The id to use for this ServiceLevelObjective. If omitted, an id will be generated instead.
	SLOID *string `json:"sloId,omitempty" tf:"slo_id,omitempty"`

	// ID of the service to which this SLO belongs.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/monitoring/v1beta1.CustomService
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("service_id",false)
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// Reference to a CustomService in monitoring to populate service.
	// +kubebuilder:validation:Optional
	ServiceRef *v1.Reference `json:"serviceRef,omitempty" tf:"-"`

	// Selector for a CustomService in monitoring to populate service.
	// +kubebuilder:validation:Optional
	ServiceSelector *v1.Selector `json:"serviceSelector,omitempty" tf:"-"`

	// This field is intended to be used for organizing and identifying the AlertPolicy
	// objects.The field can contain up to 64 entries. Each key and value is limited
	// to 63 Unicode characters or 128 bytes, whichever is smaller. Labels and values
	// can contain only lowercase letters, numerals, underscores, and dashes. Keys
	// must begin with a letter.
	// +mapType=granular
	UserLabels map[string]*string `json:"userLabels,omitempty" tf:"user_labels,omitempty"`

	// A windows-based SLI defines the criteria for time windows.
	// good_service is defined based off the count of these time windows
	// for which the provided service was of good quality.
	// A SLI describes a good service. It is used to measure and calculate
	// the quality of the Service's performance with respect to a single
	// aspect of service quality.
	// Exactly one of the following must be set:
	// basic_sli, request_based_sli, windows_based_sli
	// Structure is documented below.
	WindowsBasedSli []WindowsBasedSliInitParameters `json:"windowsBasedSli,omitempty" tf:"windows_based_sli,omitempty"`
}

type SLOObservation struct {

	// Basic Service-Level Indicator (SLI) on a well-known service type.
	// Performance will be computed on the basis of pre-defined metrics.
	// SLIs are used to measure and calculate the quality of the Service's
	// performance with respect to a single aspect of service quality.
	// Exactly one of the following must be set:
	// basic_sli, request_based_sli, windows_based_sli
	// Structure is documented below.
	BasicSli []BasicSliObservation `json:"basicSli,omitempty" tf:"basic_sli,omitempty"`

	// A calendar period, semantically "since the start of the current
	// ".
	// Possible values are: DAY, WEEK, FORTNIGHT, MONTH.
	CalendarPeriod *string `json:"calendarPeriod,omitempty" tf:"calendar_period,omitempty"`

	// Name used for UI elements listing this SLO.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// The fraction of service that must be good in order for this objective
	// to be met. 0 < goal <= 0.999
	Goal *float64 `json:"goal,omitempty" tf:"goal,omitempty"`

	// an identifier for the resource with format {{name}}
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The full resource name for this service. The syntax is:
	// projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// A request-based SLI defines a SLI for which atomic units of
	// service are counted directly.
	// A SLI describes a good service.
	// It is used to measure and calculate the quality of the Service's
	// performance with respect to a single aspect of service quality.
	// Exactly one of the following must be set:
	// basic_sli, request_based_sli, windows_based_sli
	// Structure is documented below.
	RequestBasedSli []RequestBasedSliObservation `json:"requestBasedSli,omitempty" tf:"request_based_sli,omitempty"`

	// A rolling time period, semantically "in the past X days".
	// Must be between 1 to 30 days, inclusive.
	RollingPeriodDays *float64 `json:"rollingPeriodDays,omitempty" tf:"rolling_period_days,omitempty"`

	// The id to use for this ServiceLevelObjective. If omitted, an id will be generated instead.
	SLOID *string `json:"sloId,omitempty" tf:"slo_id,omitempty"`

	// ID of the service to which this SLO belongs.
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// This field is intended to be used for organizing and identifying the AlertPolicy
	// objects.The field can contain up to 64 entries. Each key and value is limited
	// to 63 Unicode characters or 128 bytes, whichever is smaller. Labels and values
	// can contain only lowercase letters, numerals, underscores, and dashes. Keys
	// must begin with a letter.
	// +mapType=granular
	UserLabels map[string]*string `json:"userLabels,omitempty" tf:"user_labels,omitempty"`

	// A windows-based SLI defines the criteria for time windows.
	// good_service is defined based off the count of these time windows
	// for which the provided service was of good quality.
	// A SLI describes a good service. It is used to measure and calculate
	// the quality of the Service's performance with respect to a single
	// aspect of service quality.
	// Exactly one of the following must be set:
	// basic_sli, request_based_sli, windows_based_sli
	// Structure is documented below.
	WindowsBasedSli []WindowsBasedSliObservation `json:"windowsBasedSli,omitempty" tf:"windows_based_sli,omitempty"`
}

type SLOParameters struct {

	// Basic Service-Level Indicator (SLI) on a well-known service type.
	// Performance will be computed on the basis of pre-defined metrics.
	// SLIs are used to measure and calculate the quality of the Service's
	// performance with respect to a single aspect of service quality.
	// Exactly one of the following must be set:
	// basic_sli, request_based_sli, windows_based_sli
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	BasicSli []BasicSliParameters `json:"basicSli,omitempty" tf:"basic_sli,omitempty"`

	// A calendar period, semantically "since the start of the current
	// ".
	// Possible values are: DAY, WEEK, FORTNIGHT, MONTH.
	// +kubebuilder:validation:Optional
	CalendarPeriod *string `json:"calendarPeriod,omitempty" tf:"calendar_period,omitempty"`

	// Name used for UI elements listing this SLO.
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// The fraction of service that must be good in order for this objective
	// to be met. 0 < goal <= 0.999
	// +kubebuilder:validation:Optional
	Goal *float64 `json:"goal,omitempty" tf:"goal,omitempty"`

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	// +kubebuilder:validation:Optional
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// A request-based SLI defines a SLI for which atomic units of
	// service are counted directly.
	// A SLI describes a good service.
	// It is used to measure and calculate the quality of the Service's
	// performance with respect to a single aspect of service quality.
	// Exactly one of the following must be set:
	// basic_sli, request_based_sli, windows_based_sli
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	RequestBasedSli []RequestBasedSliParameters `json:"requestBasedSli,omitempty" tf:"request_based_sli,omitempty"`

	// A rolling time period, semantically "in the past X days".
	// Must be between 1 to 30 days, inclusive.
	// +kubebuilder:validation:Optional
	RollingPeriodDays *float64 `json:"rollingPeriodDays,omitempty" tf:"rolling_period_days,omitempty"`

	// The id to use for this ServiceLevelObjective. If omitted, an id will be generated instead.
	// +kubebuilder:validation:Optional
	SLOID *string `json:"sloId,omitempty" tf:"slo_id,omitempty"`

	// ID of the service to which this SLO belongs.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/monitoring/v1beta1.CustomService
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("service_id",false)
	// +kubebuilder:validation:Optional
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// Reference to a CustomService in monitoring to populate service.
	// +kubebuilder:validation:Optional
	ServiceRef *v1.Reference `json:"serviceRef,omitempty" tf:"-"`

	// Selector for a CustomService in monitoring to populate service.
	// +kubebuilder:validation:Optional
	ServiceSelector *v1.Selector `json:"serviceSelector,omitempty" tf:"-"`

	// This field is intended to be used for organizing and identifying the AlertPolicy
	// objects.The field can contain up to 64 entries. Each key and value is limited
	// to 63 Unicode characters or 128 bytes, whichever is smaller. Labels and values
	// can contain only lowercase letters, numerals, underscores, and dashes. Keys
	// must begin with a letter.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	UserLabels map[string]*string `json:"userLabels,omitempty" tf:"user_labels,omitempty"`

	// A windows-based SLI defines the criteria for time windows.
	// good_service is defined based off the count of these time windows
	// for which the provided service was of good quality.
	// A SLI describes a good service. It is used to measure and calculate
	// the quality of the Service's performance with respect to a single
	// aspect of service quality.
	// Exactly one of the following must be set:
	// basic_sli, request_based_sli, windows_based_sli
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	WindowsBasedSli []WindowsBasedSliParameters `json:"windowsBasedSli,omitempty" tf:"windows_based_sli,omitempty"`
}

type WindowsBasedSliInitParameters struct {

	// A TimeSeries monitoring filter
	// with ValueType = BOOL. The window is good if any true values
	// appear in the window. One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	GoodBadMetricFilter *string `json:"goodBadMetricFilter,omitempty" tf:"good_bad_metric_filter,omitempty"`

	// Criterion that describes a window as good if its performance is
	// high enough. One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// Structure is documented below.
	GoodTotalRatioThreshold []GoodTotalRatioThresholdInitParameters `json:"goodTotalRatioThreshold,omitempty" tf:"good_total_ratio_threshold,omitempty"`

	// Criterion that describes a window as good if the metric's value
	// is in a good range, averaged across returned streams.
	// One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// Average value X of time_series should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	MetricMeanInRange []MetricMeanInRangeInitParameters `json:"metricMeanInRange,omitempty" tf:"metric_mean_in_range,omitempty"`

	// Criterion that describes a window as good if the metric's value
	// is in a good range, summed across returned streams.
	// Summed value X of time_series should satisfy
	// range.min <= X <= range.max for a good window.
	// One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// Structure is documented below.
	MetricSumInRange []MetricSumInRangeInitParameters `json:"metricSumInRange,omitempty" tf:"metric_sum_in_range,omitempty"`

	// Duration over which window quality is evaluated, given as a
	// duration string "{X}s" representing X seconds. Must be an
	// integer fraction of a day and at least 60s.
	WindowPeriod *string `json:"windowPeriod,omitempty" tf:"window_period,omitempty"`
}

type WindowsBasedSliObservation struct {

	// A TimeSeries monitoring filter
	// with ValueType = BOOL. The window is good if any true values
	// appear in the window. One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	GoodBadMetricFilter *string `json:"goodBadMetricFilter,omitempty" tf:"good_bad_metric_filter,omitempty"`

	// Criterion that describes a window as good if its performance is
	// high enough. One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// Structure is documented below.
	GoodTotalRatioThreshold []GoodTotalRatioThresholdObservation `json:"goodTotalRatioThreshold,omitempty" tf:"good_total_ratio_threshold,omitempty"`

	// Criterion that describes a window as good if the metric's value
	// is in a good range, averaged across returned streams.
	// One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// Average value X of time_series should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	MetricMeanInRange []MetricMeanInRangeObservation `json:"metricMeanInRange,omitempty" tf:"metric_mean_in_range,omitempty"`

	// Criterion that describes a window as good if the metric's value
	// is in a good range, summed across returned streams.
	// Summed value X of time_series should satisfy
	// range.min <= X <= range.max for a good window.
	// One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// Structure is documented below.
	MetricSumInRange []MetricSumInRangeObservation `json:"metricSumInRange,omitempty" tf:"metric_sum_in_range,omitempty"`

	// Duration over which window quality is evaluated, given as a
	// duration string "{X}s" representing X seconds. Must be an
	// integer fraction of a day and at least 60s.
	WindowPeriod *string `json:"windowPeriod,omitempty" tf:"window_period,omitempty"`
}

type WindowsBasedSliParameters struct {

	// A TimeSeries monitoring filter
	// with ValueType = BOOL. The window is good if any true values
	// appear in the window. One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// +kubebuilder:validation:Optional
	GoodBadMetricFilter *string `json:"goodBadMetricFilter,omitempty" tf:"good_bad_metric_filter,omitempty"`

	// Criterion that describes a window as good if its performance is
	// high enough. One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	GoodTotalRatioThreshold []GoodTotalRatioThresholdParameters `json:"goodTotalRatioThreshold,omitempty" tf:"good_total_ratio_threshold,omitempty"`

	// Criterion that describes a window as good if the metric's value
	// is in a good range, averaged across returned streams.
	// One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// Average value X of time_series should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	MetricMeanInRange []MetricMeanInRangeParameters `json:"metricMeanInRange,omitempty" tf:"metric_mean_in_range,omitempty"`

	// Criterion that describes a window as good if the metric's value
	// is in a good range, summed across returned streams.
	// Summed value X of time_series should satisfy
	// range.min <= X <= range.max for a good window.
	// One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	MetricSumInRange []MetricSumInRangeParameters `json:"metricSumInRange,omitempty" tf:"metric_sum_in_range,omitempty"`

	// Duration over which window quality is evaluated, given as a
	// duration string "{X}s" representing X seconds. Must be an
	// integer fraction of a day and at least 60s.
	// +kubebuilder:validation:Optional
	WindowPeriod *string `json:"windowPeriod,omitempty" tf:"window_period,omitempty"`
}

// SLOSpec defines the desired state of SLO
type SLOSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     SLOParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider SLOInitParameters `json:"initProvider,omitempty"`
}

// SLOStatus defines the observed state of SLO.
type SLOStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        SLOObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// SLO is the Schema for the SLOs API. A Service-Level Objective (SLO) describes the level of desired good service.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcp},path=sloes
type SLO struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.goal) || (has(self.initProvider) && has(self.initProvider.goal))",message="spec.forProvider.goal is a required parameter"
	Spec   SLOSpec   `json:"spec"`
	Status SLOStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// SLOList contains a list of SLOs
type SLOList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SLO `json:"items"`
}

// Repository type metadata.
var (
	SLO_Kind             = "SLO"
	SLO_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: SLO_Kind}.String()
	SLO_KindAPIVersion   = SLO_Kind + "." + CRDGroupVersion.String()
	SLO_GroupVersionKind = CRDGroupVersion.WithKind(SLO_Kind)
)

func init() {
	SchemeBuilder.Register(&SLO{}, &SLOList{})
}
