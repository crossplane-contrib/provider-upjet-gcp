// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AvailabilityInitParameters struct {

	// Whether an availability SLI is enabled or not. Must be set to true. Defaults to true.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type AvailabilityObservation struct {

	// Whether an availability SLI is enabled or not. Must be set to true. Defaults to true.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type AvailabilityParameters struct {

	// Whether an availability SLI is enabled or not. Must be set to true. Defaults to true.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type BasicSliInitParameters struct {

	// Availability based SLI, dervied from count of requests made to this service that return successfully.
	// Structure is documented below.
	Availability []AvailabilityInitParameters `json:"availability,omitempty" tf:"availability,omitempty"`

	// Parameters for a latency threshold SLI.
	// Structure is documented below.
	Latency []LatencyInitParameters `json:"latency,omitempty" tf:"latency,omitempty"`

	// An optional set of locations to which this SLI is relevant.
	// Telemetry from other locations will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// locations in which the Service has activity. For service types
	// that don't support breaking down by location, setting this
	// field will result in an error.
	// +listType=set
	Location []*string `json:"location,omitempty" tf:"location,omitempty"`

	// An optional set of RPCs to which this SLI is relevant.
	// Telemetry from other methods will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// the Service's methods. For service types that don't support
	// breaking down by method, setting this field will result in an
	// error.
	// +listType=set
	Method []*string `json:"method,omitempty" tf:"method,omitempty"`

	// The set of API versions to which this SLI is relevant.
	// Telemetry from other API versions will not be used to
	// calculate performance for this SLI. If omitted,
	// this SLI applies to all API versions. For service types
	// that don't support breaking down by version, setting this
	// field will result in an error.
	// +listType=set
	Version []*string `json:"version,omitempty" tf:"version,omitempty"`
}

type BasicSliObservation struct {

	// Availability based SLI, dervied from count of requests made to this service that return successfully.
	// Structure is documented below.
	Availability []AvailabilityObservation `json:"availability,omitempty" tf:"availability,omitempty"`

	// Parameters for a latency threshold SLI.
	// Structure is documented below.
	Latency []LatencyObservation `json:"latency,omitempty" tf:"latency,omitempty"`

	// An optional set of locations to which this SLI is relevant.
	// Telemetry from other locations will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// locations in which the Service has activity. For service types
	// that don't support breaking down by location, setting this
	// field will result in an error.
	// +listType=set
	Location []*string `json:"location,omitempty" tf:"location,omitempty"`

	// An optional set of RPCs to which this SLI is relevant.
	// Telemetry from other methods will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// the Service's methods. For service types that don't support
	// breaking down by method, setting this field will result in an
	// error.
	// +listType=set
	Method []*string `json:"method,omitempty" tf:"method,omitempty"`

	// The set of API versions to which this SLI is relevant.
	// Telemetry from other API versions will not be used to
	// calculate performance for this SLI. If omitted,
	// this SLI applies to all API versions. For service types
	// that don't support breaking down by version, setting this
	// field will result in an error.
	// +listType=set
	Version []*string `json:"version,omitempty" tf:"version,omitempty"`
}

type BasicSliParameters struct {

	// Availability based SLI, dervied from count of requests made to this service that return successfully.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Availability []AvailabilityParameters `json:"availability,omitempty" tf:"availability,omitempty"`

	// Parameters for a latency threshold SLI.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Latency []LatencyParameters `json:"latency,omitempty" tf:"latency,omitempty"`

	// An optional set of locations to which this SLI is relevant.
	// Telemetry from other locations will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// locations in which the Service has activity. For service types
	// that don't support breaking down by location, setting this
	// field will result in an error.
	// +kubebuilder:validation:Optional
	// +listType=set
	Location []*string `json:"location,omitempty" tf:"location,omitempty"`

	// An optional set of RPCs to which this SLI is relevant.
	// Telemetry from other methods will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// the Service's methods. For service types that don't support
	// breaking down by method, setting this field will result in an
	// error.
	// +kubebuilder:validation:Optional
	// +listType=set
	Method []*string `json:"method,omitempty" tf:"method,omitempty"`

	// The set of API versions to which this SLI is relevant.
	// Telemetry from other API versions will not be used to
	// calculate performance for this SLI. If omitted,
	// this SLI applies to all API versions. For service types
	// that don't support breaking down by version, setting this
	// field will result in an error.
	// +kubebuilder:validation:Optional
	// +listType=set
	Version []*string `json:"version,omitempty" tf:"version,omitempty"`
}

type BasicSliPerformanceAvailabilityInitParameters struct {

	// Whether an availability SLI is enabled or not. Must be set to true. Defaults to true.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type BasicSliPerformanceAvailabilityObservation struct {

	// Whether an availability SLI is enabled or not. Must be set to true. Defaults to true.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type BasicSliPerformanceAvailabilityParameters struct {

	// Whether an availability SLI is enabled or not. Must be set to true. Defaults to true.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type BasicSliPerformanceInitParameters struct {

	// Availability based SLI, dervied from count of requests made to this service that return successfully.
	// Structure is documented below.
	Availability []BasicSliPerformanceAvailabilityInitParameters `json:"availability,omitempty" tf:"availability,omitempty"`

	// Parameters for a latency threshold SLI.
	// Structure is documented below.
	Latency []BasicSliPerformanceLatencyInitParameters `json:"latency,omitempty" tf:"latency,omitempty"`

	// An optional set of locations to which this SLI is relevant.
	// Telemetry from other locations will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// locations in which the Service has activity. For service types
	// that don't support breaking down by location, setting this
	// field will result in an error.
	// +listType=set
	Location []*string `json:"location,omitempty" tf:"location,omitempty"`

	// An optional set of RPCs to which this SLI is relevant.
	// Telemetry from other methods will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// the Service's methods. For service types that don't support
	// breaking down by method, setting this field will result in an
	// error.
	// +listType=set
	Method []*string `json:"method,omitempty" tf:"method,omitempty"`

	// The set of API versions to which this SLI is relevant.
	// Telemetry from other API versions will not be used to
	// calculate performance for this SLI. If omitted,
	// this SLI applies to all API versions. For service types
	// that don't support breaking down by version, setting this
	// field will result in an error.
	// +listType=set
	Version []*string `json:"version,omitempty" tf:"version,omitempty"`
}

type BasicSliPerformanceLatencyInitParameters struct {

	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	Threshold *string `json:"threshold,omitempty" tf:"threshold,omitempty"`
}

type BasicSliPerformanceLatencyObservation struct {

	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	Threshold *string `json:"threshold,omitempty" tf:"threshold,omitempty"`
}

type BasicSliPerformanceLatencyParameters struct {

	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	// +kubebuilder:validation:Optional
	Threshold *string `json:"threshold" tf:"threshold,omitempty"`
}

type BasicSliPerformanceObservation struct {

	// Availability based SLI, dervied from count of requests made to this service that return successfully.
	// Structure is documented below.
	Availability []BasicSliPerformanceAvailabilityObservation `json:"availability,omitempty" tf:"availability,omitempty"`

	// Parameters for a latency threshold SLI.
	// Structure is documented below.
	Latency []BasicSliPerformanceLatencyObservation `json:"latency,omitempty" tf:"latency,omitempty"`

	// An optional set of locations to which this SLI is relevant.
	// Telemetry from other locations will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// locations in which the Service has activity. For service types
	// that don't support breaking down by location, setting this
	// field will result in an error.
	// +listType=set
	Location []*string `json:"location,omitempty" tf:"location,omitempty"`

	// An optional set of RPCs to which this SLI is relevant.
	// Telemetry from other methods will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// the Service's methods. For service types that don't support
	// breaking down by method, setting this field will result in an
	// error.
	// +listType=set
	Method []*string `json:"method,omitempty" tf:"method,omitempty"`

	// The set of API versions to which this SLI is relevant.
	// Telemetry from other API versions will not be used to
	// calculate performance for this SLI. If omitted,
	// this SLI applies to all API versions. For service types
	// that don't support breaking down by version, setting this
	// field will result in an error.
	// +listType=set
	Version []*string `json:"version,omitempty" tf:"version,omitempty"`
}

type BasicSliPerformanceParameters struct {

	// Availability based SLI, dervied from count of requests made to this service that return successfully.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Availability []BasicSliPerformanceAvailabilityParameters `json:"availability,omitempty" tf:"availability,omitempty"`

	// Parameters for a latency threshold SLI.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Latency []BasicSliPerformanceLatencyParameters `json:"latency,omitempty" tf:"latency,omitempty"`

	// An optional set of locations to which this SLI is relevant.
	// Telemetry from other locations will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// locations in which the Service has activity. For service types
	// that don't support breaking down by location, setting this
	// field will result in an error.
	// +kubebuilder:validation:Optional
	// +listType=set
	Location []*string `json:"location,omitempty" tf:"location,omitempty"`

	// An optional set of RPCs to which this SLI is relevant.
	// Telemetry from other methods will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// the Service's methods. For service types that don't support
	// breaking down by method, setting this field will result in an
	// error.
	// +kubebuilder:validation:Optional
	// +listType=set
	Method []*string `json:"method,omitempty" tf:"method,omitempty"`

	// The set of API versions to which this SLI is relevant.
	// Telemetry from other API versions will not be used to
	// calculate performance for this SLI. If omitted,
	// this SLI applies to all API versions. For service types
	// that don't support breaking down by version, setting this
	// field will result in an error.
	// +kubebuilder:validation:Optional
	// +listType=set
	Version []*string `json:"version,omitempty" tf:"version,omitempty"`
}

type DistributionCutInitParameters struct {

	// A TimeSeries monitoring filter
	// aggregating values to quantify the good service provided.
	// Must have ValueType = DISTRIBUTION and
	// MetricKind = DELTA or MetricKind = CUMULATIVE.
	DistributionFilter *string `json:"distributionFilter,omitempty" tf:"distribution_filter,omitempty"`

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	Range []RangeInitParameters `json:"range,omitempty" tf:"range,omitempty"`
}

type DistributionCutObservation struct {

	// A TimeSeries monitoring filter
	// aggregating values to quantify the good service provided.
	// Must have ValueType = DISTRIBUTION and
	// MetricKind = DELTA or MetricKind = CUMULATIVE.
	DistributionFilter *string `json:"distributionFilter,omitempty" tf:"distribution_filter,omitempty"`

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	Range []RangeObservation `json:"range,omitempty" tf:"range,omitempty"`
}

type DistributionCutParameters struct {

	// A TimeSeries monitoring filter
	// aggregating values to quantify the good service provided.
	// Must have ValueType = DISTRIBUTION and
	// MetricKind = DELTA or MetricKind = CUMULATIVE.
	// +kubebuilder:validation:Optional
	DistributionFilter *string `json:"distributionFilter" tf:"distribution_filter,omitempty"`

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Range []RangeParameters `json:"range" tf:"range,omitempty"`
}

type DistributionCutRangeInitParameters struct {

	// max value for the range (inclusive). If not given,
	// will be set to 0
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type DistributionCutRangeObservation struct {

	// max value for the range (inclusive). If not given,
	// will be set to 0
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type DistributionCutRangeParameters struct {

	// max value for the range (inclusive). If not given,
	// will be set to 0
	// +kubebuilder:validation:Optional
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	// +kubebuilder:validation:Optional
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type GoodTotalRatioInitParameters struct {

	// A TimeSeries monitoring filter
	// quantifying bad service provided, either demanded service that
	// was not provided or demanded service that was of inadequate
	// quality.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	BadServiceFilter *string `json:"badServiceFilter,omitempty" tf:"bad_service_filter,omitempty"`

	// A TimeSeries monitoring filter
	// quantifying good service provided.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	GoodServiceFilter *string `json:"goodServiceFilter,omitempty" tf:"good_service_filter,omitempty"`

	// A TimeSeries monitoring filter
	// quantifying total demanded service.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	TotalServiceFilter *string `json:"totalServiceFilter,omitempty" tf:"total_service_filter,omitempty"`
}

type GoodTotalRatioObservation struct {

	// A TimeSeries monitoring filter
	// quantifying bad service provided, either demanded service that
	// was not provided or demanded service that was of inadequate
	// quality.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	BadServiceFilter *string `json:"badServiceFilter,omitempty" tf:"bad_service_filter,omitempty"`

	// A TimeSeries monitoring filter
	// quantifying good service provided.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	GoodServiceFilter *string `json:"goodServiceFilter,omitempty" tf:"good_service_filter,omitempty"`

	// A TimeSeries monitoring filter
	// quantifying total demanded service.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	TotalServiceFilter *string `json:"totalServiceFilter,omitempty" tf:"total_service_filter,omitempty"`
}

type GoodTotalRatioParameters struct {

	// A TimeSeries monitoring filter
	// quantifying bad service provided, either demanded service that
	// was not provided or demanded service that was of inadequate
	// quality.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	// +kubebuilder:validation:Optional
	BadServiceFilter *string `json:"badServiceFilter,omitempty" tf:"bad_service_filter,omitempty"`

	// A TimeSeries monitoring filter
	// quantifying good service provided.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	// +kubebuilder:validation:Optional
	GoodServiceFilter *string `json:"goodServiceFilter,omitempty" tf:"good_service_filter,omitempty"`

	// A TimeSeries monitoring filter
	// quantifying total demanded service.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	// +kubebuilder:validation:Optional
	TotalServiceFilter *string `json:"totalServiceFilter,omitempty" tf:"total_service_filter,omitempty"`
}

type GoodTotalRatioThresholdInitParameters struct {

	// Basic SLI to evaluate to judge window quality.
	// Structure is documented below.
	BasicSliPerformance []BasicSliPerformanceInitParameters `json:"basicSliPerformance,omitempty" tf:"basic_sli_performance,omitempty"`

	// Request-based SLI to evaluate to judge window quality.
	// Structure is documented below.
	Performance []PerformanceInitParameters `json:"performance,omitempty" tf:"performance,omitempty"`

	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	Threshold *float64 `json:"threshold,omitempty" tf:"threshold,omitempty"`
}

type GoodTotalRatioThresholdObservation struct {

	// Basic SLI to evaluate to judge window quality.
	// Structure is documented below.
	BasicSliPerformance []BasicSliPerformanceObservation `json:"basicSliPerformance,omitempty" tf:"basic_sli_performance,omitempty"`

	// Request-based SLI to evaluate to judge window quality.
	// Structure is documented below.
	Performance []PerformanceObservation `json:"performance,omitempty" tf:"performance,omitempty"`

	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	Threshold *float64 `json:"threshold,omitempty" tf:"threshold,omitempty"`
}

type GoodTotalRatioThresholdParameters struct {

	// Basic SLI to evaluate to judge window quality.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	BasicSliPerformance []BasicSliPerformanceParameters `json:"basicSliPerformance,omitempty" tf:"basic_sli_performance,omitempty"`

	// Request-based SLI to evaluate to judge window quality.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Performance []PerformanceParameters `json:"performance,omitempty" tf:"performance,omitempty"`

	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	// +kubebuilder:validation:Optional
	Threshold *float64 `json:"threshold,omitempty" tf:"threshold,omitempty"`
}

type LatencyInitParameters struct {

	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	Threshold *string `json:"threshold,omitempty" tf:"threshold,omitempty"`
}

type LatencyObservation struct {

	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	Threshold *string `json:"threshold,omitempty" tf:"threshold,omitempty"`
}

type LatencyParameters struct {

	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	// +kubebuilder:validation:Optional
	Threshold *string `json:"threshold" tf:"threshold,omitempty"`
}

type MetricMeanInRangeInitParameters struct {

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	Range []MetricMeanInRangeRangeInitParameters `json:"range,omitempty" tf:"range,omitempty"`

	// A monitoring filter
	// specifying the TimeSeries to use for evaluating window
	// quality. The provided TimeSeries must have
	// ValueType = INT64 or ValueType = DOUBLE and
	// MetricKind = GAUGE.
	// Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	TimeSeries *string `json:"timeSeries,omitempty" tf:"time_series,omitempty"`
}

type MetricMeanInRangeObservation struct {

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	Range []MetricMeanInRangeRangeObservation `json:"range,omitempty" tf:"range,omitempty"`

	// A monitoring filter
	// specifying the TimeSeries to use for evaluating window
	// quality. The provided TimeSeries must have
	// ValueType = INT64 or ValueType = DOUBLE and
	// MetricKind = GAUGE.
	// Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	TimeSeries *string `json:"timeSeries,omitempty" tf:"time_series,omitempty"`
}

type MetricMeanInRangeParameters struct {

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Range []MetricMeanInRangeRangeParameters `json:"range" tf:"range,omitempty"`

	// A monitoring filter
	// specifying the TimeSeries to use for evaluating window
	// quality. The provided TimeSeries must have
	// ValueType = INT64 or ValueType = DOUBLE and
	// MetricKind = GAUGE.
	// Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// +kubebuilder:validation:Optional
	TimeSeries *string `json:"timeSeries" tf:"time_series,omitempty"`
}

type MetricMeanInRangeRangeInitParameters struct {

	// max value for the range (inclusive). If not given,
	// will be set to 0
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type MetricMeanInRangeRangeObservation struct {

	// max value for the range (inclusive). If not given,
	// will be set to 0
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type MetricMeanInRangeRangeParameters struct {

	// max value for the range (inclusive). If not given,
	// will be set to 0
	// +kubebuilder:validation:Optional
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	// +kubebuilder:validation:Optional
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type MetricSumInRangeInitParameters struct {

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	Range []MetricSumInRangeRangeInitParameters `json:"range,omitempty" tf:"range,omitempty"`

	// A monitoring filter
	// specifying the TimeSeries to use for evaluating window
	// quality. The provided TimeSeries must have
	// ValueType = INT64 or ValueType = DOUBLE and
	// MetricKind = GAUGE.
	// Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	TimeSeries *string `json:"timeSeries,omitempty" tf:"time_series,omitempty"`
}

type MetricSumInRangeObservation struct {

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	Range []MetricSumInRangeRangeObservation `json:"range,omitempty" tf:"range,omitempty"`

	// A monitoring filter
	// specifying the TimeSeries to use for evaluating window
	// quality. The provided TimeSeries must have
	// ValueType = INT64 or ValueType = DOUBLE and
	// MetricKind = GAUGE.
	// Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	TimeSeries *string `json:"timeSeries,omitempty" tf:"time_series,omitempty"`
}

type MetricSumInRangeParameters struct {

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Range []MetricSumInRangeRangeParameters `json:"range" tf:"range,omitempty"`

	// A monitoring filter
	// specifying the TimeSeries to use for evaluating window
	// quality. The provided TimeSeries must have
	// ValueType = INT64 or ValueType = DOUBLE and
	// MetricKind = GAUGE.
	// Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// +kubebuilder:validation:Optional
	TimeSeries *string `json:"timeSeries" tf:"time_series,omitempty"`
}

type MetricSumInRangeRangeInitParameters struct {

	// max value for the range (inclusive). If not given,
	// will be set to 0
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type MetricSumInRangeRangeObservation struct {

	// max value for the range (inclusive). If not given,
	// will be set to 0
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type MetricSumInRangeRangeParameters struct {

	// max value for the range (inclusive). If not given,
	// will be set to 0
	// +kubebuilder:validation:Optional
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	// +kubebuilder:validation:Optional
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type PerformanceDistributionCutInitParameters struct {

	// A TimeSeries monitoring filter
	// aggregating values to quantify the good service provided.
	// Must have ValueType = DISTRIBUTION and
	// MetricKind = DELTA or MetricKind = CUMULATIVE.
	DistributionFilter *string `json:"distributionFilter,omitempty" tf:"distribution_filter,omitempty"`

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	Range []DistributionCutRangeInitParameters `json:"range,omitempty" tf:"range,omitempty"`
}

type PerformanceDistributionCutObservation struct {

	// A TimeSeries monitoring filter
	// aggregating values to quantify the good service provided.
	// Must have ValueType = DISTRIBUTION and
	// MetricKind = DELTA or MetricKind = CUMULATIVE.
	DistributionFilter *string `json:"distributionFilter,omitempty" tf:"distribution_filter,omitempty"`

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	Range []DistributionCutRangeObservation `json:"range,omitempty" tf:"range,omitempty"`
}

type PerformanceDistributionCutParameters struct {

	// A TimeSeries monitoring filter
	// aggregating values to quantify the good service provided.
	// Must have ValueType = DISTRIBUTION and
	// MetricKind = DELTA or MetricKind = CUMULATIVE.
	// +kubebuilder:validation:Optional
	DistributionFilter *string `json:"distributionFilter" tf:"distribution_filter,omitempty"`

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Range []DistributionCutRangeParameters `json:"range" tf:"range,omitempty"`
}

type PerformanceGoodTotalRatioInitParameters struct {

	// A TimeSeries monitoring filter
	// quantifying bad service provided, either demanded service that
	// was not provided or demanded service that was of inadequate
	// quality.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	BadServiceFilter *string `json:"badServiceFilter,omitempty" tf:"bad_service_filter,omitempty"`

	// A TimeSeries monitoring filter
	// quantifying good service provided.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	GoodServiceFilter *string `json:"goodServiceFilter,omitempty" tf:"good_service_filter,omitempty"`

	// A TimeSeries monitoring filter
	// quantifying total demanded service.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	TotalServiceFilter *string `json:"totalServiceFilter,omitempty" tf:"total_service_filter,omitempty"`
}

type PerformanceGoodTotalRatioObservation struct {

	// A TimeSeries monitoring filter
	// quantifying bad service provided, either demanded service that
	// was not provided or demanded service that was of inadequate
	// quality.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	BadServiceFilter *string `json:"badServiceFilter,omitempty" tf:"bad_service_filter,omitempty"`

	// A TimeSeries monitoring filter
	// quantifying good service provided.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	GoodServiceFilter *string `json:"goodServiceFilter,omitempty" tf:"good_service_filter,omitempty"`

	// A TimeSeries monitoring filter
	// quantifying total demanded service.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	TotalServiceFilter *string `json:"totalServiceFilter,omitempty" tf:"total_service_filter,omitempty"`
}

type PerformanceGoodTotalRatioParameters struct {

	// A TimeSeries monitoring filter
	// quantifying bad service provided, either demanded service that
	// was not provided or demanded service that was of inadequate
	// quality.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	// +kubebuilder:validation:Optional
	BadServiceFilter *string `json:"badServiceFilter,omitempty" tf:"bad_service_filter,omitempty"`

	// A TimeSeries monitoring filter
	// quantifying good service provided.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	// +kubebuilder:validation:Optional
	GoodServiceFilter *string `json:"goodServiceFilter,omitempty" tf:"good_service_filter,omitempty"`

	// A TimeSeries monitoring filter
	// quantifying total demanded service.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	// +kubebuilder:validation:Optional
	TotalServiceFilter *string `json:"totalServiceFilter,omitempty" tf:"total_service_filter,omitempty"`
}

type PerformanceInitParameters struct {

	// Used when good_service is defined by a count of values aggregated in a
	// Distribution that fall into a good range. The total_service is the
	// total count of all values aggregated in the Distribution.
	// Defines a distribution TimeSeries filter and thresholds used for
	// measuring good service and total service.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	DistributionCut []PerformanceDistributionCutInitParameters `json:"distributionCut,omitempty" tf:"distribution_cut,omitempty"`

	// A means to compute a ratio of good_service to total_service.
	// Defines computing this ratio with two TimeSeries monitoring filters
	// Must specify exactly two of good, bad, and total service filters.
	// The relationship good_service + bad_service = total_service
	// will be assumed.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	GoodTotalRatio []PerformanceGoodTotalRatioInitParameters `json:"goodTotalRatio,omitempty" tf:"good_total_ratio,omitempty"`
}

type PerformanceObservation struct {

	// Used when good_service is defined by a count of values aggregated in a
	// Distribution that fall into a good range. The total_service is the
	// total count of all values aggregated in the Distribution.
	// Defines a distribution TimeSeries filter and thresholds used for
	// measuring good service and total service.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	DistributionCut []PerformanceDistributionCutObservation `json:"distributionCut,omitempty" tf:"distribution_cut,omitempty"`

	// A means to compute a ratio of good_service to total_service.
	// Defines computing this ratio with two TimeSeries monitoring filters
	// Must specify exactly two of good, bad, and total service filters.
	// The relationship good_service + bad_service = total_service
	// will be assumed.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	GoodTotalRatio []PerformanceGoodTotalRatioObservation `json:"goodTotalRatio,omitempty" tf:"good_total_ratio,omitempty"`
}

type PerformanceParameters struct {

	// Used when good_service is defined by a count of values aggregated in a
	// Distribution that fall into a good range. The total_service is the
	// total count of all values aggregated in the Distribution.
	// Defines a distribution TimeSeries filter and thresholds used for
	// measuring good service and total service.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	DistributionCut []PerformanceDistributionCutParameters `json:"distributionCut,omitempty" tf:"distribution_cut,omitempty"`

	// A means to compute a ratio of good_service to total_service.
	// Defines computing this ratio with two TimeSeries monitoring filters
	// Must specify exactly two of good, bad, and total service filters.
	// The relationship good_service + bad_service = total_service
	// will be assumed.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	GoodTotalRatio []PerformanceGoodTotalRatioParameters `json:"goodTotalRatio,omitempty" tf:"good_total_ratio,omitempty"`
}

type RangeInitParameters struct {

	// max value for the range (inclusive). If not given,
	// will be set to 0
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type RangeObservation struct {

	// max value for the range (inclusive). If not given,
	// will be set to 0
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type RangeParameters struct {

	// max value for the range (inclusive). If not given,
	// will be set to 0
	// +kubebuilder:validation:Optional
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	// +kubebuilder:validation:Optional
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type RequestBasedSliInitParameters struct {

	// Used when good_service is defined by a count of values aggregated in a
	// Distribution that fall into a good range. The total_service is the
	// total count of all values aggregated in the Distribution.
	// Defines a distribution TimeSeries filter and thresholds used for
	// measuring good service and total service.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	DistributionCut []DistributionCutInitParameters `json:"distributionCut,omitempty" tf:"distribution_cut,omitempty"`

	// A means to compute a ratio of good_service to total_service.
	// Defines computing this ratio with two TimeSeries monitoring filters
	// Must specify exactly two of good, bad, and total service filters.
	// The relationship good_service + bad_service = total_service
	// will be assumed.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	GoodTotalRatio []GoodTotalRatioInitParameters `json:"goodTotalRatio,omitempty" tf:"good_total_ratio,omitempty"`
}

type RequestBasedSliObservation struct {

	// Used when good_service is defined by a count of values aggregated in a
	// Distribution that fall into a good range. The total_service is the
	// total count of all values aggregated in the Distribution.
	// Defines a distribution TimeSeries filter and thresholds used for
	// measuring good service and total service.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	DistributionCut []DistributionCutObservation `json:"distributionCut,omitempty" tf:"distribution_cut,omitempty"`

	// A means to compute a ratio of good_service to total_service.
	// Defines computing this ratio with two TimeSeries monitoring filters
	// Must specify exactly two of good, bad, and total service filters.
	// The relationship good_service + bad_service = total_service
	// will be assumed.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	GoodTotalRatio []GoodTotalRatioObservation `json:"goodTotalRatio,omitempty" tf:"good_total_ratio,omitempty"`
}

type RequestBasedSliParameters struct {

	// Used when good_service is defined by a count of values aggregated in a
	// Distribution that fall into a good range. The total_service is the
	// total count of all values aggregated in the Distribution.
	// Defines a distribution TimeSeries filter and thresholds used for
	// measuring good service and total service.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	DistributionCut []DistributionCutParameters `json:"distributionCut,omitempty" tf:"distribution_cut,omitempty"`

	// A means to compute a ratio of good_service to total_service.
	// Defines computing this ratio with two TimeSeries monitoring filters
	// Must specify exactly two of good, bad, and total service filters.
	// The relationship good_service + bad_service = total_service
	// will be assumed.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	GoodTotalRatio []GoodTotalRatioParameters `json:"goodTotalRatio,omitempty" tf:"good_total_ratio,omitempty"`
}

type SLOInitParameters struct {

	// Basic Service-Level Indicator (SLI) on a well-known service type.
	// Performance will be computed on the basis of pre-defined metrics.
	// SLIs are used to measure and calculate the quality of the Service's
	// performance with respect to a single aspect of service quality.
	// Exactly one of the following must be set:
	// basic_sli, request_based_sli, windows_based_sli
	// Structure is documented below.
	BasicSli []BasicSliInitParameters `json:"basicSli,omitempty" tf:"basic_sli,omitempty"`

	// A calendar period, semantically "since the start of the current
	// ".
	// Possible values are: DAY, WEEK, FORTNIGHT, MONTH.
	CalendarPeriod *string `json:"calendarPeriod,omitempty" tf:"calendar_period,omitempty"`

	// Name used for UI elements listing this SLO.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// The fraction of service that must be good in order for this objective
	// to be met. 0 < goal <= 0.999
	Goal *float64 `json:"goal,omitempty" tf:"goal,omitempty"`

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// A request-based SLI defines a SLI for which atomic units of
	// service are counted directly.
	// A SLI describes a good service.
	// It is used to measure and calculate the quality of the Service's
	// performance with respect to a single aspect of service quality.
	// Exactly one of the following must be set:
	// basic_sli, request_based_sli, windows_based_sli
	// Structure is documented below.
	RequestBasedSli []RequestBasedSliInitParameters `json:"requestBasedSli,omitempty" tf:"request_based_sli,omitempty"`

	// A rolling time period, semantically "in the past X days".
	// Must be between 1 to 30 days, inclusive.
	RollingPeriodDays *float64 `json:"rollingPeriodDays,omitempty" tf:"rolling_period_days,omitempty"`

	// The id to use for this ServiceLevelObjective. If omitted, an id will be generated instead.
	SLOID *string `json:"sloId,omitempty" tf:"slo_id,omitempty"`

	// ID of the service to which this SLO belongs.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/monitoring/v1beta1.CustomService
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("service_id",false)
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// Reference to a CustomService in monitoring to populate service.
	// +kubebuilder:validation:Optional
	ServiceRef *v1.Reference `json:"serviceRef,omitempty" tf:"-"`

	// Selector for a CustomService in monitoring to populate service.
	// +kubebuilder:validation:Optional
	ServiceSelector *v1.Selector `json:"serviceSelector,omitempty" tf:"-"`

	// This field is intended to be used for organizing and identifying the AlertPolicy
	// objects.The field can contain up to 64 entries. Each key and value is limited
	// to 63 Unicode characters or 128 bytes, whichever is smaller. Labels and values
	// can contain only lowercase letters, numerals, underscores, and dashes. Keys
	// must begin with a letter.
	// +mapType=granular
	UserLabels map[string]*string `json:"userLabels,omitempty" tf:"user_labels,omitempty"`

	// A windows-based SLI defines the criteria for time windows.
	// good_service is defined based off the count of these time windows
	// for which the provided service was of good quality.
	// A SLI describes a good service. It is used to measure and calculate
	// the quality of the Service's performance with respect to a single
	// aspect of service quality.
	// Exactly one of the following must be set:
	// basic_sli, request_based_sli, windows_based_sli
	// Structure is documented below.
	WindowsBasedSli []WindowsBasedSliInitParameters `json:"windowsBasedSli,omitempty" tf:"windows_based_sli,omitempty"`
}

type SLOObservation struct {

	// Basic Service-Level Indicator (SLI) on a well-known service type.
	// Performance will be computed on the basis of pre-defined metrics.
	// SLIs are used to measure and calculate the quality of the Service's
	// performance with respect to a single aspect of service quality.
	// Exactly one of the following must be set:
	// basic_sli, request_based_sli, windows_based_sli
	// Structure is documented below.
	BasicSli []BasicSliObservation `json:"basicSli,omitempty" tf:"basic_sli,omitempty"`

	// A calendar period, semantically "since the start of the current
	// ".
	// Possible values are: DAY, WEEK, FORTNIGHT, MONTH.
	CalendarPeriod *string `json:"calendarPeriod,omitempty" tf:"calendar_period,omitempty"`

	// Name used for UI elements listing this SLO.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// The fraction of service that must be good in order for this objective
	// to be met. 0 < goal <= 0.999
	Goal *float64 `json:"goal,omitempty" tf:"goal,omitempty"`

	// an identifier for the resource with format {{name}}
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The full resource name for this service. The syntax is:
	// projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// A request-based SLI defines a SLI for which atomic units of
	// service are counted directly.
	// A SLI describes a good service.
	// It is used to measure and calculate the quality of the Service's
	// performance with respect to a single aspect of service quality.
	// Exactly one of the following must be set:
	// basic_sli, request_based_sli, windows_based_sli
	// Structure is documented below.
	RequestBasedSli []RequestBasedSliObservation `json:"requestBasedSli,omitempty" tf:"request_based_sli,omitempty"`

	// A rolling time period, semantically "in the past X days".
	// Must be between 1 to 30 days, inclusive.
	RollingPeriodDays *float64 `json:"rollingPeriodDays,omitempty" tf:"rolling_period_days,omitempty"`

	// The id to use for this ServiceLevelObjective. If omitted, an id will be generated instead.
	SLOID *string `json:"sloId,omitempty" tf:"slo_id,omitempty"`

	// ID of the service to which this SLO belongs.
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// This field is intended to be used for organizing and identifying the AlertPolicy
	// objects.The field can contain up to 64 entries. Each key and value is limited
	// to 63 Unicode characters or 128 bytes, whichever is smaller. Labels and values
	// can contain only lowercase letters, numerals, underscores, and dashes. Keys
	// must begin with a letter.
	// +mapType=granular
	UserLabels map[string]*string `json:"userLabels,omitempty" tf:"user_labels,omitempty"`

	// A windows-based SLI defines the criteria for time windows.
	// good_service is defined based off the count of these time windows
	// for which the provided service was of good quality.
	// A SLI describes a good service. It is used to measure and calculate
	// the quality of the Service's performance with respect to a single
	// aspect of service quality.
	// Exactly one of the following must be set:
	// basic_sli, request_based_sli, windows_based_sli
	// Structure is documented below.
	WindowsBasedSli []WindowsBasedSliObservation `json:"windowsBasedSli,omitempty" tf:"windows_based_sli,omitempty"`
}

type SLOParameters struct {

	// Basic Service-Level Indicator (SLI) on a well-known service type.
	// Performance will be computed on the basis of pre-defined metrics.
	// SLIs are used to measure and calculate the quality of the Service's
	// performance with respect to a single aspect of service quality.
	// Exactly one of the following must be set:
	// basic_sli, request_based_sli, windows_based_sli
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	BasicSli []BasicSliParameters `json:"basicSli,omitempty" tf:"basic_sli,omitempty"`

	// A calendar period, semantically "since the start of the current
	// ".
	// Possible values are: DAY, WEEK, FORTNIGHT, MONTH.
	// +kubebuilder:validation:Optional
	CalendarPeriod *string `json:"calendarPeriod,omitempty" tf:"calendar_period,omitempty"`

	// Name used for UI elements listing this SLO.
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// The fraction of service that must be good in order for this objective
	// to be met. 0 < goal <= 0.999
	// +kubebuilder:validation:Optional
	Goal *float64 `json:"goal,omitempty" tf:"goal,omitempty"`

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	// +kubebuilder:validation:Optional
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// A request-based SLI defines a SLI for which atomic units of
	// service are counted directly.
	// A SLI describes a good service.
	// It is used to measure and calculate the quality of the Service's
	// performance with respect to a single aspect of service quality.
	// Exactly one of the following must be set:
	// basic_sli, request_based_sli, windows_based_sli
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	RequestBasedSli []RequestBasedSliParameters `json:"requestBasedSli,omitempty" tf:"request_based_sli,omitempty"`

	// A rolling time period, semantically "in the past X days".
	// Must be between 1 to 30 days, inclusive.
	// +kubebuilder:validation:Optional
	RollingPeriodDays *float64 `json:"rollingPeriodDays,omitempty" tf:"rolling_period_days,omitempty"`

	// The id to use for this ServiceLevelObjective. If omitted, an id will be generated instead.
	// +kubebuilder:validation:Optional
	SLOID *string `json:"sloId,omitempty" tf:"slo_id,omitempty"`

	// ID of the service to which this SLO belongs.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/monitoring/v1beta1.CustomService
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("service_id",false)
	// +kubebuilder:validation:Optional
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// Reference to a CustomService in monitoring to populate service.
	// +kubebuilder:validation:Optional
	ServiceRef *v1.Reference `json:"serviceRef,omitempty" tf:"-"`

	// Selector for a CustomService in monitoring to populate service.
	// +kubebuilder:validation:Optional
	ServiceSelector *v1.Selector `json:"serviceSelector,omitempty" tf:"-"`

	// This field is intended to be used for organizing and identifying the AlertPolicy
	// objects.The field can contain up to 64 entries. Each key and value is limited
	// to 63 Unicode characters or 128 bytes, whichever is smaller. Labels and values
	// can contain only lowercase letters, numerals, underscores, and dashes. Keys
	// must begin with a letter.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	UserLabels map[string]*string `json:"userLabels,omitempty" tf:"user_labels,omitempty"`

	// A windows-based SLI defines the criteria for time windows.
	// good_service is defined based off the count of these time windows
	// for which the provided service was of good quality.
	// A SLI describes a good service. It is used to measure and calculate
	// the quality of the Service's performance with respect to a single
	// aspect of service quality.
	// Exactly one of the following must be set:
	// basic_sli, request_based_sli, windows_based_sli
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	WindowsBasedSli []WindowsBasedSliParameters `json:"windowsBasedSli,omitempty" tf:"windows_based_sli,omitempty"`
}

type WindowsBasedSliInitParameters struct {

	// A TimeSeries monitoring filter
	// with ValueType = BOOL. The window is good if any true values
	// appear in the window. One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	GoodBadMetricFilter *string `json:"goodBadMetricFilter,omitempty" tf:"good_bad_metric_filter,omitempty"`

	// Criterion that describes a window as good if its performance is
	// high enough. One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// Structure is documented below.
	GoodTotalRatioThreshold []GoodTotalRatioThresholdInitParameters `json:"goodTotalRatioThreshold,omitempty" tf:"good_total_ratio_threshold,omitempty"`

	// Criterion that describes a window as good if the metric's value
	// is in a good range, averaged across returned streams.
	// One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// Average value X of time_series should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	MetricMeanInRange []MetricMeanInRangeInitParameters `json:"metricMeanInRange,omitempty" tf:"metric_mean_in_range,omitempty"`

	// Criterion that describes a window as good if the metric's value
	// is in a good range, summed across returned streams.
	// Summed value X of time_series should satisfy
	// range.min <= X <= range.max for a good window.
	// One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// Structure is documented below.
	MetricSumInRange []MetricSumInRangeInitParameters `json:"metricSumInRange,omitempty" tf:"metric_sum_in_range,omitempty"`

	// Duration over which window quality is evaluated, given as a
	// duration string "{X}s" representing X seconds. Must be an
	// integer fraction of a day and at least 60s.
	WindowPeriod *string `json:"windowPeriod,omitempty" tf:"window_period,omitempty"`
}

type WindowsBasedSliObservation struct {

	// A TimeSeries monitoring filter
	// with ValueType = BOOL. The window is good if any true values
	// appear in the window. One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	GoodBadMetricFilter *string `json:"goodBadMetricFilter,omitempty" tf:"good_bad_metric_filter,omitempty"`

	// Criterion that describes a window as good if its performance is
	// high enough. One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// Structure is documented below.
	GoodTotalRatioThreshold []GoodTotalRatioThresholdObservation `json:"goodTotalRatioThreshold,omitempty" tf:"good_total_ratio_threshold,omitempty"`

	// Criterion that describes a window as good if the metric's value
	// is in a good range, averaged across returned streams.
	// One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// Average value X of time_series should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	MetricMeanInRange []MetricMeanInRangeObservation `json:"metricMeanInRange,omitempty" tf:"metric_mean_in_range,omitempty"`

	// Criterion that describes a window as good if the metric's value
	// is in a good range, summed across returned streams.
	// Summed value X of time_series should satisfy
	// range.min <= X <= range.max for a good window.
	// One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// Structure is documented below.
	MetricSumInRange []MetricSumInRangeObservation `json:"metricSumInRange,omitempty" tf:"metric_sum_in_range,omitempty"`

	// Duration over which window quality is evaluated, given as a
	// duration string "{X}s" representing X seconds. Must be an
	// integer fraction of a day and at least 60s.
	WindowPeriod *string `json:"windowPeriod,omitempty" tf:"window_period,omitempty"`
}

type WindowsBasedSliParameters struct {

	// A TimeSeries monitoring filter
	// with ValueType = BOOL. The window is good if any true values
	// appear in the window. One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// +kubebuilder:validation:Optional
	GoodBadMetricFilter *string `json:"goodBadMetricFilter,omitempty" tf:"good_bad_metric_filter,omitempty"`

	// Criterion that describes a window as good if its performance is
	// high enough. One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	GoodTotalRatioThreshold []GoodTotalRatioThresholdParameters `json:"goodTotalRatioThreshold,omitempty" tf:"good_total_ratio_threshold,omitempty"`

	// Criterion that describes a window as good if the metric's value
	// is in a good range, averaged across returned streams.
	// One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// Average value X of time_series should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	MetricMeanInRange []MetricMeanInRangeParameters `json:"metricMeanInRange,omitempty" tf:"metric_mean_in_range,omitempty"`

	// Criterion that describes a window as good if the metric's value
	// is in a good range, summed across returned streams.
	// Summed value X of time_series should satisfy
	// range.min <= X <= range.max for a good window.
	// One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	MetricSumInRange []MetricSumInRangeParameters `json:"metricSumInRange,omitempty" tf:"metric_sum_in_range,omitempty"`

	// Duration over which window quality is evaluated, given as a
	// duration string "{X}s" representing X seconds. Must be an
	// integer fraction of a day and at least 60s.
	// +kubebuilder:validation:Optional
	WindowPeriod *string `json:"windowPeriod,omitempty" tf:"window_period,omitempty"`
}

// SLOSpec defines the desired state of SLO
type SLOSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     SLOParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider SLOInitParameters `json:"initProvider,omitempty"`
}

// SLOStatus defines the observed state of SLO.
type SLOStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        SLOObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// SLO is the Schema for the SLOs API. A Service-Level Objective (SLO) describes the level of desired good service.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcp},path=sloes
type SLO struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.goal) || (has(self.initProvider) && has(self.initProvider.goal))",message="spec.forProvider.goal is a required parameter"
	Spec   SLOSpec   `json:"spec"`
	Status SLOStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// SLOList contains a list of SLOs
type SLOList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SLO `json:"items"`
}

// Repository type metadata.
var (
	SLO_Kind             = "SLO"
	SLO_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: SLO_Kind}.String()
	SLO_KindAPIVersion   = SLO_Kind + "." + CRDGroupVersion.String()
	SLO_GroupVersionKind = CRDGroupVersion.WithKind(SLO_Kind)
)

func init() {
	SchemeBuilder.Register(&SLO{}, &SLOList{})
}
